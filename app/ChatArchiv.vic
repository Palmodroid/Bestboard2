@s7[CHAT]
~~CLOSETOC~~

;;y/owr:[[start|Főoldal]] · [[http://lattilad.org/vicky/doku.php/thon/chat?do=recent|Változások]] · [[files]] · [[coat1000|Szintaxis]];; · //Utolsó módosítás: @LASTMODBY, @LASTMODAT//

@s5[Tesztelendő változat]

@uj@app[170812]

Zöldbékás változat...

@s5[Lassulások]

Erről a kérdésről már beszéltünk korábban. Az ún. IME (vagyis a billentyűzet) szigorúan a rendszer által üzemeltetett service, aminek néhány részét módosíthatjuk. (Ja, és senki nem ír róla semmit, alig lehet info-t találni)

A képernyő megérintésekor értesítést kapunk. Ebből néhány tíz sor alatt kitaláljuk, hogy az melyik billentyű, és rögtön elküldjük a leütött kódot. Ezt a részt már kétszer átnéztem, semmi sincs benne, ami bármiféle lassulást okozhatna.

Ettől külön áll a megjelenítés. Itt már lehetne hiba, ugyanis minden egyes érintésnél küldjük a képet. Viszont ezt kipróbáltam, a fentiektől függetlenül működik. Ha belassul, akkor néhány képet kihagy, amit nem veszel észre. De nem áll meg. Ez viszont kipróbálható: a beállításokban a vonalhúzás ill. a billentyűpirosítás is kikapcsolható. (Show touched keys ill. Show stroke on keyboard opciók)
@lad[Nálam már nem piros, hanem zöld. :D]

A másik a log, ami jelentősen lassíthat. EZ feltétlen legyen kikapcsolva! (Enable developer log) A log ugyanis ír egy file-t is, néha törli és másolja. Mindezt ugyan "háttérszálon", de ettől még időigényes lehet.

Ha ezek után is van lassulás, akkor ellenőrizni kell minden egyes futó folyamatot (nem tudom még, miként), mert valamelyik program néha annyira lefoglalja a gépet, hogy nem kapjuk meg a vezérlést. Lehet, hogy ez olyankor is bekövetkezik, amikor nem piros a bill., csak nem látjuk. A puffer gyűjti az érintéseket, csak nem kap lehetőséget arra, hogy átadja.

Ezt úgy tudjuk majd ellenőrizni, hogy az érintés-küldés idejét logoljuk. (Nem is az érintést, hanem amikor megkapjuk az érintést). Ha ez az idő hosszú, akkor a hiba nálunk van. Ha egységesen rövid, akkor a rendszer (vagyis más program) okozza a késést.

Ezt egyébként még egy dolog alátámasztani látszik: az új (6.vmennyi) androidon néha kiírja, hogy egy program túl sok erőforrást használ. Ilyen régen nem volt, most viszont sokszor a legváratlanabb programokat kiírja.

Ettől persze nem tudom, hol az igazság. Jó lenne, ha reprodukálni lehetne. Jó lenne, ha minden program letiltása mellett ki tudnánk próbálni. Egy csomó dolog jó lenne... de addig is a fenti hármat tudom javasolni. Az ellenőrzést meg majd megcsinálom valahogy. 

Még egy: ez a rész a legrégebbi, és nem módosult szinte semmit. Vagyis évek óta használod. Ha a lag most jelent meg (avagy vált gyakorivá), akkor megint csak valahol másutt érdemes az okot keresni.
@ulad[Hát ez az, ezért nem sipákolok folyton, hogy de lassú, de lassú. Folyton lődözöm lefelé a taszkokat, és akkor valamivel jobb, de képtelen vagyok megtalálni, mi fogja vissza a gépet. Ezért nem akarnék elpusztítani rajta mindent.]

@s5[Tesztelendő változat]

@app[170605]
@lad[…vajon miért nem működnek újabban a file-letöltések… ez is csak ftp-n át jött le…]
@thon[Fura. Itt működik. Igaz, most megint elköltöztem két hétre, 15-én kezdünk majd véglegesen költözni. Addig meseszerű a net: hol volt, hol nem volt...]

@thon[A monitor row megérintésével két újabb billentyű is felbukkan. A STORE eltárolja az éppen aktuális billezetet. A RECALL visszahívja az utolsó eltárolt változatot (ha van ilyen). Ezt azért kell tesztelni, mert eredetileg egyetlen adathalmazt szerettünk volna, ezért a statikus és változó adatokat egybekevertem. Most úgy működik a tárolás, hogy a coat file feldolgozása utáni ponton lép be a program, és innen mindent újragenerál. Elvileg ezzel megoldódtak a problémáink, de nem vagyok teljesen biztos benne. Úgyhogy próbálgassuk! Közben megoldom, hogy a felület könnyebben kezelhető legyen.]
@lad[Hát látni látom ezeket a gombokat remekül, de megint bamba vagyok, mely problémákat oldanak ők meg?]
@thon[Ők speciel még semilyet, de a segítségükkel (STORE) tárolunk egy aktuális soft-board-ot, amihez vissza tudunk térni később (RECALL). Az nem tiszta, hogy pontosan melyik állapotba térünk vissza, mi van, ha módosítjuk a szöveget, ha egy rövidítés közepén vagyunk stb, vagy csak épp tele lesz a memória. Gondoltam, addig is nézegessük; de a végleges természetesen kézre állóbb felület lesz.]

@s5[Új chatoldal]

S megoldottam a láthatatlan bill-t! Jó éjt. Köszi a fáradozást, innen csak a postagalamb műxik... 

@lad[Hol van az az itt? És milyen a láthatatlan?]

Itt: Nagy Falu.

Nézd meg: @app[170517], főként, hogy feltöltötte-e jól. Másrészt a MONITOR ROW-t megérintve lesz egy SET és egy DRAFT billentyűd (maga a monitor row láthatatlan billentyű, mert ugye nem rajzol hatszöget. Még nem a teljes megoldás, de ezzel kezdhetsz új boardok építésébe. A SET/File Selector eddig a megoldás, de majd igyekszem ezt gyorsítani. A szöveges rész csak azért van ott, hogy ki tudjuk próbálni a billezetet. Sólj majd a kezdeti tapasztalatokról!
@lad[Mögy remekül. Azért az a fallback billezet szerintem érdemes lenne.]

@lad[Hát ebbiza nincsen föltöltve, a szerveren nyoma sincs.]

Most van. Elvileg az előbb is volt, vagyis megjelent a feltöltöttek között. De az oldal csak tekert, csak tekert... Bezártam. Újra nekifutottam, most talán jó. Nagyon bizonytalan a net, leginkább a mobil működik, aranyárban. Vagyis nem az ár az érdekes, azt úgyis ki kell fizetni, de igen kicsi a mennyiségi korlát. Képek, videók már nemigen férnek bele...

@lad[Most már megvan, bár letölteni csak ftp-vel tudtam. Fura egy elmaradott falucskába csöppentél, főorvos uram. De így van ez jól, vihetsz gyógyulást, kultúrát, civilizációt a bennszülötteknek…]

@thon[Hogy-hogy ftp? Ugyanúgy töltöttem fel. Na mind1. Naná, hogy lesz fallback billentyűzet, csak lassan megy. Elvileg itt lenne egy első és egy második gombóc, ami a két billezet között vált. Az mekkora gond szerinted, ha váltásnál újrarajzolja a billezetet? A szerkesztettnél kifejezetten előny, de a másiknál kis időveszteség. Viszont különben az egész programstruktúrát is tárolni kellene. Egyébként ez az elgondolás segít a szerkesztésben?]

@lad[Két billezet közötti váltáshoz elég egy gombóc, meglátásom szerint. Az autót is egy gombbal kapcsolom ki és ugyanazzal be. Ha újrarajzolás alatt az értendő, hogy megjelenik a kék képernyő a kabátgombbal, és percekig ülünk és malmozunk az ujjunkkal, az nem szívderítő, de ha nincs más, akkor nincs más. Minden apró fejlesztés segít a szerkesztésben, szerintem.]

@lad[Rájöttem, hol a bibi. Betöltesz egy billezet, amin nincsen settingsgomb. És nem kapcsoltad be a monitorsort. Ahhoz, hogy beléphess a settingsbe, kell a monitorsor, de azt csak a settingsben tudod bekapcsolni…]

Ok. Dolgozom rajta. A settings elérhető a fő settingsben, ott be lehet kapcsolni a monitor-sort. Egyébként a fejlesztéshez kelleni fog a monitor-row, nincs más ötletem, hogy azt miként lehetne máshogy megoldani. De a beállítások/Nyelv és Bevitel alatt mindig elérhető a settings.

@lad[Ja igen. Ezt mindig elfelejtem. Más. Említettem korábban, hogy böngiben – akár ebben a szerkesztődobozban is, ha a word wrap be van kapcsolva – nagyon lelassul, megbízhatatlanná válik, összebetűket a keveri. Az jutott eszömbe: nem lehet ezt valami clipboardos trükkel megoldani? Persze ki-bekapcsolhatóan, mondjuk szavanként küldeni a szöveget clipboardon át… Nem tudom igazából, csak hangosan gondolkodom. Annyira könnyedén lehet írni ezzel a jószággal, hogy valósággal fáj, amikor mégse.]

@thon[Nem tudom elképzelni sem, mi a probléma. Az összes billentyűzet ún. IPC - inter-process-communication segítségével küldi az adatokat, ami igen lassú, és nem is szinkronizált folyamat. Mi - természetesen - megfelelő sorrendben küldjük el az adatcsomagokat. Nem tudom, hogyan lehetne máshogy jelezni a sorrendet. Próbáld ki másik billezettel is! Úgy működik rendesen?]

@lad[Örömmel kipróbálnám, csak most valamiért a sajátunkon se tudom reprodukálni. Sweetie olyan lassú volt, mint az államapparátus, erre újraindítottam, és tök sima a billezet még Chrome-ban is, bekapcsolt word wrap mellett.]

@thon[Ez is amellett szól, hogy nem a mi készülékünkben van a hiba...]

@s7[Régi szövegek archívuma 2017. június 6.]


@s5[LayoutView módosítás Navigation Bar miatt]

@app[170317]

A Navigation Bar bevezetésével a képernyő kezelése módosult. Mivel eddig hard-key-jel ellátott készülékeken dolgoztunk, ez nem okozott hibát. Navigation Bar esetén azonban a rendszer a billentyűzet megjelenése ALATT módosítja a kép beállításait. Kapunk egy újabb hívást a Navigation Bar méretével csökkentett szélességgel és a már kiszámított magassággal. Ezt a korábbi algoritmus nem tudta feldolgozni, mert fix értékeket várt. Nos, kijavítottuk.
@lad[Klassz, bár nem tudom, hogy öszik-e vagy isszák.]
@thon[Emlékeztetőnek álljon itt egy részletesebb leírás! Android alatt a "layout" méretének meghatározása több lépcsőben fut le. Az ún. onMeasure metódus emiatt több alkalommal kap információt a rendelkezésre álló helyről, és ennek ismeretében mondhatja meg, hogy mekkora legyen a layout mérete. A korábbi verziókban (navigation bar nélkül) a metódus MINDIG a teljes képméretet kapta meg, és ebből számolta ki (ismert szélességhez arányítva a magasságot), hogy mekkora területre van szüksége. Az új verzió első körében megkapjuk a teljes képméretet, melyből kiszámításra kerül (helyesen) a tényleges méret. Ekkor jelenik meg a navigation bar, és kapunk egy új szélességet, de! visszakapjuk a már kiszámított magasságot, hiszen az előbb kértük, hogy erre van szükségünk. Ez szerintem ugyan egy logikai hiba, de így történik. A korábbi algoritmus szorgalmasan újraszámolta a méretet, de a hibás magasságból. Emiatt a kép torzult; kb. a fele magasságot érte el. Az új metódus nem egyszerű, mert nem tudjuk, hogy mikor érkezik info a teljes és mikor a számított magasságértékről. Ezt úgy tudjuk megoldani, hogy tároljuk a teljes és számított magasság értékét. Ha a rendszertől kapott érték a számítottnak felel meg, akkor helyette a teljes értéket használjuk. Ha nem akkor a kapott értéket a teljes magasságnak vesszük. Ezt a módszert is "át lehet verni", ha a számított magasság éppen megfelel az elfordított készülék magasságának; de ezt a hibát még nem tudom megoldani.]

* * *

@thon[Nem vesztem el, de nagyon sok gond és teendő van most, majd foglalkozom még ezekkel ]

@thon[Az új tesó: ASUS Zenphone 3 Max, vagyis Maxi. Két kártya kellett, az előző akksi meg feladta a harcot. Ami gond: Android 6 Marshmallow - semmi nem úgy műxik, ahogy kéne. Dolgozom az ügyön, rá is jöttem, hogy mik a bajok. Párhuzamosan arra is rájöttem, hogy a monitor-sort fogjuk használni a feljlesztésre, négy gombbal: Settings/Draft/Test keyb./Fallback keyb. - utolsó kettő közötti váltás lehet egy gomb is. Más: az előző ötletem bővült, és van más ötletem is, de olyan helyen szeretném megbeszélni, ami védett. Van nekünk ilyen? Ne lehessen kintről elolvasni, tárolni stb. Nem mintha súlyos titok lenne, csak úgy.]
@lad[Hát a] [[:privat:thon]]

@thon[Úgy hívják az állatot, hogy Cerber Ransomware. Konkrétan semmi nem maradt utána. Vagyis minden, csak hozzáférhetetlenül. Szóval, komplett agycsere a gépnek, ami egy jó darabig nehezen fér bele az időmbe...]
@lad[És nincsen neki ellenszere? Minden ilyesminek lenni szokott.]
@thon[Vagy tíz éve nem volt tetvem. Ez viszont a létező legjobb; nincs ellenszer. Illetve 150e Ft értékben bitcoin az írások szerint, akkor küldik a dekódóló kódot. Tor-ról. Jó mi? A szakértők javaslata: csináljunk egy másolatot, hátha lesz majd ellenszer egyszer. Van még egy lehetőség: elköltözünk Azerbajdzsánba, mert néhány ország védett a féregtől.]
@lad[És gugli mit mond arra, hogy cerber ransomware removal? Mert nekem használhatónak tűnő találatokat ad.]
@thon[Elremovolja, vagyis további kárt nem tesz. Viszont a registry-t is károsítja (belerondítja a kódjait) és a bekódolt adatok ettől még nem jönnek vissza. Egyébként baromi érdekes, mert a gép amúgy tökéletesen működik. Merthogy kizárólag a TE adataidat rongálja, .jpg, .doc, .pdf ilyesmi, de pl. a download-ban még azt sem. A .bbcode és a .java is megmaradt, de azokról van másolat. A .ppt előadások viszont nem. És ami még rossz: a neveket is kódolja, vagyis azt se tudod, mi volt a mappában előtte. Szóval csúnya jószág.]
@thon[Amúgy nem vész, mert semmi igazán lényeges nem volt. Vagy hát, csak olyan, amit én írtam; az pótolható. Volt egy HP letöltés, talán neked megvan. De soha nem mentem bele. A bosszúság a legnagyobb, nincs net, nincs technika, haza kellett cincálni a gépet, hogy legyaluljam. Cipelhetem, meg hát az alig itthon töltött időben sem agyatlan windowst akartam telepíteni. Szóval linux lulez! Akarom mondani: rulez! Az alatt ugyanis nincs vírus...]
@lad[Ja, igen, HP persze megvan itthon, bár lehet, hogy már szétraktam azóta, több száz giga könyvet raktam rendbe, és még van bőven, ami rumlis.]
@thon[Dorka (éppen most): Képzeld Apa! Egy ház, ahol működik a wifi és még gyors is! - Na ez leírja a pesti helyzetet pontosan.]
@lad[Hátha egyszer kipróbálhatja még minálunk is. A nyári upgrade óta egész jó. Mondjuk akiknek csináltam, azok sose látták.]

@thon[Annyi számítógépes ismeret van Kissy-ben. Ez is megérdemelne egy említést. Határozottan ötletes, de durva vírus.]
@lad[Végül is…]

@lad[Valamit csinálni kell a settingsszel, egyszerűen képtelen voltam elérni, ha nem volt rá külön gomb a fallback billezeten. Néha akkor se, mert a logablak jött helyette.]

@lad[Betettem a fallbackre a kulcsszavakat is, csak olvashatatlan. Ha lekicsinyítem a betveket, azért lesz olvashatatlan. Ha rövidítem a jó hosszú kulcsszavakat, akkor meg érthetetlen lesz. Micsináljak?]

@s5[Elgondolás a szerkesztőről]

@lad[(Nagy részét megbeszéltük személyesen, de legyen meg itt is.)]
@lad[Legyen egy parancs a settingsben, hogy „kapcsolj szerkesztő üzemmódba”. Azért ott, mert elérhetőnek kell lennie, akármilyen billezetet készítettünk magunknak. A parancs hatására két billezet jelenik meg, egy szerkesztés alatt álló, ami amúgy teljesen működőképes, és egy fallback. A szerkesztés alatti ugyanúgy cserélhető, mint máskor, a fallback fix. A fallbacket hamarosan megtervezem.] @lad[Első változat kész, feltöltve!]
@lad[A normál billezetet át lehet szerkeszteni a szövegszerkesztőben, ki kell menteni, aztán a) a program magától észreveszi a változást, mert szerkesztőmódban figyeli ennek az egy file-nak a módosítási idejét, b) meg kell nyomni egy gombot. Az a) változat jobban tetszene. Újraolvassa a file-t és megmutatja az új képet.]
@lad[A fallback tartalma: angol ábécé, számjegyek, az U+007F alatti írásjelek, szóköz, Enter, Tab; backspace; copy, cut, paste; kurzornyilak; a Coat nyelv kulcsszavai, illetve struktúrái. És egy draft gomb, ha nem figyeli a file módosítási idejét.]
@lad[A fallback persze akkor is használható, ha valakinek a rendes billezete nem latin betűs, és a latin betűs részből csak ezek a karakterek kellenek neki; így elkerülheti, hogy latin betűs részt is kelljen terveznie hozzá csak azért, hogy webcímeket írhasson be. Ezért a fallbacket úgy kell elkészíteni, hogy általános célokra is alkalmas legyen.]

@lad[No, elkezdtem a fallback billezetet. És rögtön látszik, miért kell a fallback billezet. Két zárójelet rossz helyre tettem, és egy többkarakteres szövegkonstanst aposztrófok közé tettem, amire kaptam tíz hibát és egy töküres billezetet. Ha csak egy programka lenne, akit most találtam frissiben a neten, akkor a fejemet fognám és már nyomnék is az uninstallra. Ezért kell nekünk fallback billezet, hogy a gép fölötti uralom akkor is megmaradjon, ha a tervező hibát csinált.]

@s5[Gyerek]

@lad[Nos, főorvos úr, tudom már, hol veszett el a sok bába között a gyerek. Annyira sokat tud, annyira remekül van megtervezve, annyira kifinomult, hogy egy nagyobbacska csomag áttervezése már meghaladja az ember türelmi szintjét – az elkészítéséről nem is beszélve. Most például kigondoltam, hogy beiktatok soronként egy gombot, vagyis kettővel növelem a ''halfcolumns''t, ezt meg is tettem, kaptam egy-egy gombnyi helyett jobbról. Én balról szerettem volna, tehát a berakogatott ''block''okat eltologattam eggyel jobbra. Kiderült, hogy a Symbol Shift gombom helye külön van definiálva, helytelen, de tény. Megkerestem, eltoltam. Lett egy-egy gombnyi helyem balról, kivéve két gombot, akik szintén külön vannak definiálva. Ekkor átgondoltam, mi minden kell ahhoz, hogy a cikcakkos üres oszlopot kitöltsem gombokkal, definiálni kell egy ''block''ot, megtölteni gombokkal, a helyére beilleszteni, hogy inkább sürgősen visszacsináltam az egészet, mielőtt túl sok lenne a visszacsinálnivaló.]
@lad[Meglátásom szerint az átlagember az életben nem fog nekiállni megírni egy Coatot, és a programozó lelkületűek is csak egyszerűbbekre vállalkoznak. Rajtunk kívül még négyen vannak regisztrálva a ''bestboard'' felhasználói csoportba, és eddig nem jelentkeztek alkotásaikkal. Én se álltam neki küzdeni vele, amióta nagyjából tudja a minimumot, amire szükségem van, pedig én mániákus vagyok.]
@lad[A megoldás nem az, hogy tudjon kevesebbet vagy legyen egyszerűbb a szintaxisa vagy a szemantikája. Azt tudja, amit tudnia kell, és a nyelv semmivel se bonyolultabb a szükségesnél. Nem itt leli meg végső nyughelyét a blöki. A megoldás egy többé-kevésbé WYSIWYG szerkesztő. Jelenleg már ott megkeserítjük a felhasználó életét, hogy ha nincsen egy stabilan használható billezete (ábécé, írásjelek, számjegyek, Enter, draft gomb), akár mert még az elején tart, akár mert elrontotta és egymásra rajzolódnak a gombok vagy hibaüzenettel leáll a cucc, akkor vagy PC-n szerkeszt, mely esetben nem lát semmit, vagy egy másik billezetprogrammal, mely esetben nem lát semmit, vagy szenved karaktertáblával meg ami van. Eleve a kék hátterű hibaüzenet nem maradhat, mert a Windowson cseperedett felhasználó lábrázást kap tőle, azt hiszi, hogy leállt a gépe (ráadásul akkor is megjelenik, amikor rendszerindítás után még csak a parsing folyik, és később kapjuk meg a billezetet), az csak akkor jelenhet meg, ha tényleg hiba van, de akkor sem az, hanem egy egyszerű kis QWERTY fallback billezet, amin megvan minden, amivel Coatot lehet szerkeszteni; és akkor vagyunk mosolygós kövérek, ha a fallback billezet meg a normális között egy gombbal lehet ide-oda kapcsolni.
De akkor se ússzuk meg WYSIWYG szerkesztő nélkül. Meglátásom szerint enélkül a felhasználók száma bármekkora lehet ugyan, ha csinálunk szép billezeteket, és akkor azokat használni fogják, de újakat szerkeszteni nem – vagyis nem valósul meg az alapelv, hogy mindenki csinálja meg a saját kiosztását –, de a billezettervezők száma nulla lesz, és ebbe már minket kettőnket is beleszámítottam. Vagy Te gyártasz Coatokat azóta is, és a szám valójában már egy főre rúg?]

@thon[Ezen már én is törtem a fejem. Csupán két gond van: 1. a szerkesztő valamivel hosszabb feladat, mint maga a bill. 2. Pont ezt a feladatot: vagyis a meglévők széttolását, új beillesztését tudom elég nehezen elképzelni. No, persze. Amint leírtam, támadt egy ötletem! Block szerkesztőre van szükség, és a blokkokból össze tud rakni egy komplett billentyűzetet!]

@s5[Caps - átmenetileg maradt - és kiegészül ALFÁ-val]

@uj@app[161009]

Az 'ALFA int' egy érdekes parancs, ugyanis nem a softboardra, hanem a tokenizáló részre hat. Ettől kezdve minden szín, ami nem tartalmaz alfa értéket (csak rgb-t), az nem az FF teljesen átlátszatlan értéket kapja, hanem azt, amit itt megadtunk. ALFA értéke 0-255 lehet, akár hexában megadva (0x bevezetővel persze). A 0c kódok itt nem jók, mert ez nem egy szín, hanem a szín egyik paramétere. Bár csak 8 bitet használ a számból, tehát 0c még működhet is, de akkor sem helyes. Ez ott fog nagyon jól jönni, ahol a színeket névvel adjuk meg (és emiatt nincs alfa csatornájuk), ill. ha háttérképet rakunk be, akkor egyetlen ponton lehet az átlátszóságot növelni vagy csökkenteni. 

@s5[véletlenül caps is lett]

@uj@app[160925caps]

Ez egy érdekes dolog: ez a változat a teszt miatt született. A PacketTextSimple HELYETT kompletten egy PacketTextCaps elnevezésű packetet használ, ami annyival tud többet, hogy az alapértelmezett felirattal követi a CAPS beállításait.
Ez persze jó, csak éppen így minden érintésnél minden billentyűt újrarajzol. Ezt ugye el akartuk kerülni korábban. Ez a módszer akkor lenne jó, ha nem minden érintésre (kis pötty), hanem csak minden billentyűváltásra rajzolná újra magát. Ehhez viszont az egész rajzrendszer felújítása kell(ene); ez most nem lesz meg. Azért működik, pláne ezeken a komolyabb gépeken. Ha a STROKE opciót kikapcsoljuk, akkor nem is eszik nagyon sokat.

@thon[Kérdés: van-e értelme annak, hogy ezt a packetet is elérhetővé tegyük coat alól? Ugyanúgy, ahogy van TEXT, lenne mondjuk CAPSTEXT is? (Ebben a verzióban Minden TEXT így működik). A válasz a fenti okok miatt ráér; majd meglátjuk. Lehet, hogy a majdani Fieldbe kerül beépítésre.]
@lad[Ezt a koncepcicót nem egészen értem. (Eufemizmus ahelyett, hogy egyáltalán nem.)]
@thon[Nem baj, még én se tudom, hogy mit akarok csinálni. Csak valahogy feleslegesnek tűnik, hogy a kis '?' és nagy '?' kérdőjel között is különbséget tegyünk, noha most ez történik. De majd inkább a program találja ki, hogy különbözik-e a kicsi a nagytól, ne a coat író.]
@lad[Hát kis és nagy kérdőjelet még nem ettem.]

@s5[és még csini is]

@app[160924]

Pl. így: ADDLAYOUT ( ID lay2p HEXAGONAL ALIGN odds ROWS 4 HALFCOLUMNS 20 LINECOLOR fuchsia LINESIZE 2 PICTURE "assisi.jpg") 
Mivel a layout-hoz tartozik azon belül kell megadni: LINECOLOR color - a kontúrvonalak színe, LINESIZE integer - a kontúrvonalak vastagsága, PICTURE "képfile" - a háttér képe. Értelemszerűen ilyenkor a COLOR felesleges.
Van még vele probléma: 1. lassú 2. eszi a memóriát (akár el is fogyhat) De legalább jól néz ki.
A színeknél érdemes az 'A' részt (0cARGB vagy 0cAARRGGBB formában) alacsonyra venni.
@lad[Nem tűntem ám el (annyira), csak kínlódok ezzel a sok mindennel. Azért ezt megnéztem. Tényleg jópofa, én csak egy fotót raktam be mögé, de ez igazából arra lesz jó, hogy a gombokra tett feliratoknál összetettebb magyarázatokat adjanak a kiosztásokhoz.]
@lad[Olyat lehet-e, hogy a feliratokhoz használt fontot is layoutonként adhassuk meg? Merthogy jelenleg a bráhmi írásos billezetemnek külön coatban kell lennie, mivelhogy a rendeshez használt font nem tartalmazza ezeket az írásokat.]
@thon[Mindig attól tartok, hogy elfogy a memória, de aztán sohase. A fontkészlet idióta módon van megoldva: be kell olvasni az egészet. Ha nyolcat használsz, akkor nyolc teljes készletet. Emiatt (és az egységes stílus miatt) maradt a font a teljes softboardhoz egy. Mert egyébként feliratonként is meg lehetne adni, nem csak layoutonként. Viszont: ezen mégse változtatnék, mert szerintem jobb lenne a LOAD használata ilyen esetekben, vagyis megnyitni egy új softboardot a billentyűzetről. Igaz, hogy ez pár másodperc, de ezeket úgyis ritkán használjuk. Viszont cserébe nem foglaljuk el a fél világot (ez a Te gépeden nem gond, de az összes kínai, gyengébb masinán igen), és még a coat is áttekinthetőbb.]
@lad[Ja, LOAD, az nem jutott eszömbe.]

@thon[Ezeket tényleg csak a játék kedvéért tettem bele. A kód viszont megint elnyargalt, anélkül, hogy dokumentálni tudtam volna az eseményeket. Nem is akarok hozzányúlni, mert már nem tudom az összes kapcsolódási pontot fejben tartani. Végig kell gazolnom az egészet, leírni a főbb működési elemeket, és akkor bátran lehet módosítani. Ha van időd, akkor inkább az eddigiek helpjére meg példaprogramjaira gyúrjunk. Én közben igyekszem komplettálni a még hiányzó részeket. Ha már felkerül a google-play-re, és látjuk, hogy ki mire használja, mi az ami a legjobban hiányzik belőle, akkor bővíthetjük bármelyik irányban.]
@lad[Időm az rengeteg… nem csinálok semmit. Csak túl sok ez egyszerre, várni a CT eredményére, várni arra a szegény kislányra, várni, hogy elkezdhetem-e az életem új fejezetét és az miről fog szólni, vagy éppen most ér véget az egész. Azt hiszem, depis vagyok még mindig.]
@thon[Nem nagyon értek a copd-hoz, de tudomásom szerint az nem lesz egyik pillanatról a másikra. Másrészt meg légzésfunkció kell a felméréséhez. Biztos, hogy neked az van? A múltkor még csak nem is köhögtél. Másrészt amikor nagyon erős volt az allergiám, én is sokszor befulladtam. De aztán az allergia szűntével ez is elmúlt. Ezt inkább csak laikusként és együttérzéssel kérdezem, a tüdőről kb annyit tudok, hogy merre kell keresni...]
@lad[Volt légzésfunkció, elég gyatra eredményt hozott, de sokat köhögtem is épp. Július óta köhögök nagyon, 23-án este volt a kritikus pont, amikor Hajni először aludt mellettem, és úgy köhögtem, hogy stresszbe estem, hogy fölébresztem szegényt (Hajnalka óta talpon volt és dolgozott, és másnap is helyt kellett állnia a munkában), úgyhogy összejött egy remek pánikrohamom, életemben a második. Nem tudom, hogy tényleg COPD-e. Ezt diagnosztizálták. A kérdés nem ez, hanem hogy mi okozta. Talán holnap megjön a lelet és megtudom, hogy van-e tüdőrákom, cisztás fibrózisom, mit tudom én, miféle halálos nyavalyám. És ha nincsen, akkor várnom kell Hajnira, hogy elkezdhetem-e az életemet elölről.]

@s5[KEEPCODE]

@app[160923]

Az ADDVARIA részben szerepelhet a KEEPCODE flag. Ilyenkor a varia billentyűk kiválasztásánál NEM tűnik el a kód, csak kiválasztja a billentyűket. Hosszabb kóddal akár másik variát is választhatunk. A felismert kód CSAK AKKOR tűnik el, ha KÖZVETLENÜL a kód után leütjük az egyik kiválasztott varia billentyűt. KEEPCODE nélkül a felismert kód azonnal törlődik (és nem folytatható). Természetesen a rövidítések továbbra is így működnek.
FONTOS! Minden esetben AUTO/FIND/VARIA a LEGHOSSZABB egyezőt keresi a rendszer!! (Eddig VARIA és AUTO a legrövidebb egyezést kereste.)
Egy.txt tartalmazza a példát.
@lad[Mindjárt kipróbálom ezt is.]
@lad[Ez egész klassz. Csak nekem nem a leghosszabb egyezőt kereste, vagy én vagyok bamba valahol, de pillanat, ellenőriztem] [[https://play.google.com/store/apps/details?id=com.pleco.chinesesystem|Plecóban.]] @lad[Beírtam a felső keresősorba, hogy **zhong2** és kiválasztottam a legelső írásjegyet, aki ez 仜. A Plecóban nem tűnt el a kód, nyilván nem kompatibilis, oké. Csakhogy aztán elég volt megnyomni a Done gombot és megtudtam, hogy az írásjegy ejtése **hóng** (vagyis **hong2**).]
@lad[Hopp, megvan a hiba! Minden visszavonva. **Zhong2** ejtésű írásjegy nincs is az adatbázisban, persze hogy **hong2**-t ad helyette, mert az viszont van!]

Ezzel a módszerrel nagyon komoly módosuló billezeteket lehet gyártani. Alapos próbálgatás kell viszont, hogy minden részében megismerjük és kipróbáljuk.

@s5[Buggabb]

@lad[Va egy problémám, azt hiszem, elég zavaró. Bár a kíai biltyűzetet tartalmazó layt st em aktív, sőt újraidítottam a prograt, továbbra is azoal eltüteti az összes fölismert pi kódot! Például az összes mit Nádor betűt (em méltóságév, haem keresztév, a közepé is va egy N, azoba az azoal eltűik, csak a agybetűs marad meg, mert case sesitive a fölismerés). Meg a st szóból (st = azoal, ebbe a pillaatba) is eltűik a MO, mert érvéyes kód. Szóval midjárt megyek a szövegszerkesztőmbe és kiremem a pi (= PĪNYĪN) részt…]

@thon[Az a baj, hogy ez nem bug, hanem tényleg így működik. Vagyis a program teljesíti a megfogalmazott elvárásokat, csak éppen az elvárások rosszak. Ki kéne találni, hogy miként működjön; de ezt csak akkor tudjuk megtenni, ha már van (rossz) kiindulási alap. Pl.: a varia nem kapcsolható, hiszen hozzátartozik a billentyűzethez (váltogatja a billentyűket). Szóval alkossunk ötleteket, hogy miként lehet ezt jól működtetni.]
@lad[Értelek. A recsegés, amit hallasz, fejtörésemtől származik.]

@lad[Nos, gondolkodtam, és arra jutottam, hogy függetlenül a shortcut és a varia közötti különbségtől, mindkét típusnak ki-be kapcsolhatónak kell lennie. Egyrészt azért, hogy ne jelentkezzenek kínai írásjegyek vagy bármilyen velük kapcsolatos működés, amikor nincs rá szükség; másrészt mert ezeket szeparálni kell. Teszem azt a kínaiban létezik egy csomó írásjegy, aminek a kiejtése //ma,// és ha pīnyīnben írod le a //ma// szótagot, akkor ezeket az írásjegyeket akarod látni (például a 馬 lovat). De a //ma// egyúttal egy írásjegy cāngjié kódja is, éspedig a 百-é, mert M a vízszintes vonal jele, A pedig a vízszintesen áthúzott négyzeté. A kiejtése ennek az írásjegynek viszont //bǎi,// és azt jelenti, hogy száz. Szóval ezt a kettőt nem szerencsés keverni, egy valódi kínait, aki ránézésre felismeri az írásjegyeket, eléggé zavarna, ha beírná, hogy //ma,// és megjelenne mindenféle írásjegy, aminek bármilyen szempontból köze van a //ma// betűkhöz. Hiszen a japánban is van két szótagjel, amiknek a kiejtése //ma,// a koreaiban egy szótag, aminek úgyszintén, és így tovább. Mondjuk egy Kelet-kutató nyelvésznek ezekre a nyelvekre simán szüksége van egyszerre, de nem egyidejűleg. Majd ha azt akarja, hogy egyazon képernyőn jelenjen meg neki az összes mindenféleség, aminek köze van ahhoz, hogy //ma,// akkor egyesíti a szótárakat.]
@lad[Tehát akár shortcut, akár varia, ezeknek ki-be kapcsolgathatónak kell lenniük, erre kell egy utasítás. A másik teendő, hogy a kódszó törlését ne az okozza, hogy felismertük, hanem hogy megnyomtuk a variagombot. Vagyis a feldolgozás a következő:]
  * @lad[bekapcsoljuk a szótárat, például a pīnyīnt]
  * @lad[beírunk egy kódszót, például //ma//]
  * @lad[a //ma// még mindig ott van a szövegszerkesztőben, hiszen lehet, hogy //mang// vagy //magyar// lesz belőle, de a variagombokon már megjelent egy-egy //ma// ejtésű írásjegy, az egyik közülük a 馬]
  * @lad[megnyomjuk a 馬 gombját, a //ma// eltűnik és bekerül a 馬]

@thon[Gondolkodjunk még egy kicsit, nekem a magyar egyszerűbb.]

Legyen három kódszónk! Mindegyiket használni is szeretnénk, 
  * ma - 1
  * alma - 2
  * almafa - 3

Hát, ez majd folytatódik. 
De közben rájöttem, hogy minden egyes beírást egy számkóddal azonosítunk, így megcsinálhatjuk azt, hogy beírod "ma" - erre megjelenik a megfelelő varia sor. Ha leütöd, hogy "fa", akkor beírja: "mafa". Ekkor már leütheted bármelyik varia billentyűt, az lesz felhasználva, de nem törli az előző beírást. Ezzel szemben, ha "ma" után leütöd bármelyik varia billentyűt, akkor a "ma"-t, mint a variát kiválasztó kódszót törli.
Átgondolandó: mi történik az egymásba ágyazott kódszavakkal? Pl. "ma" -shortcut-> "holnap", ami varia kódszó. Varia leütése: holnap törlődik, de ma nem íródik vissza.
Mihez kössük a variát? Jelenleg board-hoz kötődik, vagyis minden layouton él. Kössük layout-hoz? Akkor viszont a változó variákat nem lehet több layouton is használni (mármint ugyanazt a variát). Ez egyébként azért is nehéz, mert a kódszavak összerendezése időigényes, és ilyenkor minden layout-váltásnál megtörténne. Még törjük a fejünket; mert ezt ma nem tudom felprogramozni, most pedig elutazunk ide: http://www.santegidio.org/pageID/11712/langID/en/Assisi-2016--Thirst-for-Peace.html



@s5[Kínai]

@lad[Nos, jelentem, betettem a billezetembe a kínait, kétféle táblázattal: cāngjié és pīnyīn. Hát vannak még gondjaim.]
{{filelist>kinesasep.txt}}
@lad[Bal szélen a narancssárga, zongorabillentyűzetet ábrázoló gombot nyomd meg, ez adja a billezetválasztó menüt. Itt nyomj arra, hogy 中文, azaz kínai írás. Visszakapod ugyanazt a billezetet, a tetején egy plusz sorral. A jobb szélén a világoskék gomb a cāngjié gombja, ezzel minden rendben van, beírsz olyanokat, hogy **l tmtj o rvp tc0 hdr wirm**, mindegyik szó után megnyomva a világoskék gombot, és megkapod, hogy 中華人民共和國, azaz Kínai Népköztársaság, direkt nem egyszerűsített kínaiul. Ez tehát oké.]
@lad[Ami nem oké, az a pīnyīn. A rózsaszín variagombokon jelennek meg az írásjegyek. Mármost írd be, hogy **zhong1** és nézd meg, mit kapsz. Ezeket kapod: 叿 呍 哄 揈 渹 烘 焢 硡 红 薨. Csakhogy ezek a **hong1** ejtésű írásjegyek. A z-t nem vette észre a drága. Olvasgatom az ''egy.txt''-t, de nem értem a rengeteg ''findshortcut, autoshortcut, addshortcut, shortcutset'' mindenféléket, biztos klassz pedig.]
@lad[Más gond is van: nem találok lapozógombot, márpedig tíznél sokkal többen vannak az írásjegyek például **hong1** és **zhong1** ejtéssel egyaránt.]
@lad[És végül: ha az egyik variagombon levő írásjegyet megnyomod, az megjelenik szépen, csak a beírt kód is ott marad…]

Ok. Most csak nagyon rohanva tudok válaszolni, könnyen lehet, hogy ez nem is változik a jövő hét végéig.
De a lényeg:
KÉT külön szerkezet van: a VARIA és a SHORTCUT
A Shortcut kicseréli a rövidítéseket a hosszú változatra. Az AUTOSHORTCUT utasítás ezt írás közben, azonnal teszi meg, mégpedig a legrövidebb egyezőre. A FIND... ugyanezt a lenyomáskor teszi meg, de a leghosszabb egyezőre. Mindkettő egyetlen SHORTCUT gyűjteményt tud fogadni, ezért van lehetőség több SHORTCUT lista egyetlen gyűjteménybe való foglalására (Az ADD.. egy shortcut listát készít, a SHORTCUTSET több ilyen listát gyűjt egybe.) Mindig egy AUTOSHORTCUT aktív (legfeljebb). Ha nincs gombóc, akkor mindegyiket betölti. Kezdetben aktívvá tehető a START jelző megadásával.

A VARIA ettől teljesen függetlenül működik. Egy kód a beállított GROUP-ok közül választja ki a megfelelőt. A gomb a VARIA csoportot és az INDEX-et tartalmazza, de a GROUP-ot a kód választja ki.
Ha van tíz gombod, akkor mindegyikre rengeteg GROUP-ot tehetsz. Az egyik ezek közül tartalmazhatja a kódszót, és akkor szinte görgetni tudsz a billentyűk között. No, az lehet, hogy a kódszót nem tünteti el, de ez egyetlen sor (erre ugyanis nem gondoltam). Csináld azért meg, csak ne vedd észre, hogy a kódszót otthagyja, majd kijavítom, ha géphez jutok, meg programhoz, meg időhöz - mindezt egyszerre. De nem fogja otthagyni, ahogy shortcutnál se hagyja ott!

@app[160914]

@thon[Íme, javítva. Varia kódokat sem hagyja benne. Remélem, most ok lesz!]
@lad[Ööö… esetleg várjuk meg, amíg egy kicsit több időd lesz, mert ez egy kicsit messzebb került most. Amint lenyomod az utolsó betűjét egy létező kódnak (például **de**), azonnal eltűnik, pedig lehet, hogy tovább is szeretnéd írni (például **de2**), de már nem tudod. Akkor kellene eltűnnie, amikor kiválasztottál egy írásjegyet és az bekerült a szövegbe. Majd ha több időd lesz, megbeszélhetjük ezeket a sokféle kulcsszavakat is, nem kerget minket senki.]
@thon[Nem, ez sajnos így van. Ugyanis a legrövidebb kódra azonnal reagál. Ezt csak valami sokkal fondorlatosabb módon tudjuk majd megoldani. Vagy speciális kódrendszert kell alkalmazni, vagy - ha egyforma végződések vannak - akkor egy záró karaktert, ami megkülönbözteti őket. Ezen rengeteget törtem a fejem, az máshogy nem megoldható, ugyanis nem tudod, hogy milyen hosszú a végződés, hol kezdődik, hol végződik. Sztem. csinálj valami próbapadot, ahol ki tudod próbálni; ne rögtön több ezer jellel.]


@s5[Bug]

@app[160912]

@thon[Agyoncsaptam! No, de mi legyen a ''toggle autofunc''-kal? Most kikapcsolja az összes autocaps lehetőséget, ha nem engedélyezett (se hold, se wait, se semmi). A lentiekkel kapcsolatban mi a helyzet?]
@lad[Most már jó. A toggle-nak az a dolga, hogy mindent kikapcsoljon, csinálja csak. A kínaival még nem jutottam tovább, túl sok minden van egyszerre, de játszani akarok vele, berakom a rendes billezetembe, mindent.]

@lad[Elkaptam! Gyorsan üsd agyon, mielőtt meglóg! Ott leselkedik, hogy ha a ''toggle autofunc'' gomb kikapcsolt állapotban van, és megnyomod a Shiftet, akkor kapsz nagybetűt. De ha leírtál egy mondatvégi írásjelet, és utána nyomod meg a Shiftet, mivelhogy enélkül ugye most nem kapol nagybetűt, akkor a Shift csak egy villanásnyira kapcsol be, és nem lesz nagybetűd. Tehát ''toggle autofunc'' gomb ki, üss le egy pontot, aztán nyomd meg a Shiftet és egy betűt: kicsi lesz.]

@app[160911]

Íme, az új algoritmus. Az AUTOSHORTCUT a legrövidebbre, a FINDSHORTCUT a leghosszabb egyező végződésre keres. Ha a debug be van kapcsolva, akkor érezhetően, de nem feltűnően lassú, ha nincs bekapcsolva, akkor nem zavaró. Emellett, ha gondot okoz, át lehet rakni natív gépi kódba (nem egy összetett metódus), de olyat még soha nem csináltam. Jó lenne, ha egy anyanyelvi kínai kipróbálná, és véleményt mondana.
Az egy.txt-t újraírtam. <del>Kicsit olyan, mintha a kikapcsolás nem mindig menne, ezt majd ellenőrzöm még.</del> De megy, ellenőriztem. Tied a pálya, próbálgass nyugodtan. Szintaxis az {{filelist>egy.txt}} szerint.

@app[160907]

A kínai támogatás nagyon feladta a leckét, de szerintem a FINDSHORTCUT (ld. chinese.txt) most már működik. Az AUTOSHORTCUT még nem lesz tökéletes, meg ebben is kellene egy kicsit szebbé tennem a kódot, de most ennyi fért bele.
Elv: leghosszabb egyezőt keresi meg.
@lad[Ez tündéri, művész úr kérem. Nagyon szépen jönnek az írásjegyek, akármit beírok, adja. Kerítek pīnyīnt is. És ha annak a szótárát is berakom ugyanabba a txt-be, és a gombját a cāngjié mellé, akkor ez lesz a legelső, ami úgy tudja a kettőt, hogy nem kell közben üzemmódot váltani, menüparancsokkal vacakolni, hanem ha az egyik írásjegynek a kódja jut eszödbe, a másiknak meg a kiejtése, akkor egyszerűen azt írod be és a megfelelő gombot nyomod. Imádom.]
@thon[Az éjszaka kérdése: van-e olyan jel, amit nem talál meg?]
@lad[Nem tudom, de miért lenne? Fölteszem, az egész listát végignézi, és az input szövegben bármi állhat, kivéve " jelet. Szerintem minden jelet meg fog találni. Igazán komoly használatra azért persze énnekem nincs módom, majd egy-két eleven kínai talán. Rakok ki róla képernyőfotót az Omniglotra. :)]

@thon[Örülök, ha tetszik.]Hosszas fejtegetések helyett itt a gondolkodás helye:  [[abbreviations]] Még töröm a fejem, hogy teljes mértékben biztonságos-e az algoritmus (nem hagy-e ki bizonyos kombinációkat), ill., hogy miként lehet optimalizálni.

@e[FONTOS!]@thon[ Ha valaki ki szeretné próbálni a programot, akkor az új Androidon (6 felett, ha igaz) kézzel engedélyeznie kall az SD-kártya elérését!! A programot már az új fordítóval készítettem (ezért ezt az üzenetet nem írja ki), de a szükséges kódot még nem raktam bele (mert service esetén ez nem is olyan egyszerű).]


@s5[Nomenklatura]

  ADDVARIA ( ID variaid 
    ADDGROUP ( CODE codetext LEGENDS ( text... ) )
    ADDGROUP ( CODE codetext LEGEND ( INDEX index TEXT text TITLE text ) ... )
    )
  BUTTON ( VARIA keyword INDEX index ) ; VARIA packet és nem button !!


  ADDMODIFY ( ID modify ROLLS (...)/ ADDROLL()... )
  MODIFY ( ID modify  ) ; ID még nincs megváltoztatva !!


  ADDSHORTCUT ( ID shortcut PAIRS ( text text ... ) )
  
  SHORTCUTSET ( ID shortcutset SHORTCUTS ( shortcut... ) )

  AUTOSHORTCUT ( ID shortcut vagy shortcutset )
  FINDSHORTCUT ( ID shortcut vagy shortcutset )




@s5[Rövidítés és kínai támogatás elve 2.]

Szóval igen, működik. Az elvárásnak megfelelően dolgozik, és óriási mennyiségű rövidítéssel is elboldogul. Az más kérdés, hogy az elvárásainkat nem jól fogalmaztuk meg.

Ezek szerint KÉT rövidítéskezelő rendszerre van szükségünk:

1. AUTOSHORTCUT

A beírt szöveget azonnal átalakítja. Ebből következik, hogy a rövid kódszavak átalakítása történik meg először. Ha olyan kódszót adunk meg, amelyik nálánál rövidebb kódszót tartalmaz, akkor a rövidebb kódszó helyett annak teljes alakját kell beírni.
Ennek a módszernek az az előnye, hogy kevesebb (minden rövidítés után eggyel kevesebb: az itt minden írásjegynél eggyel kevesebb!) billentyűt kell használni.
Hátrány viszont az ilyen standard jelölések átalakítása. Viszont a szabály az szabály, kell rá egy algoritmus. Sajnos, nem a végződést, hanem a tartalmat kell vizsgálni, ezért ez időigényes feladat. De - pont egy ilyen esetben - el lehet végezni előre. Áttekintésnek meg megjegyzésben odatesszük az eredetit.

2. FINDSHORTCUT

A beírt szöveget csak a billentyű érintésekor alakítja át.
(Ez a mostani módszerrel is működik (nagyjából), ha a kódszó speciális karakterrel végződik. Az a 40 kbyte szinte semmi, mert csak a billentyűzet képe (ugyanott tárolódik) 10 Mbyte nagyságrendű. De mindenképp kell más módszer.)
Előny: nem terheli feleslegesen a gépet (pl. akksi) és a rövidítések kódszavai átalakítás nélkül is használhatóak. Persze eggyel több leütés.
Maga a billentyű ugyanolyan lesz, mint a másik: vagyis ugyanazokat a kódszótárat kell megadni. Ezek azonban nem lesznek részei az automata keresésnek, hanem a billentyű sajátjai lesznek. 

FONTOS! Coat-ban a szótárakat el kellene választani a billentyűtől, mert különben minden új billentyűdefiníció új szótárlistát is generál. Ezen még gondolkozom.

Megoldás:
Mivel a kódszavak "visszafelé" kerülnek ellenőrzésre, ezért a rendszer egy részben saját keresőt használ. (Kellene írni egy komplettet amúgy). Ennek az a lényege, hogy a listát az igény jelentkezésekor rendezzük. A kereséskor ebben a listában felezéssel mozgunk az első egyezésig.
AUTO-nál találat esetén tovább kell menni a lista KISEBB értékig, amíg a legrövidebb egyezést meg nem találjuk. (Ez elvileg így van, de technikailag felesleges, hiszen egyetlen karaktertől indul az ellenőrzés és egyesével növekszik.) 
FIND-nál viszont a LEGNAGYOBB értékig kell elaraszolni, mert ott a leghosszabb egyezésre van szükség. Persze a "megmutat" és "tat" közül a hosszabb kerül kiválasztásra.


@s5[Kínai támogatás]

Elkészült a komplett "kínai támogatás" - támogatás. Szokás szerint tesztelésre nem volt idő. Egy rövid teszt azért van, egyben útmutató is a használatához: egy.txt (Hogy lehet ideírni, hogy rögvest le is töltse?) Dolgozd meg alaposan. @lad[<del>Sejtelmem sincs…</del> Így!]
{{filelist>egy.txt}}
A kipontosvesszőzött sor helyett több változat is lehet:
;semmi - minden abbrev automatikusan bekapcsolásra kerül, nincs gomb a kikapcsolásra
ABBREV ( ID abr ) vagy ABBREV ( IDS ( abr1 abr2 abr3 ... ) ) - alapértelmezetten kikapcsolt abbrev, melyeket a gomb bekapcsol. 
ABBREV ( ID abr START ) - ugyanaz, de a START miatt bekapcsoltan indul. Egyszerre EGY ABBREV gombot lehet bekapcsolni.
Itt sok kérdés van: vagy nagyon összetett a coat definíció, de akkor jobban használható több rövidítés. Vagy ilyen egyszerű a megadás, de akkor korlátozottak a lehetőségek.
 DE!!
 Ne legyen még végleges a próbálgatás, mert szerintem a nevezéktanon módosítani kell.
 A START-tal párhuzamban jó lenne fenntartani a STOP nevet is, ami jelenleg befejezi a coat fordítását. Jobb lenne STOP helyett ide a BREAK;
 A MODIFY gombnál a ROLL helyett ID-t kellene írjunk (úgy konzekvens valamennyire)
 Az ABBREV helyett jobb a SHORTCUT, az entries helyett a PAIRS
 De nem változtattam, amíg nem beszéljük meg.
@lad[Rendicsek. Egyelőre megpróbálom fölfogni, hogy mit hova kell dugni, hogy ez beinduljon, csak kicsit nem nagyon vagyok a csúcson, egész éjjel köhögtem és fullákoltam, napközben aludtam egy-egy órákat, most kettőkor reggelizek, de ötre juszt is elmegyek megnézni Gabiék táncát. Szóval valamit kihozok majd belőle, azt hiszem, egyből élesben kezdek kísérletezni, igazi kínaival, hogy lássuk, mi áll össze.]

@thon[Iszonyat fáradt vagyok, én is kipihenem magam, utána segítek majd. A lényeg: hogy minden beírt szöveg lehet code, vagyis pl. egy külön gombra is lehet code-ot tenni, ami akár saját magát is változtathatja. Valahogy így találtuk ki. Mindegy, a keretrendszer képes rá.]
@lad[Pihenj csak. Én közben alkottam egy zsengét:] {{filelist>chinese.txt}} @lad[Egy sima gombozat és benne egy cāngjié lista. Teljes, mert úgy volt egyszerűbb, és közben kiderült, hogy elbír ennyivel a program. A sarokban a kínai jeles gomb kapcsolja be, és akkor jön a bibi. Merthogy ha lenyomsz egy betűt (Z kivételével bármelyiket), az egy érvényes jel a cāngjiében, és azonnal jön egy írásjegy. Az lenne a cél, hogy jelezzük, hol van a kódsor vége, 1, 2, 3, 4 vagy 5 betű után, és csak akkor alakítsa át.]
@thon[két lehetőség van: 1. írj mögé egy pl. $-t(mármint az összes rövidítés mögé), akkor csak a dollár leütésekor keres, azt meg rá lehet tenni egy billentyűre. 2. a változást is beleteszed a felismerendőbe. pl: c = cat, f = fish, akkor nem a cf, hanem a catf lesz = catfish-sel.]
@lad[Azt hiszem, a kettest nem értem.]

@thon[beírod: c átalakítja: cat folytatod: catf átalakítja: catfish - vagyis a 'c'-nél figyelembe kell venni, hogy átaalakul, ezért nem cf-catfish párt kell írni, hanem catf-catfish-t, ha van c-cat átalakítás is. Pl: "a" "日" után nem "aa" kell, hanem "日日"]
@lad[Így átalakítani több ezer karaktert… ráadásul a kapott lista így logikátlan és áttekinthetetlen lenne.]

@thon[Gondolkodtam a dolgon, mégsem jó. A keresés az első egyezésig megy. De azt nem igazán lehet tudni, hogy mit talál meg előbb, az "a"-t, vagy az "aa"-t. Ehhez kell írni egy speciális kereső algoritmust, amelyik pl. biztosítja, hogy a legrövidebb egyezést keresse meg. Addig elég komoly agymunka átgondolni. Ugyanis: "a" leütése "日"-t eredményez, tehát a szövegben nem lesz "a" soha. Ezért az "aa"-t először mint két külön "a"-t átalakítja: "日日" Ezt a jelet kell betenni, hogy "aa"-ként átalakítsa, vagyis "日日" - "昌". Ugyanezen elv alapján: "aa0" helyett "昌0" lesz "昍".]
@lad[Hát valami ilyesmi. Vagy amit korábban mondtál, hogy tegyünk be a szótárban mindegyik végére egy dollárjelet – de én azt mondom, hogy ne a forráskódot alakítsuk át, mert akkor negyvenezer rövidítésnél pusztán ezzel negyvenezer byte hosszabbodást okoztunk, a tervezőnek meg egy csomó fölösleges regexpezést, hanem az eredeti kínaitámogatás-ötlet szerint legyen egy gomb, aminek az a dolga, hogy lezárja a rövidítést. A vége ezzel megvan. Az eleje azzal lenne meg, amit szintén említettem abban a doksiban, hogy tároljuk az ábécét, amit az adott átírás használ, és ami nem abba való betű, az nem része a rövidítésünknek.]


@thon[De hová kell a tíz karakter, amiből választani kell?]
@lad[A cāngjié esetén gyakorlatilag sehol, mert mondjuk OIAR kódú karakter egy van. Csak néhány kód van, amik többféle karaktert jelképeznek, ezek a rendelkezésre álló adatbázisban számokkal vannak jelölve, mert az Autor forrásából való és ott így volt. Kísérletezésre megteszi. Választani például pīnyīn esetén kell, hiszen a kiejtést adod meg, az meg rengeteg írásjegynél azonos. De egyelőre ezt a részét akartam érteni.]

@lad[Játszottam még vele, és készítettem egy japán vázlatot:] {{filelist>kana.txt}} @lad[Mármost ha benyomod a hiraganát vagy a katakanát és elkezdesz szótagokat írni: ka, ki, ku, ke, ko, akkor némelyikre k betűt plusz az a, i, u, e, o magánhangzó japán jelét kapod. Ez a szótagok nagy részénél így van.]

@s7[Régi szövegek archívuma 2016. szeptember 3.]

@s5[Rendrakás]

@thon[Kicsit átrendeztem a világot, így mindenhová könnyebben eljutok. Kezd akkora lenni a káosz a programban, hogy már magam sem tudom, miket írtam meg, meg miket nem.  Ha a rövidítéskezelő - új nevén codetext - elkészül, akkor nem alkotok már semmi újat, amíg mindent rendbe nem tettünk, és nem véglegesítettünk. Na jó, ez nem biztos, de ez lenne a helyes :) Ebből meg lassan archiv2 lesz, mert alig tudok írni...]
@lad[Figyeltem a változásokat, nagyon tetszik.]
@thon[Hát, ha még az új programverziót meglátod!]

@s5[Bug]

@lad[Van egy gondom. A következőt észleltem. Számokkal (akiken persze nincsen semmi autocaps funkció) végződő sorokat írok, Enterrel (autocaps) fejezem be őket, és nem kapcsol be az autocaps, a Shift normál színű marad. Ha ezután megnyomom a Shiftet, akkor villan egyet és visszasötétedik, vagyis nem kapok nagybetűt. Ha másodszor is megnyomom, akkor már igen. Ez tegnap egy ideig következetesen, sorról sorra mindig így történt, de most nem tudom reprodukálni.]
@thon[Írjuk be a hiba-listába. Ha nem lehet reprodukálni, akkor nehéz a végére járni. De ha átnézem a kódot, akkor erre is kell gondolni; valami időzítési hiba lehet.]

@s5[Rövidítéskezelő és hibák]

Még kész sincs, de máris logikai gondba kerültem.  Ugye, azt akartuk, hogy egy változó-gomb mindig más szöveget használjon? No, most úgy alakítom át a kérdéset, hogy egy változó gomb miért nem kaphat BÁRMILYEN packetet? Vagyis nem szöveget, hanem packetet kéne megadni az egyes változásokhoz....
Na mindegy, ezt most így befejezem, aztán meglátjuk.

@s5[Hibák]

Nekiálltam a rövidítéskezelőnek, dolgozom is rajta. Időközben viszont bukkanok olyan apró hibákra, vagy inkább kétértelmű megoldásokra, amiket így nem fogunk tudni kijavítani. Szerintem itt az ideje a tesztelésnek, fel kell tegyük a programot. Amíg nem kezdik el többen használni, addig félve merek nagy változtatásokat csinálni, mert azok csak begyűrűznek, és egyre nehezebb lesz rendbe tenni a kódot. Ez nem sürgetés, van most épp elég dolgod, inkább csak az irány meghatározása. Ezen azért dolgozom, de valószínűleg az első körben csak belső, általunk használható megoldás lesz (nem dokumentált úgy mond). Azt hiszem csak a help, meg néhány egyszerű billentyűzetpélda hiányzik egyébként.

@s5[Github]

Emlékeztetőül: a forráskódok ill. a fejlesztés egyes lépései a https://github.com/palmodroid oldalon nyomon követhetőek. Ez mindenkinek, aki a fejlesztésben részt vesz (oké, ez nem sok ember eddig, de akkor is)  hasznos lehet; de inkább csak egy technikai, időszakos mentést szolgáló háttértár.

A publikus, letisztázott részeket egy másik gyűjteménybe helyezném:
https://github.com/lattilad
Ez már kész, de még üres (természetesen). És a név nem véletlen, ez tényleg a lattilad oldalhoz tartozik, még ha én is hoztam létre.

Célszerű lenne egy android`@lattilad.org levelezési cím létrehozása, mert akkor pl. ezt az oldalt is erre regisztrálnám.  Amúgy az első ellenőrzésen kívül erre nem sok üzenet jön, de ha valaki akar velünk levelezni, ezen megteheti. Az alias lehet éppen más is; ill. nyugodtan kaphatod Te is a leveleket, esetleg forwardolod, vagy bármi lehet. De nem érdemes még egy plusz e-mail létrehozása mondjuk a gmail alatt - szerintem. 
@lad[Megcsináltam, jelenleg forwardol az én címemre, de öt címnek van hely.]
@thon[Ok, akkor ehhez mindketten hozzáférünk. Elég jól kezeli a nagy programkód-projekteket, ezért jobb azokat ide tenni, és nem az eredeti oldalra.]
@thon[Az öt az sok vagy kevés? Mert nem sok jelentősége van, ha elfogy átmehetünk a gmailra is, akár. Azt hittem, a saját domain-en belül végtelen e-mail-ed lehet.]
@lad[Persze. Egy adott postafiók öt címre tud forwardolni.]
@thon[O. Erre nem gondoltam. Egyébként nem írtak több levelet korábban sem, de ha gondolod, a palmodroidra átforwardolhatod, akkor én is látom.]

@s5[Blogos kérdések]

@thon[Rövid kérdés, aztán majd mindjárt rendszerezek (megtörtént). A blog file-jaihoz hozzáférek? Pl. ha át akarok nevezni egy file-t, vagy törölni - azt megtehetem? Vagy, ami egyszer létrejött, az marad is; legfeljebb nem hivatkozom rá? Amúgy ismerkedem egy kicsit behatóbban is Vickyvel, közben meg alkotok is, ha még lassan is megy. Köszi!]
@lad[Tudsz törölni, törlöd az egész szöveget és kimented az oldalt. Az átnevezésre is van valami praktika, de már nem tudom, mi, többnyire azt csinálom, hogy teljes szöveg cut, save, új oldalra paste.]
@thon[Ja, príma, működik. Átmenetileg csak annyi kérésem van, hogy átállítanád csokoládésról desszert(calm)-ra? A feltettek közül azt a legegyszerűbb kezelnem. Köszi!]
@lad[Hogyne, ha rájövök, hogy hol állítottuk ezt be fixen…\\ Rájöttem!]

@thon[Van egy-két új ötletem. Az első pont nem igazán tartozik ide. Szóval a blog. Kitaláltam. Egy olyan "blog"-ra (még nincs rá jobb szavam) lenne szükségem, ahol minden tételt blogszerűen egy címhez és egy dátumhoz rendelünk. Mivel minden tétel egyúttal egy wiki file is, ezért lenne egy nagy tartalomjegyzék is (és ez a fontosabb), ahol viszont téma szerinti elrendezésben szerepelnek a blogcikkek. Ez (a címe) akár minden egyes blogcikk elején szerepelhet.]
@lad[Persze, mindent lehet. Például ha a tartalomjegyzék ábécébe lehet rendezve, akkor már meg is van a technika, a tárgymutató-készítő programom. De mindenre lehet plugint írni, csak idő kérdése (viszont abból van a legkevesebb).]

@thon[A formával kapcsolatban vannak kérdéseim: az eredeti színkombináció (android.lattilad.org) eléggé tetszik a lehetőségek közül. Egy ilyet nem tudok esetleg legyártani rá?]
@lad[Dehogynem.]

@thon[A másik, hogy a jelenlegi "fejléc" 99%-ban felesleges hozzá. Az kikapcsolható? Nagyjából a "Ieva csak táncolni akart" felett minden; nekem egy link a Te (fő) lapodra bőven elég lenne, de ha mód van rá, azt sem oda tenném, mert gyakran egész kis képernyőn kell használnom, ahol ezek a fix részek elveszik a területet.]
@lad[Elvileg megoldható. Minden skinnek van egy központi php-je, ami összerakja az egész oldalt. Ha ebbe belerakom, hogy „ha az Android blogban vagyunk, akkor hagyd ki a fejlécet”, akkor ez működik. Sőt nyilván azt is lehet, hogy „ha a bejelentkezett felhasználónév //thon//”, és akkor speciálisan Téged nem zavar.]

@thon[De ezek nem jelentős, sem pedig gyors kérdések, előbb legyen tartalom, a többi ráér. Apropó, ezt ugye később át lehet tenni az android.lattilad.org alá, ugye? Azt meg valami másra.]
@lad[Hogyne, ez éppenséggel a legkönnyebb része, van egy jegyzék az aldomainekről, ott átírom és kész.]

@thon[Nézd csak, van egy ötletem: ] [[abbreviations]] @thon[ Ezekkel a makrókkal jobban ki tudom emelni a dőlt vagy vastag részeket.]

@s5[Néhány új ötlet]

@thon[Ötletek még rendszer nélkül:
- rövidítéskezelő
-változtatható billentyűk
- előre elkészített szövegek kezelője
- többszörös clipboard kezelő
- password kezelő
- csak hard-keyekkel működő változat
- külső szövegek beszúrása (pl. időzítés szöveg)]

@app[160626] A DEFAULT utasításon belül, az egymásba ágyazott utasítások (jelenleg konkrétan az ADDTITLE) nem működött jól; mert a további bővítés az eredeti (default) addtitle-t is módosította. A probléma LET mellett nem jelentkezik, csak ha többszörös egymásba ágyazás is engedélyezett lenne. Amúgy javítva. 
@thon[Ha van időd, nagyon jó lenne sok apró, de akár összetett billentyűzetet gyártani. Én is igyekszem megtenni. A hibák csak így fognak előbukkani - ez a mostani is elég rejtekező típus volt.]
@lad[Az bizony jó lenne. Jelenleg az a nagy kérdés, hogy belevághatok-e elég nagy projektbe, ami rengeteg időt fölemészt majd, de nagyon szeretném csinálni. Két hét múlva tudni fogom.]

@thon[Nem probléma, ráérünk. A legfontosabb talán a help lenne, de az sem sürgős.]

@thon[Más, át is teheted valahová, ahová inkább tartozik:]

  ADD... ( ID azonosito 
	ADD... ( CODE kodszo TEXTS (szovegek listaja))
	)

  BUTTON ( ...TEXT ( ... azonosito NUM szam )
  
@thon[A "változó" billentyűket valahogy így kéne definiálni. Csak nem találok jó neveket hozzá, illetve nem tudom, hogyan lehetne a gomb szövegétől eltérő feliratokat beleaplikálni.]
@thon[Az elv: ami változhat az kizárólag a TEXT alapú packet, tehát nem a billentyű. Ez azt eredményezi, hogy bármelyik billentyűtípust használhatjuk változó billentyűként - viszont (egyébként logikusan) funkciót vagy hard-key-t nem tudunk "változóvá" tenni.]
@thon[Az ötlet a következő: ha a CODE után megadott kodszo-t írjuk be, akkor a CODE-hoz tartozó TEXTS-sor kerül kiválasztásra. Tehát pl. CODE "num" TEXTS ( "1" "2" "3" ) és CODE "alfa" TEXTS ( "a" "b" "c" ) esetén beírjuk, hogy num, akkor az 1-2-3, míg alfa után a-b-c lesz aktív.]
@thon[A billentyűk (pontosabban a textpacket-ek) a változó-halmaz  azonosítójára, és a TEXTS szövegek utáni sorszámra hivatkoznak. Így a NUM 1 num után "1" ,íg alfa után "a", a NUM 2 num után "2" míg alfa után "b" stb értéket vesz fel.]
@thon[Ezt az egész szintaxist együtt a rövidítésekkel alaposan pontosítanunk kell.]
@lad[Jó kérdés. Egy lehetséges megoldás: készítsd el az egész mindenséget úgy, ahogy most tervezted, kezdjük el használni, és menet közben már jobban látjuk, milyen kulcsszavak illenének ehhez a funkcióhoz.]

@lad[No, végre találtam egy bugot. A történet menete. 1. A háttérben állandóan ott van a hibalista ablaka, mivelhogy kisebb gondom is nagyobb annál, mint a pár vacak hibáját kijavítani. 2. Meg akarom mutatni valakinek a minap gyártott bráhmi kiosztást. Betöltöm, hibaüziket kapok, hiszen azóta át lett írva a programnyelv. 3. Kijavítok néhány hibát, visszamásolom a file-t, betöltöm, nézem a további hibaüziket. De előbb ugyanazokat látom viszont. 4. Átlépem őket, megkeresem a továbbiakat, kijavítom. 5. Már nagyjából kész lenne, de az utolsó hibákat már tényleg látni szeretném a listában, tehát törlöm a logot, újramásolom, betöltöm, akkor is a régi hibákat látom. 6. Mindenhonnan törlöm a logot, átírom a billezet verziószámát, mindent mindenhonnan törlök, átírok, újramásolok, könyvtárneveket mindkét gépen ellenőrzöm, minden stimmel, viszont a régi hibákat látom a régi verziószámmal. 7. Gyanút fogok és a hibalista ablakát kidobom a taszklistából. Lecsuk, gondolkodik, visszahozza, már az új verziószám van a listában, az új hibákkal.]
@lad[Szóval újra kellene azt ottan tölteni…]
@thon[Megnéztem, működik, csak kérdés, hogy mi a helyes működés. Jelenleg minden egyes indítás egy új lapot mutat meg, amiken aztán vissza tudunk lépdelni. Tehát nem átírja az egyetlen lapon lévő információt, hanem csinál egy új lapot az új információval. Ha minden hiba kijavításra került, akkor nincs is új lap, tehát még látjuk a régit. A webview egyéb használatához ez jól van így, de majd még gondolkozom rajta. Addig mindig ki kell lépni a lapról a back kétszeri leütésével (az első csak becsukja a billezetet)]
Az átírás nem egyszerű, magamnak néhány link: http://stackoverflow.com/questions/9467802/how-to-enable-only-one-instance-of-my-application 
http://stackoverflow.com/questions/3219726/android-singletask-or-singleinstance-launch-mode
https://blog.akquinet.de/2010/02/17/android-activites-and-tasks-series-an-introduction-to-androids-ui-component-model/

@lad[Újabb ötlet. Egy felhasználó dévanagári billezetet keresett, de olyat, ahol beírja a latin betűt és az átváltozik dévanagárivá, vagyis H-t nyom le és ह betűt kap stb. Szerintem a rövidítéskezelő erre is jó, csak kell egy kis ravaszság. Mert ha mondjuk a J (dzs) gombra megjelenik a ज betű, akkor a झ dzsh betűt már nem lehet JH rövidítésre tenni, mert már जH áll a szövegben: ez lesz a helyes rövidítés.]@thon[Ez elvileg így fog működni.]

@app[160601]

@thon[Ebben a változatban egy érdekes javítás van. Az editor néha megváltoztatja a bevitt szöveget (pl. numerikus editor-mezők) és nem azt írja be, amit mi küldünk (és gondolunk). Ez a visszavonásokat (többszörös billentyűknél pl.) szinte lehetetlenné teszi. Mivel a billentyűzet és editor kommunikációja problematikus, ezt a problémát teljes mértékben megoldani API 16-nál nem lehet (API 22-től kényszeríthető a kommunikáció, de a korábbi programokat ez sem fogja megoldani.)]
@thon[Egyet azonban lehetett tenni. Ha egyáltalán nem történik meg a szöveg beírása (editor nem fogad pl. betűt numerikus mezőben), akkor visszavonásra sincs szükség. Ezekben az esetekben a másodlagos szöveg (példánkban egy szám) elküldésre kerülhet. Sajnos, a kevert szövegekre (pl. szám és betű együtt numerikus mezőbe küldve) ez nem működhet, ilyenkor a másodlagos funkciót nem lehet elérni.]
@thon[Mindez a szokásos, sok sorból álló és korlátozás nélküli mezőket NEM érinti, sőt erre a programrészre el sem jut a billentyűzet. Ez CSAK korlátozott (pl. numerikus) beviteli mezőkön tesztelhető.]
@lad[Biztos klassz, csak momentán fogalmam sincs, hol találok ilyen mezőt.]
@thon[Pedig hát, ilyen esetekben is tesztelni kell a programot. A settings numerikus értékei pl. ilyen mezőben vannak, aztán majd gyártunk valami teszt-környezetet. Ami talán jó hír: komplex szöveges editorból sok van, minden szövegszerkesztő más és más - és mindnek meg kell felelni. Ilyen mező viszont szinte kizárólag a rendszer sajátja; nem hiszem, hogy ezért valaki editort írna. Szóval, kevesebb elvárásra kell tesztelni.]

@thon[Apró kérdés: az YOFFSET értéke a számítástechnika szerint helyesen, de a logika szerint fordítva van, vagyis FELFELÉ van a negatív. Ezt nem lenne érdemes megfordítani? Értem, hogy az első sor a legfelső, de az eltolásnál nekem mégis felfelé lenne logikus a plusz, és lefelé a minusz. Mivel ez minden coat file-t érint, ezért előbb tárgyaljunk róla.]
@lad[Szerintem jobb így, ahogy van. A coatokat feltehetően olyan emberek írják majd, akiknek van valamicske számítástechnikai képzettségük. Az egész számítástechnikában egyöntetűen lefelé növekednek a koordináták, kivéve az egy szem ZX Spectrumot és testvéreit.]
@thon[OK. Marad. Vagy betehetünk valami spéci utasítást, ami megfordítja, de sok értelmét nem látom.]

@lad[Annyi mindenféle klassz billezet kéne csinálni, hát megpróbálok összeütni egy kis szerkesztőprogramot. Lehet, hogy belezavarodok és félbehagyom, de egy próbát egér.]

@s5[Rövidítéskezelő] @thon[Ez fontos, ez valahogy maradjon elől, vagy legalább egy hivatkozás rá]

@thon[Valahol volt erről már egy hosszabb lélegzetvételű tárgyalás, de nem találom. Nem tudod, merre van?]
@lad[Egyelőre ezt találom:] [[chat_archivum#kínai_és_egyéb_támogatás]] @lad[Itt linkelve van a kis esszém az ügyről. Valamint] [[chat_archivum#dokumentáció]]

@thon[Ezek szerint két funkció szükséges:]
  * @thon[szöveges beírás után modifyhoz hasonlóan ellenőrzi, és átalakítja (megkötés lehet, hogy stringnél csak a string végétől ellenőriz, és nem minden egyes karaktert). Rövidítés-billentyű nem kell, ilyenkor az utolsó karakterként egy közös karaktert adunk meg]
  * @thon[valamilyen állapotjelzőtől függő billentyűk, melyek értéküket ettől függően veszik fel. Mi legyen az állapotjelző? pl. egy utoljára beírt speciális karakter? vagy string?]

@lad[Lássuk csak. Én egyetlen rövidítést használok a levelezőprogramomban: //sig// a neve, és kiteszi az aláírást. Van egy billentyűkombinációja, akit utána meg kell nyomni, és akkor aktivizélődik. Mi csinálhatunk egy külön erre szolgáló gombot, akit meg lehet nyomni a) a rövidítés előtt, b) utána, és aktiválja a rövit. Akár mindkettő létezhet, ha műszakilag lehetségesek, és más-más dolgokra lehetnek jók. Például a rövi előtt megnyomott gomb szó közben is használható, mondjuk ha //tt// jelentése //természet,// a prefix gombot *-gal jelölve anya*tt → anyatermészet. A postfix gombbal pedig tt*ellenes → természetellenes. Lehetne két gombot is kívánni, hogy elöl-hátul elhatároljuk a rövit, de ezt túlzásnak tartom.]
@lad[Ezenfelül viszont a kis kínai tanulmányban írottakat is fontosnak érzem. Akkor az egy üzemmód, amikor a jószág mindent rövidítésszótárból olvas.]

@thon[Lassan kezd körvanalazódni bennem, hogy miként lehet ezt megcsinálni, és egy egészen új távlatot nyitni. Persze, hogy fontos a kínai tanulmány, ezt akarom pont elérni. De egyébként a koreaira gondoltam, amit korábban írtál - mindegy a végeredmény ugyanaz.]
Válasszuk ketté:

@s4[rövidítéskezelő rész]

Ez aránylag egyszerű. Figyeli az elküldött szövegeket. Ha egy adott kombináció megjelenik, akkor azt kicseréli. Pl. //sig// helyett //Tamás vagyok//. Ha szeretnénk egy speciális gombot utána (mondjuk legyen ez a *), akkor a //sig*// vagy éppen a //*sig// stringet kell megadni. Én pl. a §-t használom. Több tízezer karakterből csak van egy felesleges. 
@lad[Szerintem a program szellemiségéhez az illik, ha az a gomb egy külön utasítás, nem karakter. Felesleges karakter persze van, a nem definiált kódok sokaságát lehet használni.]
@thon[Szerintem felesleges a gomb, a karakter meg a user "saját" akarata. De éppen lehet gombot csinálni, ami csak épp egyszer ellenőrzi az adott szótárat. Mint a meta meg a lock.]
Ez a módszer persze aránylag nagy kapacitást igényel, mert minden beírás után ellenőriz. Ugyanakkor pont a kínainál nem kéne még egy billentyű leütésére kényszeríteni a dolgozót. 
@lad[Nem bizony. Gyakorlatilag használhatatlanná tenné a billezetet.]
Kérdés(ek): Mi legyen a rövidítésszótár? Ha több adható meg, akkor azokat nem lehet külön-külön kikapcsolni.
@lad[Szerintem legyenek különálló txt-k, és meglátásom szerint ki lehet őket kapcsolni külön-külön. a) Kétdimenziós tömbbe kerülnek, ahol röv[1][100] az első lista századik eleme, de ha röv_bekapcs[1] = false, akkor a röv[1] listát nem is nézzük, csak a 2-est stb. b) Egydimenziós tömbbe kerülnek, és egy jegyzék tartalmazza, hogy az egyes rövidítéslisták a tömbben mettől meddig vannak. Ha kikapcsolunk egyet, a tömbnek azt a részét töröljük. Ez nem Commodore, ahol az ilyesmi órákig tart. c) Ua., mint b), de nem töröljük, csak a jegyzékben feljegyezzük, hogy azt a részt nem kell vizsgálni; gyorsabb, főleg ha sokat kapcsolgatják ki-be a jegyzékeket.!]
@thon[Az alapelv persze ez, csak mégse ilyen egyszerű. Hol adod meg a txt-t? Hogyan rendeled a billentyűhöz? Létrehozol egy összetett listát - ne felejtsd el, hogy minden leütésre ellenőrizni kell. Ha nem coat, akkor egy új beolvasórendszer is kell. (mert ugye mások a hibák). A kínai rövidítéseket be akarod tenni a billentyűbe, a sajátjaidat meg nem. Lehet, hogy a txt file-ba több másik txt-t akarsz összelinkelni. Stb. Mindezekre a vad ötletekre a program könnyebben alkalmas, mint egy sima txt olvasásra, csak ki kéne fundálnunk a jó megoldást.]
@lad[Hol adom meg a txt-t? A kínai tanulmányban említett módot jónak találom, a billentyű tartalmaz egy utasítást, amiben paraméter a txt neve. Én sima txt-ből indultam ki, amiben nincsenek semmilyen utasítások, de persze ennek nem muszáj így lennie. Ma már, a regexpek korában az se tragédia, ha minden sorhoz be kell írni valamilyen utasításszót. Például akár lehet ilyen (cāngjié):]
  alphabet "abcdefghijklmnopqrstuvwxyz"
  abb (from "a" to ("日" "曰"))
  abb (from "aa" to ("昌" "昍"))
  abb (from "aaa" to ("晶"))
@lad[Csak nagyon megnöveli a terjedelmet, de ha egy efféle preparálás meggyorsítja a feldolgozást, nem látom akadályát.]
@thon[Ha a coat-ba integráljuk, akkor a felhasználó nem tudja módosítani. Itt is valami olyan kellene, hogy lesz egy "felhasználói" szótár, ami a settingsben beállítható.]
@lad[Igen. A rövidítések elvileg függetlenek a használt coattól, mert ha valaki mondjuk programoz, akkor programnyelvi elemeket akar beírni, függetlenül attól, hogy éppen melyik coatot használja.]
@thon[A rövidítéskezelő viszont gombokkal indítható, ahol a felhasznált szótárat/akat megadjuk - és jelölhető, hogy a felhasználói szótárt is integrálja-e. Vagyis: lesz pl egy kínai billentyű, ami a kínai rövidítéseket dobja be, plusz hozzáteszi a felhasználói rövidítéseket. Ha be van kapcsolva, akkor ebből veszi, ha nincs, akkor meg nem alakítja át. Hát, ezt még át kell gondolni, de egy ilyen elgondolás nem tűnik rossznak.]
@lad[Ha azt beteszed, hogy egy gombhoz hozzá lehessen rendelni egy szótárat (''BUTTON (DICTIONARY "cangjie")''), akkor már annyi szótárad lehet, amennyit el tudsz készíteni. De lehet azt is, hogy egy gomb több szótárat is bekapcsoljon egyszerre.]

@s4[módosuló gombos rész]

@thon[Ez a nehezebb rész: lennének olyan gombok, amiknek a tartalma/felirata változhat. Ez eddig nem nehéz, hiszen a memory is pl. ezt csinálja. A kérdés az, hogy milyen behatásra, és melyik feliratot jeleníti meg.]
@thon[No, erre kezd valami olyan körvonalazódni bennem, hogy egy beírt szövegre módosulhatna a felirat. Ilyenkor pl. egy gombra rátesszük, hogy "elsősor", akkor a változó gombok kidobják az első feliratokat. "másodiksor" a második stb. feliratokat. Mivel maga a feldobott felirat is lehet ilyen "kódszó", ezért a feliratok tovább fűzhetőek egymásba. Ezt a kódszót érthetjük úgy is, hogy egyfajta szövegkörnyezetet jelez, amihez a gombok szépen feljönnek. Mert pl. lehet így a numerikus/cseh/speciális/Kissy felső sort is körbe-játszani.]
@lad[Jó gondolat.]
@thon[A gond a coat oldalán lesz, mert te meg szeretnéd adni, hogy az 1-2-3-4... ill. a Kissy-Chantal-Párizs-Vanessa... legyenek egymás mellett. De mivel gombot kell definálnod, nem gombsort; ezért az 1-Kissy, 2-Chantal..., 3-Párizs..., 4-Vanessa... stb. gombokat kell definiálni. Hát ezen még törnöm kell a fejem.]

@thon[De bárhogy is legyen, ezzel már akármit fel tudunk rakni szövegfüggően a billentyűzetre. Listázást meg egyebet nem tud, de nem is fog tudni, mert ahhoz egy külön kezelő kell. Akkor inkább el kell indítani egy kis programot, aminek az eredményét teszi be. Viszont! Beírsz egy "sho" sorozatot, amire a felső 11 billentyű felvesz különböző kínai karaktereket, vagyis az első a "sho1" nevet. Ha ezt lenyomod, akkor a "sho2" és 10 új karakter jelenik meg, és így tovább. Az első gombot nyomkodva szinte végtelen jelen tudunk végigfutni.]
@lad[Kvázi ez a kínai támogatás magja. Némi csiszolás kell még hozzá, de ezzel a lényeg már megvan.]

@thon[Hát erre viszont valami olyan összetett táblázatot kell kiókumlálni, amiben a változások részletesen megadhatóak. Utána a gombóc már csak a megfelelő táblázatra, ill. annak megfelelő oszlopára fog hivatkozni, és onnan veszi az értéket. A táblázat persze csak coatban lehet, vagyis minden értéket keywordnek kell meghatároznia, míg maga az érték csak string/karakter lehet.]
@lad[Ezt a részét nem egészen értem. Én egydimenziós listákban gondolkodom, amik //forrásszó → célszó/célszavak// szerkezetűek. Hol lépnek itt föl különböző oszlopok? És miért csak coatban lehet?]
@thon[Mert ez nem a rövidítésrész. Meg kell adni, hogy mi legyen a felső sor tartalma egy adott leütés után. Mondjuk 10 gomb, mondjuk 20 kódszó - és még nem is mondtam sokat. És lehet másik sor is. Szóval struktúra kell, és a coatot pont ezért csináltuk, hogy feltöltse.]

@thon[A másik lehetséges probléma, de erre ráérünk később, hogy a billenytűzet úgy készült, hogy csak 2-3 billentyű változik a megjelenések között. Ilyen mennyiségű változás már észrevehető lassulást okozhat. De ezt is meg fogjuk oldani.]
@lad[Elvileg nem lehet probléma. Beírod, hogy huang. Megjelenik tíz írásjegy ezzel a kiejtéssel. Tovább tart megtalálni köztük a szükségeset, mint ameddig a program ezzel vartyol.]
@thon[Elvileg. Mert minden érintésre (ami pöttyöt ad) újrarajzolja. De ezen lehet módosítani.]

@s5[Case]

@app[160516]

Hoppá, volt egy kis hiba a caps és case körül; javítottam.
És, ha már itt voltam, az autofunc engedélyezést is rendbe tettem. Most nem maradhat bekapcsolva - elvileg.
FONTOS! (Ez volt a hiba)
- Ha másodlagos funkcióval írunk nagybetűt, akkor CSAK az első karaktert nagyítja, ill. visszaváltoztatja a szöveget az eredetire (vagyis nem Sentence case lesz, csupán egy nagybetű, vagy ha kértük a stringcaps-szal, akkor mind nagybetű.
- Ha viszont a CHANGECASE változtat, akkor ténylegesen az egész stringet átalakítja, majd visszaírja. Mivel nem jegyezheti meg minden ponton, hogy mi volt az eredeti string, itt SOHA nem tudja visszaírni az eredetit, csak a kis/nagy/mondatkezdő nagy betűt. 
Megjegyzem a "Sentence Case" nem igazi "sentence case", bár mindenütt így használják, mert a kijelölt első betűje lesz nagy, nem a mondaté. Az alapértelmezett kijelölés jelenleg egy szó, bár ide is betehetnénk a CHAR/WORD/PARA/ALL vagy hasonló megkülönböztetést. És akkor az a határ lenne érvényes, ha nincs kijelölés


@s5[Include és ChangeCase módosítás]

@app[160511] 
CHANGECASE ( LOWER UPPER SENTENCE )
@lad[Ezt rögtön félreértettem, majd kiálmodom, hogy legyen egyértelmű.]
@thon[Szerencsére Te vagy az író, nekem meg elég, ha működik :)))]
@lad[Javaslat: ALLCAPS és Firstcaps, illetve a szavak kezdőbetűihez TitleCase, a lower helyett pedig lowercase, csak hogy világos legyen.]
@thon[Kontra. Ezt direkt megnéztem, így hívják őket: lowercase uppercase sentencecase meg titlecase. Hogy ne kelljen annyiszor kiírni, a case-t áttettem az elejére. Viszont az allcaps és a lowercase írásmódban annyira távol áll egymástól, hogy nehéz megjegyezni. Sztem.]
@lad[Értelek. Oké, nincs jobb ötletem, maradjon a mostani.]

@s5[Help és file-selector, egyéb módosítások]
@app[160508]
Továbbra is teszt-változat, bár elvileg mindent tud, amit a korábbiak. Kiegészítések:
  - tartalmaz egy webview komponenst, ami képes megjeleníteni html formázott szöveget.
  - tartalmaz egy file selectort, amelyikkel kiválasztható a megfelelő coat file.
@lad[Javaslat: vegyük ki a két külön sort, ahol a könyvtárat és a file-t lehet bepötyögni, hiszen van helyettük file-választó; helyettük ez utóbbi mutassa, hogy mi van érvényben, de most már ne file-névvel, hanem a ''name''-beli nevével.]
@thon[Ok, ez hosszútávon mindenképp így lesz, jó ötlet. Viszont itt még a kommunikáció kicsit göröngyös, úgyhogy a feldolgozás csak akkor indul el, ha a billentyűzet meg is jelenik. Szóval: tegyük a feladatok közé, mert ehhez kell a precízebb file-választó.]

Webview megjelenik: Preferences/Help része, HELP billentyű (mindkettő egy help.html file-t nyit meg) ill. hiba esetén a coat.log-ot listázza azonnal
@lad[Ne listázza, ezt kérem szépen kivenni belőle, majd akkor listázza, amikor ezt kérik tőle. Akkor igen, mert ez a listázás sokkal klasszabb és áttekinthetőbb, mint a Jotában megnyitni, de kérés nélkül ne jelenjen meg. Hócipőszindrómám van az olyan programoktól, amik nem bírják ki anélkül, hogy örökké rám zúdítsák a maguk Iszonyatosan Fontos Közlendőit, amik engem sosem érdekeltek.]
@thon[Már most sem tolja. Csak akkor jelenik meg, ha hiba van; ez viszont fontos a fejlesztés alatt. A kész billentyűzetben nem lehet hiba (tehát meg sem jelenik), mert a hibakezelés nem fejlett. Egyetlen hiba minden további részt is képes romba dönteni.]
@lad[Mondjuk az enyémben hosszabb ideje akad egypár, ugyanarra a helyre tettem két gombot, nem bugoltam de, mégis mögy.]
@thon[Mindegy, maradjunk következetesek: hiba ne legyen. Ha beírod, hogy OVERWRITE, akkor tudni fogja, hogy szándékosan átírod, és nem lesz hiba.]
@lad[Csak ki kell nyomozni, hogy hova kell írni.]
@thon[Abba a button-ba (vagy hasonlóba), amelyik a korábbit felülírja.]

@thon[Ma reggel tovább gondolkoztam ezen a dolgon. A preferencesbe (settings) kerülhetne egy "billentyűzet-fejlesztés" és egy "program-fejlesztés" kapcsoló (ez utóbbi a mostani debug). De ugyanakkor rájöttem, hogy a felhasználót valahogy védeni kell a potenciálisan hibás billentyűzettől (hiszen nemkap visszajelzést), tehát ha ez nincs bekapcsolva, akkor hibás billentyűzetet ne lehessen betölteni. Vagyis rá kell kényszeríteni a bill.készítőket, hogy korrektül ellenőrzött billentyűzetet adjanak ki a kezük közül. De amikor ezt végiggondoltam, rájöttem, hogy egy plusz kapcsoló beiktatásával pont oda jutottam, ahol most vagyunk. Vagyis a kapcsoló felesleges. Ha nincs hiba, akkor a program a várakozásnak megfelelően működik, vagyis nem visz sehova. Ha viszont hibás a coat file, akkor fejlesztés van, és adja a részletes - kijavítandó - hibát. Ha meg valaki hibás coat file-t ad ki, akkor a felhasználó rögtön az elején látja, hogy valami baj van (de nincs eltiltva a további javítástól pl.). SZóval szerintem, ez így van jól elrendezve.]
@lad[Hűha. Párszor megpróbáltam ezt fölgombolyítani, nem mönt, inkább elhiszem…]
@thon[Ezzel együtt azt is kitaláltam, hogy a tokenizer helyett a help-nek kell indulnia. Ez azt jelenti, hogy a "fő, ikonos program" a helpet jeleníti meg. Erre még rátehetünk egy gombot, ami a settings-be visz át; bár akkor a settings-ben lévő help-et viszont ki kellene venni (mert egymásra mutogatnak). Hát, ezt még átgondolom.]
@lad[Jó gondolat, de szerintem mutogathatnak egymásra nyugodtan. Amikor a felhasználó az ikont nyomja meg, kapjon helpet. Amikor viszont az Android settingseken vagy egy billezeten levő ''settings'' gombon át eljut a beállításokig, akkor is kaphasson helpet, mert hát miért ne, és ha jól rémlik, van már külön gomb is a helphez, ha valakinek az tetszik.]
@thon[További tervek: a webview használható egy sd-kártya file vagy egy weboldal megjelnítésére; de kérdéses, hogy ez szükséges-e egy billentyűzetről]
@lad[Lehet például olyat, hogy a name, version, author, description utasítások tartalmát mutassa egy parancsra? Mert akkor azoknak is lenne célja, jelenleg akár megjegyzésként is beírhatnánk ugyanazt a szöveget, hiszen csak szövegszerkesztéskor mutatkozik.]
@thon[Ez kicsit hosszabb magyarázatot igényel. A "service" egész különleges állatfaj, nincs képernyője, és egy csomó mindent nem csinálhat - pl. nem indíthat programot. Ez persze szabály, de rögtön nem igaz, mert a billentyű-service még különlegesebb állatfaj, úgyhogy sokat kellett mutatványozni. A program indítást, annak ellenére, hogy működik, továbbra sem értem teljesen. De valami olyasmit kell elképzelni, hogy minden indításnál egy új példányt indít a programból. Ha egymásra mutogatnak, akkor ide-oda akár rengetegszer meg lehet nyitni ugyanazt a "help" file-t. Ezt nem könnyű látni, de pl. a back billentyűt meg kell nyomni rengetegszer, mire mindet bezárod. Szóval, amíg rá nem jövök, hogy mit kell tenni, addig nincs mutogatás. Szerintem a fő indítóablak nyissa meg a preferences (androidban így híjják) oldalt, aminek rögtön az elejéről elérhető a help. De a help a vége az utcának, onnan már mást nem lehet megnyitni majd. De most marad így, ahogy van, aztán meglátjuk.]
@lad[Huh. Megvan annak az oka, hogy én igazából csak Commodore 16-oson voltam programozó.]
@thon[Másik: a webView télleg mindent meg tud nyitni. De. Hogyan fognak a html lapok egymásra mutogatni? Ezt úgy tudom megcsinálni, hogy az összes weblapot kimásolom egy könyvtárba (a munkakönyvtárba), és akkor relatív útvonallal tudnak egymásra mutatni (remélem, de nem ismerem ennyire a html-t). Az biztos, hogy a belső "tárolt" változat nem tud egy másik tárolt változatra mutatni, ki kell másolni a könyvtárba. A sok lehetőség közül jelenleg kettőt tettem be gombról elérhetőnek: a web és az sd-kártya megnyitását. De semmivel sem nehezebb a munkakönyvtárban (mint alapkönyvtár) lévő file megnyitását engedélyezni (WORK pl??), és akkor bármelyik html oldalt meg lehet kézzel "címezni", vagyis pl. bármelyik help oldalt el tudjuk indítani. Szóval ez megy, tervezheted így a helpet. De a lapoknak a velük egy könyvtárban lévő file-okra kell mutatni!! Ez fontos, mert nem csináltam meg, hogy egész könyvtárrendszert kimásoljon. Bár biztos ez sem lehetetlen.]
@lad[Örömmel tervezném így a helpet, de sajnos egy árva hangot sem értek, mint rendesen. A jelenlegi koncepcicó szerint] [[:bestboard:start|itt]] @lad[indul és egyetlen névtéren, azaz könyvtáron belül tartalmaz sok oldalakat, természetesen linkek, képek, effélék vannak. Ha ez jó, szüret; ha nem, kérek szépen útmatatást, hogy mi legyen másként.]
@thon[Hát ezt egyszerű kipróbálni. Tedd be az egész miskulanciát a munkakönyvtárba, és induljon help.html-lel. A HELP ugyanis azt nyitja meg. Apropó, lehet, hogy te nem is látod a helpet? Ha nem telepítetted újra, akkor nyomd meg, a settings-ben a asset bemásolását. Betesz két test-et, meg a help.html-t.]
@lad[De látom. Viszont akkor rögtön újabb javaslat: ne a munkakönyvtárban lakjon, hanem azon belül egy ''help'' nevűben. Mert sok file lesz, akik zavarni fogják a kotorászást a munkakönyvtárban, még akkor is, amikor a file-választó már csak a Coatokat mutatja; néha más programmal is nyúl oda az ember.]
@lad[Azt még ki kell ötölnöm, hogy mivel konvertálom a wikioldalakat html-be.]
@lad[Kiötöltem, van siteexport plugin. Máris jókora könyvtárstruktúrát exportál (57 könyvtár, 335 file, pluginok nem is használt mindenféléivel, azokat persze majd kiöljük belőle), úgyhogy én bizony csináltam egy ''_bestboard/help'' könyvtárat, abba tettem, és a korábbi helpfile-t kicseréltem egy linkre, ami a manual oldalra mutat. Klasszul megjelenik – de a linkek nem mönnek. Nyilván mert rossz könyvtárban keresi őket.]
@thon[Oké. Először csináld meg az egészet egy könyvtárra, a txt-k közül úgyis könnyen kivesszük a file-okat. Addig amúgy is ki kell találnom, hogyan lenne a legjobb a másolás/vagy ne is másolja, csak a megjelenítést végezze el valahogy, magából a programból.]
@lad[Egy könyvtárban van, csak a nevéhez kell hozzáírni, hogy help.]
@thon[Stop, mégsem! Ezt találtam:]https://groups.google.com/forum/#!topic/android-developers/UXendm2c1oI @thon[Szóval, tedd csak be a munkakönyvtárba, hogy ott működik-e! Ha igen, akkor betesszük az egészet az asset mappába, és legfeljebb a hivatkozásokat kibővítjük, ahogy a második hozzászólás írja. És akkor ki sem kell másolni az egészet, vagyis nem kell  hozzá dupla hely.]
@lad[Mármint akkor mit tegyek a munkakönyvtárba? …pillanat, akartam föltenni egy példányt az exportból, de valami baj van vele, az összes linkek önlinkelővé váltak…]
@thon[Namármostantehátakkor. Egy olyan help kell, ami egyetlen könyvtárból elüzemel, vagyis minden html a vele egy könyvtárban lévő html-re, képre stb-re hivatkozik. Ezt kipróbálhatjuk, ha az egész rendszert - csak most, kipróbálásra - beletesszük a munkakönyvtárba. Ugyanis a HELP billentyű az  ott lévő help.html-ből indul (jelenleg). De! Ezt valahol tárolni kell, erre van az ún asset mappa; ami benne van a tömörített telepítőprogramban. Ha onnan tud működni - és ezt mondják - akkor ki sem kell másolni az sd-kártyára. Majdan egyszer. De most a kipróbálásra ott a munkakönyvtár, vagyis ahonnan a coat-ot olvassa be.]
@lad[Kicsit várjunk még vele, rá kell jönnöm, hogy miért nem működnek a linkek.]

@thon[File selector: mind a coat file, mind a work-directory kiválasztásra kerül. Nem ez lesz a végleges változat; most semmilyen ellenőrzést nem végez, vagyis nem csak coat file választható ki.] 
<del>@lad[Nekem ez továbbra sincsen, mindkét sor csak annyit csinál, amit korábban, dobozkában megjelenik a file-név, és beírhatom az újat.]</del> @lad[Hüüüüülye vagyoooook… egy sorral följebb köllött nézni…]
@lad[Jó bigyó. Ehhez tényleg nem kell több, mint kiszórni-szűrni a nem billezetfile-okat, és rossz billezet esetén (amikor kék alapon kabátgomb jelenne meg), hibaüzenet kíséretében visszaadni a file-választót, válasszon a pógár másikat, ez nem ízlett. Ha nem választ, akkor pedig töltsük be a) a fallback billezetet, b) azt a billezetet, ami legutóbb volt használatban.]
@lad[És persze a coatlog csak akkor jelenjen meg, ha kérjük, viszont akkor tova lehetne fejleszteni egy kis debugolóvá. Mutassa, hol van hiba a programszövegben, és gombnyomásra menjen oda, nyissa meg egy szövegdobozban és ugorjon a kérdéses sorra. Itt nem kell tudni többet, mint engedni a felhasználót beleszerkeszteni és kimenteni a szöveget. Akkor újratölteni, ha hiba van, megint mutatni.]
@thon[Tehát mostani működés: első indítás: megjelenik a help. Hibás coat: megjelenik a hibalista. Nincs hiba, sokadik indítás: semmi extra nem jelenik meg. Szövegszerkesztőben nem tudom megjeleníteni, mert nem tudok sorra ugrani...]
@thon[Van még egy módosítás: a list gomb elmozdulás után nem változtat, szemben a modify-jal. Ez fontos, mert így többször is használható ugyanaz a billentyű egymás után.]

@thon[Hibákat, javítási javaslatokat kérem! Bár a további javításhoz egy-két új dolgot alaposabban át kellene néznem...]
@lad[Egyet találtam. Időnként (nem mindig), amikor elkezdek szövegszerkeszteni, a Caps Shiftem lockolva van, holott ezt őtőle senki nem kérte.]
@thon[Ezt feltétlen írjuk be a todosba, de egyébként pont itt nem működik az autofunc off. Úgyhogy ez ezért van. Viszont egy kicsit nehéz kijavítani, de majd megcsinálom.]

@thon[Továbbléptem a fejlesztésben, apróságok, de sok következménnyel (nem tettem bele a coat szintaxisba, mert nem tudom hol állsz vele; másold be kérlek)]
@thon[Oppá, most látom, hogy erősen dolgozol rajta; és én meg még nem válaszoltam.] @lad[Itt alant is sok minden van ám, amire még nem; egészen a logóról szóló fejezetig vannak piros pöttyök.] @thon[No, amint lesz időm, annak is nekigyűrkőzöm. (Fentiek sincsenek benne a szintaxisban, szerintem jó lenne, ha annak alapszövegét csak egy ember változtatná - esetleg Te - én is csak saját megjegyzésekkel írok majd bele.)] @lad[A Coat1000-oldalon mindent lehet irkálni nyugodtan, én bármit elfelejthetek, aztán nem lesz ott, jobb lenne, ha mindketten írnánk. A végleges, publikus doksi más, bár azt se azért írom egyedül, mert ha Te írnád, nem lenne jó, hanem mert ez a dógom.] @thon[Ok. Bár a lenti pontok nagyjából meg vannak tárgyalva, el vannak fogadva - épp csak meg kéne csinálni mindezt.]
Szóval, ezek a ''3. FUNCTION- speciális funkciók'' alá tartoznak: @lad[átmásolva]
  * HTML ("fileName") - megnyitja WebView-ban a megadott file-t. Könyvtát megadható, az external sd-card (rendszer által meghatározott) alatt. HTML és UTF-8 kódolás alkalmazható (alapértelmezetten).
  * WEB ("webcím") - mint az előző, de egy web-pldalt nyit meg. Ha nincs kitéve a ''html:'/'/" (vagy "htmls:'/'/") kód, a ''html:'/'/"-t hozzáilleszti. Fontos, hogy a ''/'' jelet használjuk elválasztásra  (és ne a backslash-t, mint Windows alatt).
  * LOAD ("coatFileName") - betölti a megadott coat file-t (akkor is, ha az hibás!). A file-t a working directory-ban keresi. Fontos, hogy a preferences-ben lévő beállított coat file-t NEM módosítja, tehát a draft, vagy a reload az eredeti (nevezzük main-nek?) coat-ot tölti be. Szintúgy az eredeti jön vissza, ha valamiért a service újraindul (gép indítás, másik billentyűzet beállítása pl.)

Fontos!! Nekem ugyan működik, de nem teljesen tiszta, hogy mi történik olyankor, amikor kicseréljük a billentyűzetet, miközben egy billentyű meg van nyomva. Valószínűleg addig tartja az előzőt, de nem próbáltam ki. Pl. átcsúszunk a mellette lévő billentyűre. Az új vagy a régi ír? Majd megnézem.

Fontos2!! Nem tudom elképzelni, hogy a WEB és HTML mire jó a gyakorlatban, lévén ez egy billentyűzet, míg ez a két utasítás kilövi a felhasználó programját csak azért, hogy egy fix, már sokszor látott oldalt nyisson meg - még csak nem is a legjobb szerkesztőben... Hacsak nem egy log file elenőrzésére, pl. Mindenesetre tudja. Ja igen, merthogy helyettesítheti a PROGRAM/RUN, ha csinálunk (vagy már van) egy olyan programot, ami az utolsó file-t/weboldalt megnyitja.

ACTIVECOLOR / RELOAD / RECENT javítva

@s5[Tutorial és egyéb kiegészítések]

@lad[!Valamit nem értek. Elkezdtem tutorialt írni [[:bestboard:tutorial]] cím alatt, csináltam egy mintaprogramot, arról screenshotot, igaziból úgy néz ki, mint ott. Három és fél gomb széles, pedig ''COLUMNS 3'' van ott. Valami nem stimmel vagy én vagyok helikopter?!]
@thon[Nem vagy helikopáter, de ez így van jól. A ''COLUMNS 3'' azt jelenti, hogy MINDEN sorban 3 gomb teljes van, párosban és páratlanban egyaránt. Ezért kell inkább a ''HALFCOLUMNS'', mert az pontos. Beállíthatjuk máshogy is a számítást, de szerintem meglehetősen furcsa, ha az egyik sorban 3, a másikban 2 billentyű van, és ilyenkor az átrendezés is nehezebb. Az alapértelmezett szélesség tehát a "féllel több".]
@lad[Értelek. Igazad van. Jó, majd eszerint írom a doksit. Most kicsi késedelmet szenved megint minden, mert ma lomtalanítottunk, holnap pedig gabis nap.]

@lad[Ötlet, sőt kérés. Arra gondoltam, hogy írok egy Coat, aki semmi mást nem tud, mint Coat programokat írni, egyetlen layout, valamelyik angol kiosztás, minimális jelkészlet; esetleg a nyelv szavaival, mint egy korábbi billezetünkön is. Ezt bele kellene tenni a programba úgy, hogy 1. legyen a settingsben egy parancs, ami átvált erre a beépített billezetre és vissza a megadott Coatra, vagyis ha már megadtam az éppen készítendő-tesztelendő-tisztelendő Coat nevét, akkor ne kelljen egy másikra átváltanom avégett, hogy tudjam őtet szerkeszteni, aztán vissza, csak egy checkbox legyen, „built-in keyboard”, ha kinyomom, a megadott Coatot tölti be újra és automatice újraparsereli; 2. ha olyan hiba törpénik, amitől Windowsból ihellett kék halálba esne, a közepén kabátgombbal, akkor ne ezt tegye, hanem töltse be a beépített billezet, kapcsolja be a monitorsort és oda írja ki a hibaüzenetet (mivel ha ez utóbbit nem teszi, és a felhasználó pont nem nézett oda, amikor a toastban megjelent a hibaüzi, nem fogja érteni, hogy miért nem a művét látja). Ezeket érzem szükségesnek ahhoz, hogy igazából lehessen billezet fejleszteni on board, az andikon.]
@thon[Ne írj ilyet, mert már irtam; csak nincs befejezve. Ugyanis akkor jött a webview meg a file-selector. De majd elküldöm, legalább az alap megvan.]
@lad[Rendicsek, lényeg, hogy legyen egy fallback billezet a programban, és 
ne valamely rivális cég terméke legyen az (mondjuk a Samsungé, aztán még fölibénk kerekednek a billezetpiacon).]
@thon[!@app[160504] - kizárólag köztesváltozat, minden régi működik, de az újak nincsenek kész benne. Egy egyszerű file-választót nyit meg, meg van neki egy browsere (ld. HELP).!]
@lad[Megint a minimális fogalmazás, de rájöttem, hogy meg kell szerezni a benne levő test.txt-t, és a millió layout egyikén van egy help gomb. Ami a LAttilaD.orgot nyitja meg. De file-választót nem találtam.]
@thon[Feltettem a test.txt is a file-ok közé. A file választó induláskor elindul, de sem formátumában nincs beállítva, sem összekötve nincsen a programmal.]

@thon[Egyik sincs beépítve. Azért kell, mert a list csak ezzel fog jól működni. Tartalmazza a test.txt-t (külön is feltöltve), nézd meg a make billezetet! (az sincs teljesen kész) Viszont arról nyílik egy gen meg egy color, meg szerintem a nyilak is elég jók. Ez most télleg ilyen köztes cucc, csak hogy lsd dolgozom rajta... Ja, és kérek véleményt, bővítést stb.]

@lad[Egyelőre elvesztem a rengeteg trükkös layout között, nagyon klassz meg minden, csak még nem találok semmit. De ez nem is cél, a programnak az a lényege, hogy mindenki saját magának csinálhat billezet.]
@thon[Bocs. Az ötlet az volt, hogy egy "alap" kiosztásról többet is el lehessen indítani. lit: irodalmi szöveg, prog: programozáshoz való, mini: telefonra, make: készítéshez. A lay kezdetűek próbabillentyűzetek. A make alatti rész, ami neked kiindulási alap. És a make-ről el lehet menni két irányba: gen: az alpvető beállítások, meg az irányok és color, ahol az irány szintén ott van, mert nem jöttem rá melyiken jobb. A lit szintén az irodalmira visz, ami az alapról is elérhető. Visszafele a sját lila gombjaikkal tudnak menni. NIncs kész az egész, de a list billentyűkön lévő szintaxis már használható alap (szerintem)]

@thon[Amúgy az "alap" billezet beállítására van parancs, ami visszatölt mindent. Majd megnézem, hogy az alapot is beállítja-e; de ez   megoldott.]
@lad[Mi az a minden, amit visszatölt?]
@thon[Van egy ún. ASSET mappa. Amit abba beleteszünk (help billentyűzetek stb.) abból ilyenkor kimásol egy példányt a munkakönyvtárba. Ezzel elkerülhető, hogy ne működjön a cucc, mert valaki megváltoztatott valamit.]

@s5[Bővítés a makrónyelven]

@lad[A tutorial írásánál utána kellett járnom, pedig régebben is tudtam: ha egy programszöveget nem ''`<code coat1000>`</code>'' közé raksz, hanem ''`<file coat1000 file-név>`</file>'' közé, akkor az adott file-néven letölthető lesz. Átírom az illetékes makrónkat.]
@lad[Nem írtam át, másikat írtam helyette. A `@coat továbbra is megvan, de van egy `@code is, ami így működik:]
''`@code[!//file-név//`|//programszöveg//!]''
@lad[!!A felkiáltójelek az elején-végén azért kellenek, mert egy Coat-programban lehet ] is, és akkor az véget vetne a programszövegnek. Ezért megcsináltam az egymásba ágyazott makrókat, már rég kellett volna. Ez itt egy ''lad'' makró, hogy zöld legyen, és most már ebbe is lehet [[coat1000]] linket tenni, nem szakad meg tőle a zöld szöveg. Lényeg, hogy az elején és a végén ugyanannyi ! legyen, nulla és tíz között, és egymásba ágyazott makrók ne használjanak egyforma mennyiségű !-et. Egyébként lehet a szövegben ], lehet !, minden lehet, sőt együtt is szerepelhetnek: !] – ha nincs pont ugyanannyi !, mint a makró elején és végén (most kettőt használtam, de itt a szövegben egy volt, tehát nem egyezik), akkor továbbra is tart a makró.!!]
@lad[Pontosítás: kívülről befelé csökkenő számú felkiáltójel kell.]
@lad[Sajnos még nem tökéletes, mert ha `| jel van a belső makróban, azt a külsőhöz tartozónak veszi.]

@thon[A legalja után jutott eszembe (file-választó)]
@thon[A file választó (amit korábban csináltam), elég jó, de a coat elemzéshez lassú.]
@lad[Ezt már akartam kérdezni, az mi az, hogy elemzéshez lassú? File-választó dolga választani file-t, aztán a parser majd elemzi, vagy én nem értek valamit?]
@thon[Ezen is elkezdtem dolgozni, de aztán a bllentyűzet miatt megszakadt. Szóval van egy csomó anyagom a korábbi android lapról, amit most folytatni meg átolvasni kéne/lehetne pl. file-választó. De ha már átolvasom, akkor át is tehetném vicky alá, meg az új fejlesztőrendszer, meg a github stb. alá.]
@lad[Sajnos pont a legidőigényesebb részében, az átolvasásban nem tudok segíteni, mert teljesen gyüge vagyok az egészhez. Viszont ha egy cikkre azt mondod, hogy hozzam át Vickybe, azt meg tudom csinálni, mondjuk egy helyütt összegyűjtöd a linkjeiket, én pedig mék és konvertálom. Bele is szerkeszthetsz, használhatsz flatpresses vagy már vickys szintaxist, bármit. A tárgymutatózást szerencsére meg tudom csinálni, ahhoz nem vagyok gyüge.]
@thon[Arra gondoltam, hogy lehetne itt egy új android oldal (vicky), aminek az első bejeegyzése (természetesen) a billentyűzet lesz, aztán majd elemezzük cikkekben, ami érdekes. Ezzel párhuzamosan a fontos részeket átemelem a régiből, referenciának nagyon jó, és egy helyen van. Utána! a régit be is csukhatjuk.
Viszont a blogos elrendezéssel szemben a fő struktúra a tematikus elrendezés kellene legyen, úgy ahogy a könyvtárlista van a régi jobb oldalán. Ettől, még a blogos, dátumos rész is működhet, csak a fő szempontot mondom. Ezt senki nem fogja folyamatában olvasni, hanem legfeljebb kikeres egy adott és érdekes problémát. (pl. én magam is). Megoldható ez szerinted?]
@lad[Első körben a tárgymatatót javaslom. Megfelelően kezelve szerintem rengeteget segíthet az oldalak csoportosításában. Aztán akármit lehet, például tárgymatatót a tárgymatatóhoz, mondjuk ha a matatóban szerepel //barnamedve, jegesmedve, koalamedve, medvecukor// és //Medvegyev,// akkor ezekből lehet készíteni egy listát //Medveféleségek// címmel, amiben megjelenhet a matatónak ez az öt kulcsszava, és az összes oldal, amire mutatnak. Vagy csak az oldalak egyben, ahogy praktikus. És ehhez csak akkor kell megint hozzányúlni, ha új kulcsszavak merülnek föl, amik szintén ide tartoznak //(plüssmedve, elvetemedve).//]
@thon[Viszont stílus szempontjából talán jó lenne valami más szín vagy forma kombináció, hogy elkülönüljön a lattilad törzsétől. De erre nincs ötletem, meg engem igazából nem is izgat ez a rész, csak gondoltam.]
@lad[Minden megoldható, legfeljebb némi agymunka. A Vickynek fantasztikus lehetőségei vannak, én magam csináltam hozzá tárgymutató-készítőt (][[:tv-basic/címlap|itt megnézhető]]@lad[), ezernyi mindenfélét tud. Kiindulásképpen csináltam egy] [[:android:blog|Android]] @lad[névteret és teljes hozzáférést adtam a Best-csoportnak, mert ez az egy van, amit csak én tudok megcsinálni, minden mást elérsz Te is. Tied a világ, majd jövök, ha valamit bűvészkedni kell.]
@lad[Ami az elkülönülést illeti, egyelőre fogalmam sincs – Talema blogja se különül el, ugyanaz a dizájn, ugyanaz a fejléc. Végeredményben ezek csak névterek ugyanabban a wikiben. Majd törpölök.]
<del>@lad[Kitörpöltem, a névtérnek kell egy template, aki makróval berak egy WRAP-et, abba beírjuk a stílust és mienk a világ. Mindjárt kipróbálom.]
@lad[Stimmel, az oldalra rákerült egy barna téglalap, mert ilyen volt készen. Azt gyártok helyette, amit akarok, háttér, font, akármi.]</del>
@lad[Mégse is. A WRAP tényleg nagyon sokat tud, a barna helyett most világoskék van kerek sarkokkal, de ez csak ott bent az oldalban érvényes, a fejlécek, miazmások változatlanul maradnak. Így hülyén néz ki. Mármost van LoadSkin, amivel meg tudom adni, hogy a) a felhasználó saját maga állíthasson be magának skint (ez van most érvényben, ez csinálja a skinválasztó menüt a jobb felső sarokban) vagy b) az admin mondja meg névterenként vagy akár oldalanként, hogy melyik skin legyen érvényben. Ez utóbbi pont jó lenne nekünk, a különböző blogokhoz a tulajdonos ízlése szerint más-más skint rendelnénk, de akkor elvész az a) pontbeli funkció, a skinválasztó menü nem csinál semmit. Tehát beásom magam a LoadSkinbe, lehet-e olyat kérni tőle, hogy „ha nincs a) beállítva, akkor b)”.]
@lad[Nem, helyesbítek, ennél okosabban van megírva. Ha nincs admin által beállított skin, akkor a felhasználóit használja, egyébként az adminit. Vagyis ha így állítom be, akkor a Vicky többi részén továbbra is a felhasználói skin lesz, illetve ennek hiányában a default, viszont azokon a névtereken, ahol adminilag külön beállítok másik skint, ott csak ez lesz, és nem lehet felhasználóilag áttérni másikra.]
@thon[Öööö.... Azt nem lehet, hogy beállítasz valami alapértelmezettet jobbra fent, aztán mindenki arra változtatja, amire akarja?]
@lad[De, elvileg most is így működik – kivéve az Android névtérben, egyedül csakis ott, ahol beállítottam kézzel a jó ég tudja már, melyik alternatív skint, és most az van érvényben, ha tetszik, ha nem. Ez a bajom, hogy akkor viszont a felhasználó nem változtathatja meg magának.]
@thon[Igazából a kérdés inkább az, hogyha én (mint felhasználó) akarom, akkor tudom-e a az egyik oldalt (mondjuk a tiédet) az egyik, míg a másik oldalt (mondjuk az androidot) egy másik stílussal nézni? De szerintem nem kell semmi varázslás, ez jó így is, ahogy van. Viszont azt még mindig nem értem, hogy miként lett ebből Neked blog? Merthogy itt nincs blog, csak szövegek.]
@lad[Jelenleg nem tudod, illetve az egyik központilag van beállítva és nem változtatható meg.]
@thon[Azon gondolkodom, hogy ez ugyan mind érdekel, de mi az, ami _igazából_ kell. Valószínűleg nekem cikkekként egyetlen formázható terület meg egyetlen cím kell. Az egészet valahogy bele kéne pakolni egy olyan cuccba, mint a categories ott oldalt; ill. egy blogszerű-időrendi bejegyzés sem lenne rossz még ettől. Meg talán a tárgymutató sem. No, de hogyan csináljak ilyet? Meg tudod ezt mutatni? Inkább megfordítom a kérdést. Be tudnál tenni mondjuk 3 kétsoros cikket az android névtérbe? Mert akkor azok alapján már tudom folytatni.]
@lad[Tehát blog legyen? Nincs akadálya, a Talema-blog indulásakor készítettem egy üres blogapparátot, azt berakom oda és máris mehet. Pillanat.]
@lad[Kész is, nem tartott soká. Két linket jegyezz meg, persze ideiglenesek és megváltoztathatók:]
[[http://ujandi.lattilad.org]] @lad[– ha ezt megnyomod, kapsz egy //Cím// nevű szövegdobozt, írd bele a cikk címét (a rendeset, ékezetekkel, nagybetűkkel, írásjelekkel), nyomj Entert, és kapsz egy üres cikket fej- és láblécekkel. A kettő közé írd a cikk tartalmát.]
[[http://vikiandi.lattilad.org]] @lad[– ez egyenesen az új blogra ugrik. Azért nem] [[http://android.lattilad.org]]@lad[, mert olyan már van.]
@lad[!Bocsánat, a tárgymatatót elfelejtettem, de most már megcsináltam azt is. Azt írd bárhová, hogy ''`@andix[akármi]'', és akkor az //akármi// bekerül a tárgymatatóba, az illető cikk linkjével. Ha azt írod: ''`@andixek[akármi valami izé]'', akkor több szót is megadhatsz szóközzel elválasztva, és mindet beteszi. ← Ezt utólag tettem hozzá, mert rájöttem, hogy többszavas kulcsszó is kellhet. Ha ''`@s5[alcím]'' típusú alcímeket írsz, mint itt a chatoldalon, akkor az illető alcímhez ugrik a tárgymatató. Persze ezen is rengeteget lehet még variálni.!]
@thon[Tökéletes  lesz. Úgyis a cikk a lényeg, aztán majd körítünk köré. Még azt nem látom, hogy az egyes cikke hogyan és hol kerülnek tárolásra. Minden cikk egy wiki dokumentum? És mi akoncepció a file-névvel? Mármint hogy miként tudok egyik cikkről a másikra hivatkozni?]
@lad[Igen, minden cikk egy wikioldal, voltaképpen csak az teszi őket bloggá, hogy egyazon névtérben (könyvtárban) vannak, ami jelen esetben ''android:blog'' (hagyományos helyesírással ''android/blog''), és van egy oldal (szintén ''android:blog''), ami tartalmaz egy {`{blog}`} utasítást, ami kilistázza… ööö… a Talema-blog tartalmát, izé, kijavítottam. Onnan lett másolva a file utolsó alkalommal.]
@lad[Hivatkozni ugyanúgy tudsz, mint máshol, akár a címmel: `[`[Káposztástészta-kopasztás kesztyűben`]`], akár a file-névvel: `[`[kaposztasteszta_kopasztas_kesztyuben`]`] – ez utóbbit megtudod az URL-ből. A blogon belül nem kell több, mert együtt vannak, de ha más névtérből – például innen – akarsz hivatkozni rájuk, akkor kell a cím vagy file-név elég, hogy '':android:blog:''. Itt a kettőspontot használjuk törtvonal helyett.]
@lad[Egyébként ezt tartom a Vicky, azazhogy a Dokuwiki nagy előnyének a Flatpresshez képest. Ott van egyrészt a blog, másrészt egy külön statikus könyvtár, amibe az úgynevezett statikus oldalakat bepakolhatod, természetesen korlátlan mennyiségben, de együvé, nincs módod szeparálni őket. És persze egy Flatpress-installációhoz egy blog tartozhatik. A Dokuwikiben viszont magad alakítod ki a könyvtárstruktúrádat, ami akkorára nőhet, amekkorára csak akarod, csak a tárkapacitás szab neki korlátot, ha szab; lehet ezer blogod, ha csinálsz nekik külön névteret és külön egy-egy oldalt, ami listázza őket. Ezenfelül állhat mellettük akárhány komplex könyvtárrendszerben elhelyezett írásmű. Nálunk például ez idő szerint huszonhárom könyvtár nyílik a Vicky gyökérkönyvtárából, ebből egy, amiben a saját blogunk van, egy a Talema-blog, egy a Te új blogod, egy ez a Thon névtér, egy a könyvtár, de a többoldalas művek külön névteret kaptak, mint a Login, az Irodalmi lexikon stb., meg vannak mindenféle kiszolgáló névterek. És a hozzáférési jogosultságok végképp szeparálnak mindent, mert például azzal, hogy Mártának szerkesztői jogot adtam a saját blogjához, itt a Thon névtérben semmilyen jogot nem kellett kapnia, még olvasásit sem. A Flatpressben ezt se lehetett, nem is lett volna mit szeparálni. Apropó Flatpress, az ottani blog cikkeit hozzuk át az ittenibe? Mert az némi pepecseléssel jár az eltérő leírónyelv miatt, azt inkább nekem kéne csinálni, már megvan rá a technikám, Neked meg van ölég dolgod.]

@lad[Amikor Márta vickys blogját csináltam, közel kétezer cikket hoztam át a régebbi blogjaiból, nem tűnt föl, de most ezen az androidoson azért elég látványos volt, hogy egyetlen próbacikk van benne és máris három darabot tüntet föl, úgyhogy egy bugot megint ki lehetett szűrni.]

@thon[Fentieket még emésztem, ámbátor nem tűnik ördöngősségnek. Gondolom el kell kezdeni csinálni, aztán megy magától.]
@thon[Nomármostanság. Hát, időm az nincsen, csak ötleteim, de azért már ez is valami. Igazán szegény lennék ha ötleteim se lennének. (Ezt a beszélgetést áttehetnénk valami vickys alrész, vagy akár a blog alá, ha gondolod. Bár itt sincs útban.) Tehát: ötlet a következő:]
@thon[A tapasztalatom az volt az androidos részekkel, hogy se időm, se energiám egy komplex programot megírni, mármint a doksiját. Viszont az olvasókat nem is érdekli pl a bestboard részletes felépítése. Érdekes, bele lehet kukkantani, lehet talán egy-két ötletet csenni belőle, de soha senki nem fogja venni a fáradtságot, hogy feltérképezze az egészet - hacsak nem akarja tovább fejleszteni; de akkor meg a felületes leírás nem elég. Lényeg: ezeket nyilván érdemes itt is bemutatni (hirdetni), akár egy-két részt kiemelni, de nem részletekben.]
@thon[Ami fontos: az apróságok. Egy-egy kis példaprogram, ami egy-egy konkrét problémát mutat be. Ezek viszont szépen fejlődnek: pl. a lista, aztán a szűrt lista, aztán a háttérben betöltött lista stb. Szóval sokkal inkább bővülő könyv v. példatár, mint blog. folyt köv...mennem kell.]
@lad[Lehet úgy is. Ha nem használod, netán letörlöd a blog file-t, akkor megszűnik blog lenni.]
@thon[Befejezem.] 
@thon[Szóval elsősorban könyv v. példatár, ahol akár egy guglis keresés elvisz a listákhoz, és végigolvashatod az egész listarésznek az összes cikkét (ez van a régiben oldalt, a categories alatt). Ugyanakkor blog is, hiszen a cikkek majd csak az idő függvényében szépen egymás után csordogálnak; és egyáltalán nem baj (sőt, kell is), hogy a megjelenés (validitás?) ideje a sok változás miatt rögzítve legyen. Ezeket a cikkeket egyébként én magam is rengeteget használom, de sok rá a hivatkozás is, úgyhogy nagyon is jó, ha van ilyen.]
@lad[Kategóriák nevű fogalom nincsen a Vickyben – emlékeim szerint –, de csinálhatunk. Lehet például //két// tárgymatató, egy rendes és egy kategóriás. Például a barnamedve-jegesedés folyamatát tárgyaló cikkben lehet háromszáz részletes tárgymutató-bejegyzés, mint //fehéredési együttható, medvebunda-hipózás, fehér, szürke és illegális medve,// meg ami kell. Viszont a kategóriás matatóban csak annyi jelenik meg erről a cikkről: //Medveféleségek, Történelem.// Teszem azt.]
@thon[Mivel a régi androidos cikkek (példák) is ide tartoznak, azokat is át kell olvassam, ki kell javítsam (mert sokat változott azóta az egész rendszer), és így majd azok is át fognak kerülni. Ha automatikusan, rejtve át tudod dolgozni őket, az jó, mert akkor abból indulok ki, de egy az egyben nem lehet (érdemes) őket az újabb blogba tenni. Akkor már legyen a mai elveknek mindenben megfelelő. Ha dolgoznod kell vele, akkor majd inkább célzottan egy-egy cikket megnézünk.]
@ad[Automatikusan nem, de azért nem akkora was ist das, nincs tele speckó formázásokkal, pluginokkal, gondolom. Egypár globálcsere. Majd megnézem, mi kell hozzá.]
@thon[Egyébként lehet azt is, hogy ez lesz az android cím, és az első cikk hivatkozik a korábbi, csak más néven elérhető blogra, ha valaki referenciát szeretne. Aztán ha egyszer minden értékes cikk átkerül, akkor azt egy tóparti vacsorával egybekötve bezárjuk.]
@lad[Persze.]
@thon[Kb. ez a terv, de hogy miként fog beleférni, nem tudom. A billentyűzet azért azt mutatta, hogy mindenre nem lesz idő. Viszont a billentyűzetben is vannak olyan rövid témák, amiket innen-onnan összeszedtem, és egy oldalban össze is foglalhatóak. Hát, a talicska megvan, már csak el kéne tolni...]
@lad[Kis lépésekkel, Ellie. Előbb-utóbb mindenre jut idő – Neked legalábbis. Nekem muszáj mindent azonnal, mert különben elfelejtem…]

@s5[Logó]

//Ennek a szakasznak a tetején legyen a logó mindenkori legfrissebb Coat-szövege. Ez most Tamás kódja, május 2-án 00:15 körül.//
@code[!!logo.txt|
  coat (1000)
  font "Asap-Regular.ttf"
  let (logo
  block (
	button (text 'x' addtitle (text 'Ω' color 0cff6 yoffset 500) color 0c0f9)
	button (text 'x' addtitle (text 'ණ'  color 0cfcc yoffset 500) color 0c99f)
	crl
	button (text 'x' addtitle (text 'צ' color 0c99f xoffset 900) color 0cfcc)
	button (text 'x' 
		addtitle (text "Best’s" BOLD size 750 yoffset -380) 
		addtitle (text "Board" BOLD size 750 yoffset 180) 
		addtitle (text "beta" ITALICS size 400 yoffset 620) 
		color 0c0c0)
	button (text 'x' addtitle (text 'ቜ' color 0c9cf xoffset -900) color 0ccf9)
	crr
	button (text 'x' addtitle (text 'ゑ' color 0ccf9 yoffset -500) color 0c9cf)
	button (text 'x' addtitle (text 'स' color 0c0f9 yoffset -500) color 0cff6)
  )
  )
  addlayout (id logolayout start
  halfcolumns 6 rows 3 align odds asboard color 0nk)
  block (logo layout logolayout row 1 column 1)
!!]
@thon[Utolsó ötlet/feladat: kéne logo is! Ha SVg-ben csináltad, vagy a részeihez hozzáférek, akkor én is tudok játszani az előzővel. De nem ragaszkodom hozzá, idő ugye...]
@lad[Coatban csináltam, csak hát az a szövegrész ha meg is van még, már rég nem kompatibilis a mai nyelvvel. Megpróbálom megkeresni, de szerintem újraírni se nagy kunszt.]
@lad[Megtaláltam, szerencsére nem is változott a nyelv olyan sokat. Ez az egész file.]
++++elavult|
  coat (1000)
  let (logo
	block (
		button (addtitle (text 'Ω' color 0cff6 yoffset 500) color 0c0f9)
		button (addtitle (text 'צ' color 0cfcc yoffset 500) color 0c99f)
		crl
		button (addtitle (text 'स' color 0c99f xoffset 900) color 0cfcc)
		button (
			addtitle (text "Best’s" size 750 yoffset -250) 
			addtitle (text "Board" size 750 yoffset 250) 
			color 0c0c0)
		button (addtitle (text 'ቜ' color 0c9cf xoffset -900) color 0ccf9)
		crr
		button (addtitle (text 'ゑ' color 0ccf9 yoffset -500) color 0c9cf)
		button (addtitle (text 'ණ' color 0c0f9 yoffset -500) color 0cff6)
	)
  )
  addlayout (id logolayout start
	halfcolumns 6 rows 3 align odds asboard color 0nk)
  block (logo layout logolayout row 1 column 1)
++++  
@thon[Hát ez nagyon fura. Nekem tökéletesen megy. Semmi hibaüzenet? Valahol előtte nem áll le? Nézd meg a coat.log-ot!]
@lad[Á, közben megoldottam, csak átvetted az oldal szerkesztését és nem tudtam föltenni az új változatot. Most már az van itt fölül, középre gyömörített tartalommal, hogy így lehessen kivágni:]
@png[logo_2016-05-01-22-41-09-1]
@lad[De már emlékszem, hogy amikor legutóbb idáig eljutottunk, akkor még megbeszéltük, hogy kontrasztosabb kell, mert kicsiben nem fog látszani. Csak aztán abbamaradt az ügy. Hamarosan csinálok kontrasztosabbat.]
@thon[Ja, hiányzott belőle a ''logo''. Szóval a kontraszt kell, igen, meg a best's board betűtípusát valami amerikai hamburgerezde betűtípusára cseréljük le. Vagy ami kicsit lekerekítettebb. Esetleg picibe/ferdén/utólag a beta odafér? És még egy egy picit toljuk el valamerre, ne legyen pont középen. Na jó, más bajom nincs is... Visszavonom: legyen inkább pár különböző változat, aztán választunk. Kicsibe több is elfér egymás mellett, a nyertest kinagyítjuk.]
@lad[Gondolom, mindent lehet, de én nem tudom ám, milyen betűtípust hamburgereznek az amerikaiak.]
@lad[Ja, ha rendereled a logót és képet csinálsz róla: a lefoglalható képernyőhányadot nálam meg kellett növelni, mert különben nyomott lett a kép.]
@thon[Azt ugyan én se, de ez valahogy nagyon "kemény". Olyat kéne, mint ami körbe van. Dejavu sans? ]
@thon[Nem tudom, mi van benne: de pl. ez: https://www.fontsquirrel.com/fonts/asap?filter[classifications][0]=comic&filter[classifications][1]=pixel&filter[classifications][2]=sans+serif&filter[license][0]=app&q[term]=&q[search_check]=Y]
@lad[Minden jó, csak honnan szerzed be az Asap-Regular.ttf-et? Nekem csak egy zipet ad, akiben otf-ek vannak.]
@lad[Megnéztem Windowson, klassz font lenne, csak némi latin betűkön kívül semmi sincsen benne, vagyis a Best’s Board megjelenne, de a többi karakter nem. Egyrészt. Másrészt nagy kérdés, hogy ikonméretben látszik-e a változás. Tessék az iménti logó 64·64-ben:] @png[ikon_2016-05-01-22-41-09-1]
@thon[Simán letöltöttem a FontSquirell-ről. Mindenre van liszensze, és vagy nyolcvan elvarázsolt nyelvet támogat (legalsó pont), de legalábbis a mi karaktereink működnek. Sőt, van hozzá symbol-készlet is, de azt nem töltöttem le. A zip (mindkettő) feltöltve, abból vettem ki a ttf-eket is, bár sok egyéb is van benne. A fontokat nézegetve arra jöttem rá, hogy vidámabb, ha az s szára nincs végighúzva. Emellett viszont egyenesen áll.]

@thon[Szerintem jobban néz ki, csak a színeket kell módosítani. Középen valami égszínkék/fehér kombó?]
@lad[Mélyebb kék kellene a kontraszt miatt. Kék háttér, fehér betű.]
@lad[Megvan: nekünk erre van szükségünk.] [[http://visibone.com/colorlab|Visibone Color Lab]] @lad[Itt ki lehet kísérletezni, hogy mely betű- és háttérszínek adnak jó kontrasztokat, igaz, hogy csak a Visibone-színek közül, de az bőven elég, és a nyelvünk is támogatja már a Visibone-színeket. Sokkal gyorsabb és kényelmesebb, mint a Coatot szerkesztgetni, átmásolni, draftolni, miazmás.]
@thon[Az ikon még kisebb (48x48 talán). Lehet, hogy az egyik sarokban el kéne hagyni a szomszédos betűket, hogy a közepe nagyobb legyen; a felirat meg lehet csak "BB" vagy B'B vagy ilyesmi az ikonban. De a nagy kontraszt tényleg kell.]
@lad[Ha 64·64-es képet csinálok, az az én homescreenemen ugyanakkorában jelenik meg, mint a programikonok; ez gyakran megesik, mert emléköztetőnek mög mindönféle célra csinálok ikonokat. Ezért gondolom, hogy ez nekik a szabványméret.]
@lad[Nagyítsunk rá a középső hatszögre úgy, hogy balra fölfelé csússzon, a görög, a héber és a dévanagári betű ekkor kimegy a képből, viszont az átellenes oldalon visszajöhetnek (ha kiférnek), ugyanarra a gombra téve, mint a társaik. Ez azt is demonstrálja, hogy egy gombon több jel is lehet. Majd PC-ről megcsinálom.]

@lad[Újabb ötlet: csináljunk picike Coat file-okat, olyasféle terjedelműeket, mint a logót elkészítő program, és csak egy-két dolgot demonstráljanak. Ezek előnye, hogy a kezdő felhasználó is jobban át tudja tekinteni (én a saját Kinesámat már rég nem), meg tud ismerkedni egy-egy funkcicó működésével. De ezt csak akkor lehet, ha meglesz a file-választó, mert teljes ábécé nélküli billezeten nem lehet beírni a másik file nevét.]
@lad[Jól jönne továbbá egy olyan utasítás, aki betölt egy másik Coat-programot, lehetne a neve ''keyboard'', paramétere egy file-név.]
@thon[Párhuzamosan a file-választó is megvan, de még dolgozom rajta. Ugyanis még nem a mi fileainkat választja ki. A fenti rész is megvan, csak csinálok hozzá billentyűt.]
 
@s5[FIELD avagy PLAY]

@app[160427]
Egy kisebb hiba miatt a MEM billentyű nem törölte a beírást, amikor a tárhelyet töröltük. Javítottam.
Ennek kapcsán: FIELD. Arra jöttem rá, hogy inkább úgy van értelme a TEXT/FIELD megkülönböztetésnek, ha a TEXT értékét egy az egyben, automatikusan átveszi, a FIELD-et viszont karakterről karakterre feldolgozza, keresve a benne elrejtett "utasításokat" (pl. ctrl-a, tedd ide a kurzort stb. - amiről korábban beszéltünk.) Ennek elkészítése még várat magára. És persze talán nem FIELD lesz a neve. Azt még ki kéne találni, hogy pontosan milyen szintaxist is kövessenek ezek az elrejtett utasítások. Feltételek: a tokenizáló már egyszer minden stringet átnéz, és a ''\'' kezdetű karaktereket kicseréli. Ha érti, ami írva van (pl ''\n'') akkor a megfelelő kódra, ha nem érti, akkor csak kihagyja a ''\'' jelet. Ezt tudnunk kell, hogy MINDEN stringben megtörténik, tehát ezt csak olyan módon használhatjuk, hogy a TEXT-et ne akadályozza. Pl.: nem tehetem úgy {ide} az utasítást, hogy mellette írok egy \{-t a kapcsos zárójelnek.
@lad[Előbb azt találjuk ki, hogy milyen funkciók szerepeljenek benne. Gondolom, kurzor helyének megjelölése (jelenlegi elképzelés szerint ''\c''), kurzormozgatás föl-le-balra-jobbra, page up/down, home, end, ilyenfélék? Ha igen, akkor a javaslatom: zárójeles parancsok. Mivel a zárójelet már amúgy is használjuk, én maradnék ennél, de legyen a parancsok számára dupla. Vagyis (`(left)`) vinné balra a kurzort, (`(home)`) lenyomna egy Home gombot, és akár (`(cursor)`) lehet a kurzorpozicionáló parancs. Az idézőjel mutatja, hogy ez nem programszerkezeti zárójel.]
@lad[Hátránya, hogy ha itt a Vickyben hivatkozunk rá, akkor a két zárójel közé tennünk kell egy `` jelet, mert különben a Vicky lábjegyzetkészítő parancsként értelmezi.]
@thon[Sztem. jobb az egy zárójel, és kettővel jelölni az egyet. Vagyis a valóst. Márminthogy: ha egy zárójel a 'tag' jelzése, akkor két zárójel kikapcsolja, sőt négy zárójel két zárójelet ír, és nem kezdi el a tag-et. Ezzel szemben fordítva: ha két zárójel a 'tag' jelzése, akkor egy ugyan lehet tényleges, textuális zárójel, de dupla zárójelet praktice lehetetlen lesz írni. Csak gondoltam, végiggondolom még egyszer, azért írom.]
@lad[Úgy is lehet.]
@thon[Hm.hm. Van TOKENIZÁLÓNK, azt kellene használni, és ahhoz kitalálni egy egyszerű kódrendszert, "string" konstansot nem nagyon használhatunk, mert azt be kellene ágyazni. De keyword tokent bármennyit. Mit szólsz a következőhöz: Kötelező egy token, ami megmondja, hogy mit csinálunk, és lehet egyetlen keyword vagy szám paramétere. Ezt akár külön-külön is zárójelbe tehetjük, de folytatódhat is. Mert mit akarunk elküldeni? Bármit, amit amúgy rátehetünk egy gombra. Ez nem lehet textpacket, mert éppen abban írjuk. Lehet KEY és akkor vagy egyetlen karakter, vagy keyword, ami a billentyűt azonosítja (ezek már amúgy is definiálva vannak). Az a gond, hogy a meta-billentyűknél számít a létszám is, azt hogyan adjuk meg zárójel nélkül? Vagy mindet ki kell írni: TURNON CTRL TURNON ALT TURNOFF SHIFT KEY A - és akkor még vissza is kell állítani. Emellett is szól egyébként érv: mert minden utasítás egy billentyűnek felel meg, de azért jó lenne rövidíteni. Ezen még agyalni kell. No és a harmadik csoport a funkciók, mozgások, ami megint csak egyszerűbb.]
@lad[Lássuk csak, miket tudok elképzelni.]
  * ''field "turnon ctrl turnon alt turnoff shift key a"''
  * ''field "turnon (ctrl alt) turnoff shift a"''
  * ''field (turnon (ctrl alt) turnoff shift key a)''
  * ''field (combine (ctrl alt a))'' @lad[– ez utóbbi úgy értelmezendő, hogy a megadott metákat és gombokat kombinálja, de csak ezeket, vagyis ha előzőleg bárki be volt kapcsolva, az ki lesz]
@lad[Közben találtam nevet is ennek a parancsnak. ''PLAY''. Mivelhogy lejátszik egy megadott billentyűsorozatot.]
@lad[Ja igen. Ugye lesz a paraméterei között ''TAP (x y)'' és ''SLIDE (x1 y1 x2 y2)'' is? Hiszen egy androidos képernyőn a legtöbb dolgot így lehet elérni.]
@thon[Akkor ezek szerint ''PLAY''. Viszont ''PLAY''-nek, ugyanúgy mint a ''TEXT''-nek egyetlen string paramétere van. Ami nem string, azt meg kell nyitni zárójellel:]
  * ''play "Hello (turnon (ctrl shift) turnoff (alt) key KEYA) világ"''
@thon[PALY-en belül nem lehet sem " sem ', tehát itt nincsenek string és karakterkonstansok. (Mondjuk nem is kellenek) A TURNON és TURNOFF utasítások értelme, hogy a paraméterlistájukat ki és bekapcsolják. Mivel eddig ezek egy layouthoz vagy egy gombhoz voltak kötve, ezért csak arra az egy elemre működtek. Tehát lehet ilyet pl: ]
  * ''play "Hello ( SEND ( KEY  keyc TURNON (ctrl ) TURNOFF (shift ) ) ) világ"''
  * ''play "Hello ( TURNON (ctrl ) TURNOFF (shift ) ) világ"''
@thon[Az elsőben a SEND áll a coat különböző buttondefiníciói helyett, egyébként az írásmód ugyanaz, mint a coat. A második viszont ki/be kapcsolja a meta billentyűket. Vagy lehet ez is (de szerintem az előző jobb)]
  * ''play "Hello ( META ( TURNON (ctrl ) TURNOFF (shift ) ) ) világ"''
@lad[Nekem tetszik mindegyik. Ha választani kell, akkor a legrövidebbet ajánlom. A ''meta (turnon (ctrl))'' nekem nem mond többet, mint a ''turnon (ctrl)'', ezt beletenni egy ''meta ()'' parancsba fölösleges bonyolításnak érzem. Még így is elég hosszú, vö. az Autoit és Autohotkey módszerével, ahol a metagombokat a ''+^!#'' karakterek jelölik, amelyik nincs kitéve, az értelemszerűen nem nyomandó meg, és például ''^c'' annyi mint Ctrl-C. Illetve pillanat. Ha már tokenizálunk, mi lenne a ''play "ctrl keyc"'' parancs eredménye?]
@thon[Sajnos TAP és SLIDE nem lesz. A rendszer nem engedélyezi, hogy egyik program hozzányúljon a másikhoz, márpedig ez abszolút hozzányúlás lenne, és mint ilyen - biztonsági rés. Saját program (pl. szövegszerkesztő), persze fogadhat ilyen parancsot, de akkor maga szimulálja le. Vagy - rootolt - készüléken hozzányúlhatunk a rendszerhez is. Jelenleg két kommunikációs lehetőségünk van: 1. string (küldhetünk stringet, elkérhetjük a kurzor előtt/mögött/kijelölt stringet (de nem biztos, hogy az egészet megkapjuk) és mozgathatjuk a kurzort (de nem kérdezhetjük le a helyét, csak számon tarthatjuk) 2. billentyűkód, amit praktice csak elküldeni lehet. Ezekkel a kommunikációs lehetőségekkel kell kombinálni. Magyarra fordítva: a billentyűzettől az editor kér adatokat, amiket aztán feldolgoz - DE - a billentyűzet nem nyomhat le az editor torkán olyasmit, amit az nem kér.]
@lad[Hát ha nem, nem, ez van.]

@s5[Szekciók ki/bekapcsolása]

@app[160426] Kimaradt a jelek közül: ';', ami a sor végéig átugorja a szöveget. Ezen a szövegen - szemben pl. a STOP utasítással - semmilyen ellenőrzést nem végez. Mivel nagyobb blokkok átugrására is szükség lehet ez kiegészül a kettős: ;( ... ); jelekkel. A köztes részen semmilyen ellenőrzés nem történik. Egymásba ágyazás viszont nem lehetséges, a következő ); leállítja a megjegyzést. A ); nem kötelező, tarthat a file végéig. Ilyenkor csak egy értesítést kapunk, hibaüzenetet nem.

@lad[Nagyon aranyos. Mondjuk ezt a kiosztást már nem fogom átszínezni, viszont kaphatna egy másik skint webes színekkel. Ez akkor lenne az igazi, ha a színeket definiálhatnánk egy-egy ''block''ban, és a settingsben be lehetne állítani, hogy „töltsd újra a coatot, de a megjelölt ''block''ok közül csak ezt meg ezt olvasd, amazt meg amazt hagyd ki”.]
@thon[Megpróbáltam, de nincs igazán használható ötletem erre. Ha berakod két () közé, akkor egy unexpected block hibaüzenettel átugorja.]
@lad[Csak hát az lenne a lényeg, hogy a szöveg átírása nélkül. Képzeljük el a következőt. Ne is parancs legyen, hanem olyasmi, mint a fordítási direktívák, például a php-ben a ''#include''. Legyen mondjuk ''section //név//'' és több sorral lejjebb ''endsection''. Nomármost. Ha van a kódban ilyen, akkor a bennük megadott összes //név// megjelenik egy listában a settingsben. Itt ki-be lehet őket kapcsolgatni. Amikor ezt megtettük, a program újraolvassa a kódot (draft), de a különböző sectionök közül a kikapcsoltakat egyszerűen kivágja még azelőtt, hogy a parser megkapná a szöveget. Még szebb, ha a section után állhat egy ''on'' vagy ''off'' is, ami az alapértelmezést jelzi. Javaslok egy ''exclusive'' paramétert is: ha egynél több ilyen section van, akkor bármelyik bekapcsolása egyidejűleg kikapcsolja a többit, így a több sectionben is deklarált változók nem ütköznek.]
@lad[Mindennek az lehet a következménye, hogy a settingsben egy-két kapcsolással másik színeket állíthatunk be, vagy akár egy teljesen új layoutrendszert vehetünk elő. De lényeges, hogy a parser mindig csonkított szöveget kap, amiből a kikapcsolt sectionök hiányoznak, a többiből pedig maguk a section és endsection sorok vannak eltávolítva.]
@thon[A coat nyelv csupán egyszerű leírónyelv, ha ilyen mértékő elemzést szeretnénk, akkor ki kell cserélni valami sokkal komolyabb gyári nyelvre. A másik probléma, hogy nehéz a settingsel összekapcsolni magát a leíró file-t. (Pl. mi történjék, ha hiányos a leíró-file?) Mindezek persze megoldhatóak, de ezt a kérdést tegyük el a távlati tervek közé. Addig a fenti módszer működik.]
@lad[Jó, eltehetjük, de csak azért ne vessük el, mert ha hiányos a file, akkor fejreáll. Enélkül is fejreáll, ha hiányos a file. Az összekapcsolást a settingsszel nem értem, hát ott van benne egy bejegyzés, hogy melyik file az aktuális.]

----

@s7[Régi szövegek archívuma]

@s5[Rivális]

Né csak: [[https://play.google.com/store/apps/details?id=it.keybeeproject.keybee|Keybee!]]
Amint látom, négy beépített kiosztása van, nincsen spacetravel, és ha hozzáteszi az å meg ä betűt, az egy fejlesztés. No meg a színek, a layoutváltások… Fényévekkel járunk a jóember előtt.
Írtam róla [[:blog:keybee|cikket]] is.
@thon[Nem vagyok egy irígy típus. Nem kellene megosztani vele, hogy mi mire jutottunk? Egy közös fejlesztés nagyságrendekkel többet tud előrehaladni, mint két külön. Persze lehet, hogy ő ebből akar tengerparti villát építeni, akkor nyilván tárgytalan a dolog. De a valóság mégis ez: mi hobbifejlesztők vagyunk, ha jobbak is, mint mások :)]
@lad[Szabadalmaztatta. Mindenesetre elküldtem neki is a linket még tegnap, jött válasz is:]
//
Hello.
Thank you for your message and for your comparison. Of course Keybee  
is currently a prototype, a lot of features should be added to perform  
a better typing experience. Keep the keyboard as simple as possible is  
the goal of Keybee. Good luck with your keyboard project.

Marco.//
@lad[Szóval udvarias, de nem túl érdeklődő. Én azt mondom, maradjunk mi csak meg magunkban egyelőre, részint azért is, mert minden írott anyagunk magyarul van; amikor eljön az ideje, publikáljuk a programot, és bízzuk Marcóra, hogy érdekli-e. Most már tud róla, tudja, hogy hol talál minket.]
@thon[Jól van, látom, egy srófra jár az agyunk. Mármint Veled. Ha nem, hát nem, nem erőszak. Ilyet nem fog csinálni, nem éri meg. Túl összetett ahhoz, hogy elég nagyszámú érdeklődő legyen. Szabadalmaztatni szerencsére csak elég konkrét dolgot lehet, pl. kiosztást. De szerintem hatszögletű billentyűzetformát nem. Ha mégis, akkor lekerekítem a megjelenő billentyűket :) Megjegyzem, az egész ötletet az IBM rég szabadalmaztatta, ld. korábbi cikkek. Mi meg úgysem tudjuk megtenni - vagy legalábbis nekem túl bonyolultnak tűnik. De ha mégis szbadalom: Mónikában partnerre lelünk, csak én nem akarok benne lenni :)))]

@s5[Webview gyorstalpaló]

@thon[Nagyon kéne nekem egy olyan, hogy a legegyszerűbben hogyan tudok sima, cifrázásmentes textet html-ként megjeleníteni. Pl. 1. mitől lesz az új sor új sor, mert most összefolynak. 2. hogyan lehet minimális erőbefektetéssel egy részt kiemelni (mármint színnel/színekkel) Természetesen tag-eket pakolhatok bele, én rakom össze (futásidőben) a szöveget. Csak nem tudom mi az, ami mindenképp kell bele. Eleje/vége stb. Köszi!]
@lad[1. Én a ''<br>''-t szoktam használni, egyszerű és hatékony. 2. Html-ben sajnos nincs rövidebb a ''<font color=#RRGGBB>SZÖVEG</font>'' megoldásnál, de ennek működni kell.]
@thon[No, akkor van html megjelenítő. De még csiszolom egy kicsit.]

@s5[Alternatív számláló, elvetve]

@lad[Újabb ötlet. Ha három gombra rátesszük a következő három utasítást külön-külön:]
  * ''let (szamlalo 0)''
  * ''inc (szamlalo)''
  * ''…addtitle (show (szamlalo))''
@lad[amelyekből az ''inc'' feladata egy numerikus változó értékét növelni, a ''show'' pedig változó értékét is ki tudja írni – akkor megvalósítottuk a szöveghossz-számlálást, méghozzá rugalmasabban, mint ahogy bármilyen szövegszerkesztő tudja. Mert csinálhatunk egy számlálót, akit a szóköz és az Enter növel, az a szavakat számlálja; csinálhatunk egyet, akit a mondatvégi írásjelek növelnek, és van mondatszámlálónk; és így tovább.]
@lad[A dolog akkor komplett, ha a számlálók megállnak, ha máshol dolgozunk, illetve a korábban már megírt szöveg kérdéses értékeit fölveszik. Ezt viszont az ember tudja, nem a Best:]
  * @lad[''varsave (file "kissy" var szamlalo var masixamlalo)'' kimenti a kérdéses változókat egy ''kissy.var'' nevű file-ba, ami valahogy úgy néz ki, hogy ''szamlalo 33743 (enter) masixamlalo 230171''; ezeket egy másik gombon elhelyezett ''varload'' visszatölti]
  * @lad[''input (szamlalo)'' beolvassa a változó értékét, lehetőségektől függően egy olyan inputablakban, amilyeneket a settings is ad, vagy a szövegszerkesztőben a kurzor előtt beírt számot használva – és az már a felhasználó problémája, hogy hogyan jut a birtokába a számnak, amit be akar írni]
@lad[Mindennek a lényege, hogy a kérdéses változók rátehetők egy gombra feliratként, és mindig látjuk, hogy mennyit haladtunk. Én ezt nagyon hiányolom a Jotából a Notepad+`+-hoz képest, amit PC-n használok. Vagy még inkább a tejpWriterhez képest, ahol a szószámlálót is beállíthattam állandóan láthatóra.]
@thon[Ezt tegyük át a todos-ba. DE!]
Alapvetően ehhez szövegszerkesztőt kell írni, az android ugyanis nem támogatja, hogy mi tudjuk, hogy mit küldtünk el:
  * nem tudjuk, hogy Kissyt írsz, levelet, vagy banki pin-kódot;
  * nem tudjuk, hogy az editor honnan kap még forrást (pl. külső billentyűzet, paste stb.)
  * nem tudjuk, hogy az editor hogyan változtatja meg a beírt szöveget (pl. numerikus esetben csak a számokat veszi át)
  * és még saját magunkról sem tudjuk, hogy pl. a modify, vagy a delete már korábban beírt, vagy az éppen most beírt szöveget változtatja.
Emiatt az egész rendszer rendkívül pontatlan lesz;
Cserébe viszont rendkívül nehéz elkészíteni, és a kód ineffektív lesz. Ugyanis:
  * a fenti műveletek elkészíthetőek, de hogyan kötjük össze az egyes karakterekkel? 
  * vagy: minden egyes billentyűnek tárolnia, ellenőriznie kell egy matematikai műveletet, ha szükség van rá, ha nem.
Ezzel szemben a mostani módszer pofonegyszerű: az elküldés pillanatában növeli a számlálókat, nem minden egyes betűtípus szenved vele. És ez bővíthető is, hiszen mellétehetünk egy statisztikai modult, ami betűnként leválogatja, hogy pontosan mi is szerepelt a string-ben, meg mennyi.
Van még egy nagyon fontos ellenérv: az egyszerű felhasználó szívbajt kap, ha a billentyűzet BÁRMIT rögzít. Ugyan ebben az esetben ez extremitás, de nem is lehetetlen. Pl. beírom a kódomat: 1111. És a statisztika csak ezt a négy számot rögzíti. Ha ebben a pillanatban megnézik a gépem, akkor feltörték a kódomat. Nem realitásról, az elvről beszélek. Amúgy emiatt a fejlesztés egy bizonyos pontján a debug is erősen meg lesz csonkítva, tehát nem közli, hogy mit ütöttek le - semmilyen beállításnál.
@lad[Igazad van, kár vele vacakolni, leteszem majd az archívba.]

@s5[Syntax highlight]

@lad[Né csak: csináltam syntax highlightot a Vickybe a nyelvünkhöz.] [[kinesa44]]
@thon[Ez nekem nagyon-nagyon teszik. És a betűtípusa is sokkal olvashatóbb. Androidra nincs syntax highlight-ra képes editor? Mármint a miénkre persze.]
@lad[Jelenleg nyilván nincs, a kérdés az, hogy van-e syntax highlightos editor szabadon definiálható nyelvvel, mint PC-n a Notepad+`+.]
@thon[Igen, így értettem]
@lad[Némi keresgélés azt mondja, hogy nincs. Törpölök viszont olyanon, hogy hátha ezt a most csinált technológiát át lehetne vinni egy webes editorba, csak még nem értem a koncepcicót. Közben a számokról az rgb színezést levettem, mert Sweetie-n elcsúszott, és képtelen voltam meglelni a módját, hogy rendbehozzam.]

@s5[A Coat 1000 véglegesítése]

@lad[Kérés, avagy javaslat. El kellene dönteni – ez a Te feladatod –, hogy a Coat nyelv mely részei azok, amelyek már nem fognak változni, véglegesnek tekinthetők ebben a verzióban. Ha ezeket megjelölnéd a doksiban, mondjuk „innentől idáig”, akkor én ezeket elkezdeném angolra fordítani, sajtó alá rendezni, miazmás. És ezzel is közelebb jutnánk a publikálható programhoz, mert doksi nélkül ez a program félkarú óriás, csak azt tudnák használni, amit megtalálnak a hozzá adandó coatokban.]
@lad[Javaslat, sőt kívánság még: fixáljuk a program pontos nevét, ebből képezzünk egy aldomaint a szerveren, és legyen a settingsben egy parancs, akit megnyomva az a webcím a bönginek átadatik, és ha már zörgettünk, megnyittatik. Ott lesz a dokumentáció, amit a tervezőknek el kell tudni érni a lehető legkönnyebben, androidos gépről is, a cím megjegyzése nélkül.]e
@lad[Erről jut eszömbe, hogy a) a ''PROGRAM'' utasítást kiegészíteni, b) egy új utasítást (mondjuk ''OPEN'') fölvenni lenne célszerű, aki megnyit egy dokumentumot azzal a programmal, amelyikkel a rendszer azt megnyitni szándékozik, és az lehet webcím, email, file neve, akármi, átadja a rendszernek, hogy nyissa meg.]
@thon[A coat végleges. Vagyis: az egyes funkciókon már nem tervezek változtatni. (Talán a selectall kivétel, abban az értelemben, hogy kellene select word stb. is; és akkor lehetne akár egységes is a nevezékten. De ez minimális.) Amin változtatni lehet: és ez viszont legalább közös feladat, hogy az egyes coat parancsszavak változzanak-e. Pl. a TURNON mindenképp listát fog kérni zárójelben, és a zárójelben lévőket bekapcsolja. De ettől ezt még átnevezhetjük FORCEON-ra BEKAPCSOL-ra vagy bármire - csinálni ugyanazt fogja. Azt kellene megtegyed (én már megtettem), hogy mennyire kézreállóak, logikusak, konzisztensek azok a szavak, amiket most használunk. Volt már ilyen csere: SPACES-ből SPACE lett. Szóval valószínűleg apróságok, de jobb, ha most döntünk. Ha minden egyes szót mérlegre tettél, akkor kész vagyunk.]
@lad[Rá fogok mozdulni, ráteszem az összeset a mérlegre.]
@thon[A program "rövid" neve: bestboard, pontosabban org.lattilad.bestboard. Ennek alapján a bestboard aldomain megnyitható. Ugyanakkor a javaslatom, hogy a textuális (helpben, megjelenésben stb.) használt név legyen a korábban elfogadott Best's Board, amit kiegészíthetünk egy dőlt beta felirattal, mert nahát. Utoljára ezekben maradtunk, vagy legalábbis a program ezeket a neveket tartalmazza. Én egyébként röviden kitérnék a helpben a Best családra, vagyis inkább a Kissy-re, mégpedig nem csak azért, mert innen van a név, hanem mert jelentős rész ezen íródott. (Sőt, az elvet tekintve az egész, ha jól tudom.) A board/keyboard választáson gondolkoztam el, de a Board szerintem jobb.]
@lad[Jó. Persze, akár ki is térhetünk rá, legalább tudja a felhasználó, hogy nem azért Best, mert ez a legjobb (ez a legjobb, de nem azért). Mondjuk meg azt is, hogy a könyvbeli Best család a program szerzőjének családjáról lett mintázva?]
@thon[Erre csak gondolatban válaszoltam, bocs. Egyébként nem látom akadályát. Amúgy nem titok éppen, csak feleslegesnek tartom nagydobra verni. Mármint a konkrét nevet; mert szerintem a történet viszont szép, és nyugodtan szerepelhet. Megtiszteltetés egy könyvben szerepelni. Egyébként (végre!) Matyi is úgy elkezdett olvasni, hogy éjjel ki kellett vennem a kezéből... Vadonjáró tanítványa sorozat, ajánlom figyelmedbe. Van benne olyan szereplő, aki a Te történeteidbe is beleillene. A fordítás amúgy katasztrófa. Ja, a kezdő löketet az Uránia adta. :)) ]
@lad[Utánanézek. A megtiszteltetés kölcsönös, az is, hogy szerepeltethettelek Benneteket, elnézést a mekegésért, meg hogy az én könyvem vette rá Matyit, hogy komolyabban olvasson. Ez a legklasszabb, csak ezért már érdemes volt megírni a könyvet.]

@thon[Html-t az android alapból meg tud jelenteni, (ld. Webview), úgyhogy a help-et bele (is) tesszük, nekem sincs mindig netem, amikor használom a gépet. De a neten csak legyen meg a legutolsó változat.]
@lad[Jó gondolat. Amúgy is azt terveztem, hogy az új helpet egyetlen Vicky-oldalként írom meg, abból akár egy az egyben ki lehet másolni a html-be renderelt változatot és kész.]
@thon[Jöhet. Többlapos lesz? Bár kezeli az ugrásokat.]
@lad[Nem tudom, pillanatnyilag egylaposra gondoltam, sok-sok oldalon belüli ugrással.]
@lad[Mégiscsak jobb lesz a többlapos, hosszú is ez egylaposnak, meg technikailag is bonyolultabb lenne.]
@thon[Semmi akadálya. Tettem már rá back és forth billentyűt.]

@thon[''OPEN'' gyakorlatilag már van, csakhogy. Az androidon INTENT van, vagyis azt mondod meg, hogy mit szándékozol tenni. Nem programokat kell megnevezni, hanem szándékokat. Kukkants bele ide: http://developer.android.com/reference/android/content/Intent.html Még nem jöttem rá, hogy ezt miként érdemes leprogramozni. Néhány gyakoribb intentnek készítünk parancsot, vagy csinálunk valami olyat, ami mindent visz. Ez utóbbira hajlanék, de ez olyan komplex része a rendszernek, aminek még magam sem ismerem minden csínját és bínját. És rögvest egy nehézség: Mi CSAK akkor tudunk programot indítani, ha szerkesztőmezőben vagyunk. Pl. megnyitottam a RealCalc nevű programot, és többet nem tudtam visszajutni a billentyűzetemhez, mert ő a sajátját használja. (persze a BACK visszavitt) De nagyon zavaró volt a hatás. Úgyhogy ötlet van, de kivitelezve még nincs.]
@lad[Értem – nagyjából. Én úgy gondoltam, hogy ''open "kutykurutty.txt"'', aztán a rendszer majd eldönti, hogy azt mivel kell megnyitni; Windowson ez működött, sőt ma is működik. De kétségtelen, hogy ha az emberi testet az Android rendszer tervezői alkották volna, akkor minden műtéted első órája arról szólna, hogy az összes érintett szervhez kellene egy vágási intent, egy szike activity, és ezekhez handlerek meg permissionök, az utolsó órája pedig arról, hogy nem varrhatsz csak úgy fonallal, mert a rendszer nem engedi, előbb a fonalat regisztrálni kell a gerincvelőben…]
@thon[Van ebben igazság, meg az androidban is logika. Itt ugyanis a felhasználó választja ki, hogy mit akar csinálni. Pontosabban a telepített programok közül melyikkel akarja csinálni. A telepített programoknak meg kell mondani, hogy mivel tudnak dolgozni. A baj az, hogy egyre inkább úgy érzem, a billentyűzet nem erre való. De majd küldök példát, aztán meglátjuk.]

@s5[Színek]

@app[160425]
@thon[Benne vannak az előre definiált színek. Numerikus konstansként szerepelnek, 0n... prefix után. CSS3 teljes névvel ill. visibone is, mert e kettő között nincs átfedés.]
@thon[Ami kérdés: kell-e ide kis/nagybetű megkülönböztetés, mert lehet. (Bár én kivettem, mert a többi részben sincs.)]
@lad[Nincs különbség, az összes színnév case-insensitive.]
@thon[A másik kérdés: azok a szép színek, amiket az eredeti kinesában megadtál most minek felelnek meg? Mert nem találom ezeket a numerikus értékeket.]
@lad[Leginkább csak saját hexakódjaiknak, én nem ebből a listából vettem a színeimet – majd ezután!]
@thon[Ja, a késlekedés oka nem a parittya, hanem a színeknek nem volt transzparencia komponense; ezért egyik se látszott. Hát, volt egy idő, amíg rájöttem mi a hiba.]

@thon[Ne tegyünk bele előredefiniált színeket?] 
Pl. https://hu.wikipedia.org/wiki/HTML-sz%C3%ADnk%C3%B3dok Vagy hát ebben inkább Te vagy a szakértő, csak ugyanúgy, mint a key-kódokat, ezeket is berakhatjuk. 
@lad[Nem lenne rossz, de akkor szabványosakat, amiket a tervezők már ismerhetnek. Pont a linkelted oldalon van a legjobb szabvány, a CSS 3, ezt tudom ajánlani, de a Visibone is jó, bár kevésbé elterjedt – de a kettő nem zárja ki egymást, mindkettőt tartalmazhatja, és akkor ''color fuchsia'' vagy ''color m'' ugyanazt jelenti.]
@thon[CSS3-ra gondoltam; de mindkettő jó. Van esetleg olyan, hogy név/érték párban amiből át tudom alakítani? Nem tudom, kell-e elé valami jelző (szerintem nem), de azzal együtt 12 karakterünk van egy névre.]
@lad[A Visibone-t én szeretném, mert sokat használom. Már össze is állítottam a listát, akár megcsinálnám egyből abban a formátumban, amiben a programban kell, ha megmondod, hogy legyen; ha php lenne, tudnám, ''"név"=>"szín",'' de itt nem tudom. Az is kell, hogy legyen-e # vagy akármilyen jel a színkódok előtt. Viszont bizony van benne hosszabb is, például mediumspringgreen az tizenhét karakter. Rövidítsük?]
@thon[Sajnos, a rövidítés mindenképp kell, 12 a max. De visibone-ban nem ilyen hárombetűs kódok vannak?]
@lad[De, 1-2-3 betű mind. De a CSS azért ismertebb. Nem gond, majd lerövidítem.]
@thon[Egyébként gondolom van sok azonos névrész, ami könnyen rövidíthető pl.: Medium helyett M. No. Kell egy lista a nevekről, ami bemegy a tokenizáló részbe (ezért van), és az rögtön kiadja a token-log-ban, úgy ahogy nekünk kell, vagyis a lenti command.javaban a Hard-key mnemonics. Ezek csak a nevek. Most mindegyikhez hozzá kell rendelni a számértéket, úgy, ahogy a Hard-key labels-ben van. Nem nehéz, de a legjobb, ha simán két excel oszlopban (vagy bármiben, amiben két oszlop van) odaadod. Egyik oszlop név, másik a szám. A szám lehet decimális, vagy hexa, ha hexa akkor 0x a prefix. De ez nem kell, mert hozzá tudom tenni, meg a #-t is tudom törölni. A legnagyobb baj, hogy a színeket nem tudom összeszedni, hogy mit tegyünk bele.]
@lad[Jó. Most egy tab van a két oszlop között, ha megfelel.]
@thon[Tökéletes. Az a kérdés, hogy az 1-2-3 betűs rövidítések elé tegyünk-e valamit? Pl. "VISI" vagy ilyesmi? Nem biztos, hogy jó ötlet a teljes 1-3 betűs részt erre feláldozni. Vagy: ha logikus a felépítése, akkor betehetnénk inkább a tokenizer-be. Az azt jelenti, hogy nem felismeri a szöveges kódot, és után kikeres hozzá egy cimkét, hanem pl. ugyanúgy, ahogy a színkódokat a 0c vezeti be, ezeket bevezethetné pl. a 0v - és akkor a 0v... kódokat azonnal a megfelelő színek numerikus értékére alakítja. Ezek a kódok mindenhol állhatnak, ahol a program numerikus értéket fogad.]
@lad[Nem tudom, hogy mi számít logikusnak, de a 0v tetszik. Tessék két lista.]
@thon[SÜRGŐS KÉRDÉS! Az jutott eszembe, hogy mind a két listát betehetnénk ugyanígy, és akkor nincs hossz-megkötés sem, mert nem keyword-ot írunk, hanem tulajdonképp egy számot, amit egy speciális kód jelöl. DE! a visibone-ra jó a 0v, de a CSS3-ra? A 0c-t meg nem használhatjuk, (feltéve, hogy ugyanazt használjuk hexa kódra, mert összekeverhető. MI LEGYEN A PREFIX akkor? 0c_ 0v 0_ 0s 0cs?? A lényeg: 0-val kéne kezdődnie, merthogy szám, a következő karakter meg - elvileg - a szám típusát adja meg. Ebből az értelemből a 0s is logikus, merthogy string. Vagy 0t merthogy text Vagy 0m mint mnemonic. Vagy lehet aláhúzás, hogy ne olvadjon egybe. Vagy mi legyen?]
@lad[Esetleg 0n, //named color.// De akkor ne ezt a listát használd, adok olyat, amiben a CSS-nevek nincsenek lerövidítve.]
@thon[Amíg megírom, az is elkészül :) most épp a parittya fizikai együtthatóit számoljuk Annával. És nem is érti, hogy ez parittya,,, hüjjeség, amit oktatnak.]
@lad[Olvasson Kissyt, ott van benne a parittya. Fizikai együtthatója az üvöltés, amit a shindy kiad.]

++++CSS 3, rövidítetlenül|
aliceblue	#f0f8ff
antiquewhite	#faebd7
aqua	#00ffff
aquamarine	#7fffd4
azure	#f0ffff
beige	#f5f5dc
bisque	#ffe4c4
black	#000000
blanchedalmond	#ffebcd
blue	#0000ff
blueviolet	#8a2be2
brown	#a52a2a
burlywood	#deb887
cadetblue	#5f9ea0
chartreuse	#7fff00
chocolate	#d2691e
coral	#ff7f50
cornflowerblue	#6495ed
cornsilk	#fff8dc
crimson	#dc143c
cyan	#00ffff
darkblue	#00008b
darkcyan	#008b8b
darkgoldenrod	#b8860b
darkgray	#a9a9a9
darkgrey	#a9a9a9
darkgreen	#006400
darkkhaki	#bdb76b
darkmagenta	#8b008b
darkolivegreen	#556b2f
darkorange	#ff8c00
darkorchid	#9932cc
darkred	#8b0000
darksalmon	#e9967a
darkseagreen	#8fbc8f
darkslateblue	#483d8b
darkslategray	#2f4f4f
darkslategrey	#2f4f4f
darkturquoise	#00ced1
darkviolet	#9400d3
deeppink	#ff1493
deepskyblue	#00bfff
dimgray	#696969
dimgrey	#696969
dodgerblue	#1e90ff
firebrick	#b22222
floralwhite	#fffaf0
forestgreen	#228b22
fuchsia	#ff00ff
gainsboro	#dcdcdc
ghostwhite	#f8f8ff
gold	#ffd700
goldenrod	#daa520
gray	#808080
grey	#808080
green	#008000
greenyellow	#adff2f
honeydew	#f0fff0
hotpink	#ff69b4
indianred	#cd5c5c
indigo	#4b0082
ivory	#fffff0
khaki	#f0e68c
lavender	#e6e6fa
lavenderblush	#fff0f5
lawngreen	#7cfc00
lemonchiffon	#fffacd
lightblue	#add8e6
lightcoral	#f08080
lightcyan	#e0ffff
lightgoldenrodyellow	#fafad2
lightgray	#d3d3d3
lightgrey	#d3d3d3
lightgreen	#90ee90
lightpink	#ffb6c1
lightsalmon	#ffa07a
lightseagreen	#20b2aa
lightskyblue	#87cefa
lightslategray	#778899
lightslategrey	#778899
lightsteelblue	#b0c4de
lightyellow	#ffffe0
lime	#00ff00
limegreen	#32cd32
linen	#faf0e6
magenta	#ff00ff
maroon	#800000
mediumaquamarine	#66cdaa
mediumblue	#0000cd
mediumorchid	#ba55d3
mediumpurple	#9370db
mediumseagreen	#3cb371
mediumslateblue	#7b68ee
mediumspringgreen	#00fa9a
mediumturquoise	#48d1cc
mediumvioletred	#c71585
midnightblue	#191970
mintcream	#f5fffa
mistyrose	#ffe4e1
moccasin	#ffe4b5
navajowhite	#ffdead
navy	#000080
oldlace	#fdf5e6
olive	#808000
olivedrab	#6b8e23
orange	#ffa500
orangered	#ff4500
orchid	#da70d6
palegoldenrod	#eee8aa
palegreen	#98fb98
paleturquoise	#afeeee
palevioletred	#db7093
papayawhip	#ffefd5
peachpuff	#ffdab9
peru	#cd853f
pink	#ffc0cb
plum	#dda0dd
powderblue	#b0e0e6
purple	#800080
rebeccapurple	#663399
red	#ff0000
rosybrown	#bc8f8f
royalblue	#4169e1
saddlebrown	#8b4513
salmon	#fa8072
sandybrown	#f4a460
seagreen	#2e8b57
seashell	#fff5ee
sienna	#a0522d
silver	#c0c0c0
skyblue	#87ceeb
slateblue	#6a5acd
slategray	#708090
slategrey	#708090
snow	#fffafa
springgreen	#00ff7f
steelblue	#4682b4
tan	#d2b48c
teal	#008080
thistle	#d8bfd8
tomato	#ff6347
turquoise	#40e0d0
violet	#ee82ee
wheat	#f5deb3
white	#ffffff
whitesmoke	#f5f5f5
yellow	#ffff00
yellowgreen	#9acd32
++++

++++CSS 3, rövidítve|
maroon	0x800000
darkred	0x8b0000
firebrick	0xb22222
red	0xff0000
salmon	0xfa8072
tomato	0xff6347
coral	0xff7f50
orangered	0xff4500
chocolate	0xd2691e
sandybrown	0xf4a460
darkorange	0xff8c00
orange	0xffa500
darkgoldrod	0xb8860b
goldenrod	0xdaa520
gold	0xffd700
olive	0x808000
yellow	0xffff00
yellowgreen	0x9acd32
greenyellow	0xadff2f
chartreuse	0x7fff00
lawngreen	0x7cfc00
green	0x008000
lime	0x00ff00
limegreen	0x32cd32
springgreen	0x00ff7f
mspringgreen	0x00fa9a
turquoise	0x40e0d0
lseagreen	0x20b2aa
mturquoise	0x48d1cc
teal	0x008080
darkcyan	0x008b8b
aqua	0x00ffff
cyan	0x00ffff
dturquoise	0x00ced1
deepskyblue	0x00bfff
dodgerblue	0x1e90ff
royalblue	0x4169e1
navy	0x000080
darkblue	0x00008b
mediumblue	0x0000cd
blue	0x0000ff
blueviolet	0x8a2be2
darkorchid	0x9932cc
darkviolet	0x9400d3
purple	0x800080
darkmagenta	0x8b008b
fuchsia	0xff00ff
magenta	0xff00ff
mvioletred	0xc71585
deeppink	0xff1493
hotpink	0xff69b4
crimson	0xdc143c
brown	0xa52a2a
indianred	0xcd5c5c
rosybrown	0xbc8f8f
lightcoral	0xf08080
snow	0xfffafa
mistyrose	0xffe4e1
darksalmon	0xe9967a
lightsalmon	0xffa07a
sienna	0xa0522d
seashell	0xfff5ee
saddlebrown	0x8b4513
peachpuff	0xffdab9
peru	0xcd853f
linen	0xfaf0e6
bisque	0xffe4c4
burlywood	0xdeb887
tan	0xd2b48c
antiquewhite	0xfaebd7
navajowhite	0xffdead
blandalmond	0xffebcd
papayawhip	0xffefd5
moccasin	0xffe4b5
wheat	0xf5deb3
oldlace	0xfdf5e6
floralwhite	0xfffaf0
cornsilk	0xfff8dc
khaki	0xf0e68c
lemonchiffon	0xfffacd
palegoldrod	0xeee8aa
darkkhaki	0xbdb76b
beige	0xf5f5dc
lgoldrodyel	0xfafad2
lightyellow	0xffffe0
ivory	0xfffff0
olivedrab	0x6b8e23
dolivegreen	0x556b2f
darkseagreen	0x8fbc8f
darkgreen	0x006400
forestgreen	0x228b22
lightgreen	0x90ee90
palegreen	0x98fb98
honeydew	0xf0fff0
seagreen	0x2e8b57
mseagreen	0x3cb371
mintcream	0xf5fffa
maquamarine	0x66cdaa
aquamarine	0x7fffd4
dslategray	0x2f4f4f
pturquoise	0xafeeee
lightcyan	0xe0ffff
azure	0xf0ffff
cadetblue	0x5f9ea0
powderblue	0xb0e0e6
lightblue	0xadd8e6
skyblue	0x87ceeb
lightskyblue	0x87cefa
steelblue	0x4682b4
aliceblue	0xf0f8ff
slategray	0x708090
lslategray	0x778899
lsteelblue	0xb0c4de
cornfloblue	0x6495ed
lavender	0xe6e6fa
ghostwhite	0xf8f8ff
midnightblue	0x191970
slateblue	0x6a5acd
dslateblue	0x483d8b
mslateblue	0x7b68ee
mediumpurple	0x9370db
indigo	0x4b0082
mediumorchid	0xba55d3
plum	0xdda0dd
violet	0xee82ee
thistle	0xd8bfd8
orchid	0xda70d6
lavenderbl	0xfff0f5
pvioletred	0xdb7093
pink	0xffc0cb
lightpink	0xffb6c1
black	0x000000
dimgray	0x696969
gray	0x808080
darkgray	0xa9a9a9
silver	0xc0c0c0
lightgrey	0xd3d3d3
gainsboro	0xdcdcdc
whitesmoke	0xf5f5f5
white	0xffffff
++++
++++Visibone|
aab	0x0066ff
aac	0x0099ff
b	0x0000ff
bba	0x0033ff
bbv	0x3300ff
c	0x00ffff
cca	0x00ccff
cct	0x00ffcc
dab	0x003399
dac	0x006699
dba	0x0033cc
dbv	0x3300cc
dca	0x0099cc
dct	0x00cc99
dda	0x336699
ddb	0x333399
ddc	0x339999
ddg	0x339933
ddm	0x993399
ddo	0x996633
ddp	0x993366
ddr	0x993333
dds	0x669933
ddt	0x339966
ddv	0x663399
ddy	0x999933
dfb	0x000099
dfc	0x009999
dfg	0x009900
dfm	0x990099
dfr	0x990000
dfy	0x999900
dg	0x666666
dgs	0x33cc00
dgt	0x00cc33
dha	0x0066cc
dhb	0x0000cc
dhc	0x00cccc
dhg	0x00cc00
dhm	0xcc00cc
dho	0xcc6600
dhp	0xcc0066
dhr	0xcc0000
dhs	0x66cc00
dht	0x00cc66
dhv	0x6600cc
dhy	0xcccc00
dmp	0xcc0099
dmv	0x9900cc
dor	0x993300
doy	0x996600
dpm	0x990066
dpr	0x990033
dro	0xcc3300
drp	0xcc0033
dsg	0x339900
dsy	0x669900
dtc	0x009966
dtg	0x009933
dvb	0x330099
dvm	0x660099
dwb	0x333366
dwc	0x336666
dwg	0x336633
dwm	0x663366
dwr	0x663333
dwy	0x666633
dyo	0xcc9900
dys	0x99cc00
g	0x00ff00
ggs	0x33ff00
ggt	0x00ff33
k	0x000000
lab	0x6699ff
lac	0x66ccff
lba	0x3366ff
lbv	0x6633ff
lca	0x33ccff
lct	0x33ffcc
lda	0x6699cc
ldb	0x6666cc
ldc	0x66cccc
ldg	0x66cc66
ldm	0xcc66cc
ldo	0xcc9966
ldp	0xcc6699
ldr	0xcc6666
lds	0x99cc66
ldt	0x66cc99
ldv	0x9966cc
ldy	0xcccc66
lfb	0x6666ff
lfc	0x66ffff
lfg	0x66ff66
lfm	0xff66ff
lfr	0xff6666
lfy	0xffff66
lg	0x999999
lgs	0x66ff33
lgt	0x33ff66
lha	0x3399ff
lhb	0x3333ff
lhc	0x33ffff
lhg	0x33ff33
lhm	0xff33ff
lho	0xff9933
lhp	0xff3399
lhr	0xff3333
lhs	0x99ff33
lht	0x33ff99
lhv	0x9933ff
lhy	0xffff33
lmp	0xff33cc
lmv	0xcc33ff
lor	0xff9966
loy	0xffcc66
lpm	0xff66cc
lpr	0xff6699
lro	0xff6633
lrp	0xff3366
lsg	0x99ff66
lsy	0xccff66
ltc	0x66ffcc
ltg	0x66ff99
lvb	0x9966ff
lvm	0xcc66ff
lwb	0x9999cc
lwc	0x99cccc
lwg	0x99cc99
lwm	0xcc99cc
lwr	0xcc9999
lwy	0xcccc99
lyo	0xffcc33
lys	0xccff33
m	0xff00ff
mab	0x3366cc
mac	0x3399cc
mfb	0x3333cc
mfc	0x33cccc
mfg	0x33cc33
mfm	0xcc33cc
mfr	0xcc3333
mfy	0xcccc33
mmp	0xff00cc
mmv	0xcc00ff
mor	0xcc6633
moy	0xcc9933
mpm	0xcc3399
mpr	0xcc3366
msg	0x66cc33
msy	0x99cc33
mtc	0x33cc99
mtg	0x33cc66
mvb	0x6633cc
mvm	0x9933cc
mwb	0x666699
mwc	0x669999
mwg	0x669966
mwm	0x996699
mwr	0x996666
mwy	0x999966
oda	0x003366
odb	0x000066
odc	0x006666
odg	0x006600
odm	0x660066
odo	0x663300
odp	0x660033
odr	0x660000
ods	0x336600
odt	0x006633
odv	0x330066
ody	0x666600
og	0x333333
oor	0xff6600
ooy	0xff9900
owb	0x000033
owc	0x003333
owg	0x003300
owm	0x330033
owr	0x330000
owy	0x333300
pda	0x99ccff
pdb	0x9999ff
pdc	0x99ffff
pdg	0x99ff99
pdm	0xff99ff
pdo	0xffcc99
pdp	0xff99cc
pdr	0xff9999
pds	0xccff99
pdt	0x99ffcc
pdv	0xcc99ff
pdy	0xffff99
pg	0xcccccc
ppm	0xff0099
ppr	0xff0066
pwb	0xccccff
pwc	0xccffff
pwg	0xccffcc
pwm	0xffccff
pwr	0xffcccc
pwy	0xffffcc
r	0xff0000
rro	0xff3300
rrp	0xff0033
ssg	0x66ff00
ssy	0x99ff00
ttc	0x00ff99
ttg	0x00ff66
vvb	0x6600ff
vvm	0x9900ff
w	0xffffff
y	0xffff00
yyo	0xffcc00
yys	0xccff00
++++

@thon[Apropó: Itt: https://github.com/Palmodroid/BestBoard/blob/master/app/src/main/java/org/lattilad/bestboard/parser/Commands.java a Predefined labels alatt van egy csomó konstans (key-kód), amit már ismer. A TOKEN_-t természetesen nem kell beírni, csak a többit a használathoz. Bár erről régebben már tárgyaltunk, de ki emlékszik mindenre?]
@lad[Átvittem a doksiba, mert tényleg el fogjuk felejteni. Egyelőre betettem a végére.]

@s5[...meg a bővítések]

@app[160424] @thon[Szinte ott volt az orrom előtt, meg kellett csinálnom: FIELD packet. Megszámoltam: kevesebb, mint 20 programsor. Jó egy kicsit gondolkodni is kellett, ezzel együtt 25 perc. Vannak viszont fontos kérdések: kell-e ezt külön névvel illetni, vagy a TEXT kapja meg ezt a funkcionalitást? * helyett használhatunk kontroll-karaktert, pl. \c, mint cursor, akár az ennek megfelelő ascii 2-vel? (nem biztos, hogy 2, de space alatt valami) Ill. az unicode-ra beállított $-nál is kérdés, hogy megfelel-e (nem lehet \, mert akkor karaktert készít, ez meg stringet)]
@lad[Lassan, többszöri újraolvasással kezdem felfogni. ''FIELD "<kvak>*</kvak>"'' → kapok egy tagpárt, és közte lesz a kurzor. Mármost. Volt egy elvünk, hogy minél kevesebbféle karakterre legyen szükség ahhoz, hogy meg lehessen írni bármit coatul. A jelenlegi doksiban nem szerepel a jelkészlet, de ha minden igaz, akkor az angol ábécé kis- és/vagy nagybetűin, a számjegyeken és a szóközön kívül kellenek még a ''( ) " ' \ $ _ -'' jelek. Azt javaslom, hogy ezt a jelkészletet minél kevésbé bővítsük, főleg ne olyasmivel, ami csak egy-egy viszonylag ritka esetben kell, és a tervező, aki már félkész Best-gombozattal dolgozik, hirtelen emiatt ne tudjon dolgozni, mert azt a jelet még nem tette rá.]
@lad[Azt nem értem, hogy a ''\'' karaktert készít, ez meg stringet, azt tudtommal az idézőjel típusa dönti el, nagyon megtanultam, már százhetvenkétszer fordult elő, hogy nem működött a programom, mert ''`''' jelet tartalmazó szövegrészt másoltam le, beleírtam több karaktert egy helyett, de persze elfelejtettem kicserélni ''"''-re. A ''\c'' jel itt nem karaktert készítene, hanem a kurzor helyét jelölné. Az ASCII 2 az 3, merthogy a C az ábécé harmadik betűje, de azt végképp külön emiatt kellene fölrakni a billezetre, és sok szövegszerkesztő nem is kezelné helyesen. Javaslatom: ha nem ''\c'', akkor ''_'' vagy ''$'' jel, ezek már szerepelnek az alapjelkészletben.]
@lad[A szót csak akkor cseréljük TEXT-re, ha biztos, hogy a kérdéses jelet nem akarjuk csak simán kiíratni. Vagyis ha egyetlen karakter a jel, akkor nem lehet TEXT, hiszen úgy nem tudod kiíratni magát a jelet. A ''\c''-nek utánanéztem, a Unix Bash nyelvében szerepel, tehát nem lehetetlen, hogy valaki pont ezt akarná rádefiniálni egy gombra. Jobb, ha maradunk a FIELD-nél.]
@thon[Ez jogos.]
Nézzük: @lad[Ezt a szakaszt beemelem a doksiba.]@thon[Ok, bár az elején nagyjából benne van. Attól még ezzel bővíthető persze.]
  * 0-9 és A-Z-ig szükséges az azonosítókhoz (_-t ismeri, de végül nem használtuk)
  * A speciális karakterekhez kell egy control-jel, ez most a c és java alapján a '\'. A \c ilyen értelemben nem érdekes, mert az 'c'-t jelent. A '\c'-t '\\c'-ként kell leírni.
  * A szövegek azonosítására kell egy külön kezdő-záró jel, ami az idézőjel ". Az aposztrófot a rendszer ismeri, de megint csak elhagyhatjuk, mert igazából mindent stringre alakít át. (Kiv. a KEY, de ott meg mindennek van rendes neve.)
  * A \HHHH jel egyetlen karaktert ír le. Ez mindig egy karakterre fordítódik, a stringben is. A $HHHHHH viszont nem írható le egy karakterrel (két byteon), mert lehet négy byte-os is, mármint a rendszer által használt UTF kódolásban. A feldolgozás nagyságrendekkel egyszerűbb, ha egy külön jel van erre; bár lehetne 0u is a 0x és 0c mintájára (Csak azok meg számok, más más írásmóddal.) Mindenesetre ez elég ritkán kell, csak ha BMP feletti kódkészletet írunk le. (És még akkor is lehet két karakter kombójaként leírni.)
  * A '*'-t próbaként tettem be, én sem érzem jónak. Bármelyik \ kezdetű karakter lehet, mert azokat a rendszer külön értelmezi, speciális karakterek. Inkább az a kérdés, hogy milyen ascii kódra írja át, de szerintem a 03 ált. nem használt, vagy pont erre a célra használt. Vagy a 31 is.
  * A FIELD a felhasználó oldaláról biztonságos. Ha valamit FIELD-ként definiálunk, és nincs benne * (vagyis ezek szerint valami másik jel), akkor amúgy is text lesz.
  * Van még 3 fontos karakter: ( ) és + A két zárójelet nem cserélném, mert nem tudok helyette jobbat. A + viszont csak "+ kombinációban értelmes, ezt kicserélhetjük pl. "/-re vagy "$-ra vagy "_-ra, vagy igazából bármire, ami normálisan nem lehet az idézőjel után.
@lad[Javaslatom: ''_''. Ez már szerepel a jelkészletben, ha nem is követeljük meg, és legalább egy nyelvben, a Visual BASIC-ben pontosan ugyanezt jelenti.]
@thon[Szerencsére ezt nem túl bonyolult kicserélni, pont egy karaktert kell átírni :) Viszont a field-et egy kicsit takarékra teszem, vagyis ne használjuk (a program tudni fogja ettől...) Az "undo" ugyanis nem szereti, ha arrébb battyog a kurzor miközben ő aktív. Képzeld el: beírsz egy szöveget, kitörlöd, és vissza akarod vonni. A kurzor meg elmegy a nem létező végére... Szóval nem az igazi. Azt kellene megnéznem, hogy az plusz ellenőrzés mekkora terhet ró a programra.]
@thon[Egyébként a többi működik?]
@lad[Hál’ Neked, igen.]

@s5[...és a javítások]

@app[160423] Javított változat. Hibák:
- elírás miatt a meta állapotok mind a shift állapotot állították be. 
- showtitles nem volt képes karaktert, csak stringet fogadni (nem volt beírva az átalakító metódus, közvetlenül használta a beírt értéket)
És tud újat is: van PROGRAM billentyű is.
Nagyon fontos lenne az átfogó tesztelés, mert gigantikussá hízott a program, biztos vannak benne hibák; gondolom komolyabbak is, mint az eddigiek. Át kellene az elejéről nézzem szisztematikusan az egészet - hát ehhez egy picit hiányzik az időm. Egyébként a hibaüzeneteket továbbra is érdemes megnézni a billentyűzetkészítés után, általában kiderül, hogy hol volt a turpisság. Ha nem derül ki, akkor az üzeneteken is változtatnunk kell.
Viszont ami jó: a rengeteg bővítés mind-mind pár sor és max. fél óra munka egyenként, ezért ömlöttek ennyire.
@lad[Próbálnám tesztelni, csak én is időhiánnyal küzdök…]
@thon[Most már tényleg nem kerget a tatár. Én is szeretném kipróbálni végre (és nem csak írni), másrészt Matyinak megígértem, hogy befejezem a szótárprogramot. Annak egyébként része pl. a file-választó, úgyhogy nőhetnek együtt, meg a szöveg-bemutató rész is megvan hozzá. Én úgy számolom, hogy az kb. az ősz reális arra, hogy pl. a play-re feltegyük, de addig a haveroknak kéne próbálgatni (faceboo, androidos lap pl.)Ahhoz viszont leginkább egy kész coat kell majd... Meg a többi. Ezt egyébként befejezni nem lehet, csak abbahagyni; ráadásul az utolsó rész túlságosan is magával ragadott, még a felületes tesztelésre sem maradt idő.]

[[chat_archivum]] (már túl nagy volt ez az oldal, a webes editor panaszkodott rá)

@s7[Régi szövegek archívuma]

@s5[Most-már-tényleg-végleges változat]

@lad[No, fölraktam, átírtam a feltüntetett átírandókat. Jelenleg nincsen szóköz, Enter és switchboard gombom. Próbálom átírni a doksi alapján, de persze hogy nem értem. Mondjuk a switchnél az van írva, hogy BOARD(keyword). Betettem. ''button (switch board(cesky) lock color swcolor addtitle (text 'Č' xoffset 500))'' Nem működik.]
@lad[A copy, cut, paste gombokat átírtam ''key 'c' turnon(ctrl)''-ra, nem működnek, nagy C, V, X betűket írnak és a clipboardba is ezek kerülnek.]
@lad[Aj, és most vissza kell csinálni az összes változtatást, hogy visszatehessem az előző programváltozatot. Brühühü. Ezt nem szabad terjeszteni, amíg végleg le nem zárod a nyelvet, az emberek nagy fáradsággal megcsinálnak egy kiosztást, változtatsz valamit, nem működik többé, nem fognak nekiállni újratanulni és átírni, inkább kidobják a programot.]
@lad[Visszaállítani se tudom, márciusi programváltozat márciusi coattal nem működik, nincsen szóköz, Enter, switch.]

@lad[Második nekifutás. A 384 hibát lecsökkentettem 334-re, nem tudom, hogyan, látható változás nincsen, semmi sem működik.]
@lad[Beírtam egy szóközt ''text''tel, legalább szóközt írni tudok, csak nem spacetravel. Háromszázszor olvastam el a doksit, nem derült ki, hogy mire írtad át a parancs működését. Látszólag ugyanaz.]
@lad[Ha az Enterhez írom be, hogy key enter, akkor megjelenik a gombon, hogy N/A, de működni nem működik.]

  let (entertext '✔')
  showtitles (
  	entertitle (entertext)
  	gotitle (entertext)
  	searchtitle (entertext)
  	sendtitle (entertext)
  	nexttitle (entertext)
  	donetitle (entertext)
  	prevtitle (entertext)
  	nonetitle (entertext)
  	unknowntitle (entertext)
  )
@lad[Ez nem működik, egy halom hibaüzenet jön. Hibát kapok még a spacetravelre, a metacapsra, az tényleg nincs már a doksiban… kicseréltem arra, hogy meta(caps), de az is se jó neki. Hibát ad az enter, a modify, a case… mi az a case? ja, modify case, ahol a case a kisbetű-nagybetű átváltó modifynak az azonosítója. Aztán a többi modify is ad darabonként három hibát, és ez kezdődik elölről, ahogy a többi layoutra is betesszük a blokkot, remekül alkalmas arra, hogy az egekbe tornássza a hibaüzenetek számát és a kezdő tervező sikítva meneküljön.]
@lad[Én is föladom, visszakapcsoltam a BestBoard nevű változatra, legalább tudjak szöveget írni, amíg előkerülsz és megrendszabályozod a programodat.]

@thon[No, akkor küldjél coat-ot, aztán hadd lássuk. Hát persze, hogy lehetnek hibák, - attól még, hogy nálam nincsenek - ezért kellene tesztelni. Ritka kivételtől eltekintve letisztult, hogy miként kell ezt megírni, úgyhogy magában a szerkezetben már nem tervezek változtatást. Viszont magukat az elnevezéseket télleg el kellene döntsük.]

Tulképp csak hat típusú hiba volt benne:
entertitle stb. az entertext
meta stb. a button helyett áll; merthogy az egy button pl.: meta (caps addtitle() stb. ) többi ugyanígy:
switch ( board id )
modify ( roll id )
spacetravel ( )
forcecaps off helyett turonoff ( caps stb.) ill. turnon (capst stb.) ugyanígy
A burma_black hiányzott, ill. a felülírást engedélyezni kellene, hogy ne adjon hibaüzenetet. A maradványhibákat a programban kell keresni, de ezzel már működnie kell.
@coat[kinesa41mod.txt]
@lad[Hát nagyjából már működik, de az Enteren az jelenik meg, hogy CR, nem a beleírt felirat, és a copy-cut-paste gombok továbbra se.]
@thon[Cut/copy/Paste megoldva: elírtam és csak a shiftet változtatta; enteren dolgozom, utána küldöm.]
----

@lad[Most kicsit megint nem leszek hiperaktív, barátommal elvileg pénteken bemegyünk a városba, arra kell készülnöm, és kaptam egy munkát is. De hogy értendő, hogy végleges? Hisz rengeteg bővítés van még tervben.]
@thon[Semmi sürgetés, a város fontosabb. Viszont sok újdonság van benne, ami esetleg érdekelhet. Engem meg majd az érdekel, hogy műxik-e - ami persze majd csak a nyúzás során derül ki. Tegyük hozzá, hogy lassan kéne még ember, aki legalább kipróbálja, ha most még ez nehézkes is. A végleges úgy értendő, hogy a jelenlegi funkciókat már nem akarom bántani. Ha a COAT szintaxisban is egyetértünk, akkor azt sem - persze egy-egy szót megváltoztatni nem nehéz. A bővítés más tészta, látod, az alábbiak is egy fél óra alatt beépültek, és igencsak növelték a funkcionalitást (szerintem).]
@lad[Még nem töltöttem le, de a Coat 1000-et már átolvastam. Fantasztikus, le a kalappal, nem tudom, mikor csináltad, de megírtad a dokumentációt, adjunktus úr. Itt-ott majd kérni fogok némi megvilágosítást, hogy miképpen is van, esetleg példákat, aztán nincs más teendő, mint lefordítani angolra (de azt már tényleg én fogom csinálni, pár óra alatt megvan) és mehet a nagyvilág elé. Mintabillezetnek egyelőre ott a jelenlegi Kinesa, az emberek többsége nem magyar, ösztönözve lesznek, hogy tervezzenek maguknak.]

@app[160420] Elkészült a véglegesnek tekinthető változat - mármint végleges akkor lesz, ha le is teszteltük; most még sok apró, és akár komoly gondot is okozó hiba lehet benne.
A [[coat1000]] már ehhez a változathoz tartozó dokumentációt tartalmazza. Néhány módosítás szükséges csak a korábbi coat változatokban; azokat az elejére kiemeltem.
A leírás néhány ponton nagyon részletes, de legalább Neked értened kell, hogy mi miért történik. Ebből KÉT egyszerűsített leírás elkészítését már Rád bízom: szerintem egy nagyon egyszerű kell a felhasználóknak, és egy kicsit összetettebb a billentyűzetet készítőknek (akár egyben).
Másrészt nagyon hiányzik egy-két példabillentyűzet. Az eddigi tapasztalataim alapján leghasznosabb lenne egy nem teljesen kitöltött példány, ami már használható, de lehetőséget ad új billentyűk hozzáadására is.
A magam részéről igyekszem befejezni a két éve abbahagyott file-választót, és akkor az is meglesz hozzá
Enjoy!

@app[160421] És máris itt a bővítés! Két régi ötletünket valósítottam meg, egyenként kb. fél óra alatt - vagyis már elég jól előkészített a terep. CHANGECASE és MEMORY is kész. Persze, komoly ellenőrzés még szükséges. Legfontosabb apró módosítások: CAPITALIZE/CAPITALISE félreérthetősége miatt inkább CHANGECASE elnevezést adtam. Nem TOGGLE CASE, mert a toggle utasítást fenntartanám a kétértékű adatokra. A többi esetben (vagyis toggle turnon turnoff kivételével) az utasítás azonban egy egység, ezért a több szavasakat is egybe írtam.

@app[160422] Néhány apró hibajavítás. Két fontosabb: SWITCH (BOARD BACK) helyett SWITCH (BACK) és az utolsó ADDLAYOUT és BLOCK beállít egy alap layout értéket, amit a BLOCK használ, ha nincs más megadva (DEFAULT-ban sem!). Kicsit zavarossá teheti a nyelvet, úgyhogy jobb egyébként expliciten kiírni.
STOP: érdekes kérdés, mert a tokeneket ellenőrzi, és ezért adhat hibát. (Az ellenőrzés szükséges, mert elvileg folytathatná a végrehajtást, ha az adott blokk befejeződik. Nálunk csak a legalsó zárójelblokkban engedélyezett, ezért nem tapasztaljuk.) Végül nem módosítottam, mert azt jelenti, hogy utána bármit írhatunk, hanem azt, hogy megállítja a végrehajtást.
És van egy új billentyű, ami miatt az eddig LIST át lett keresztelve MULTI-ra (multiple rövidítése, de lehet h. szerencsétlen, mert keverhető a multi típusú billentyűkkel, amikhez semmi köze) Na, mindegy.
LIST: ez teljesen új ötlet, de tetszik. Praktikusan egy olyan billentyű, mint a MODIFY (egyetlen beépített változtatási sorral), de ha nem talál változtatni valót, akkor beírja a legelső értéket. Felhasználói szempontból ugyanaz, mint a MULTI (korábbi list), csak minden érték egy új leütés után jön elő. Mivel csak az elsődleges funkciót használja, hozzátettem a másodlagost is - de itt már annyiféle dolgot tud írni, ami zavaró. Szóval a másodlagos technikailag lehetséges, de nem biztos, hogy szükséges is. Amire büszke vagyok: ezt sem volt nagy falat elkészíteni. Tesztelést viszont alaposan igényel.
Még egy javítás: a string-tokenek eddig egy sorra voltak korlátozva. Most a " után közvetlenül írt + segítségével folytathatjuk a stringet egy új sorban: "String eleje"+   (új sor)    "és a vége". Fontos, hogy NE legyen szóköz a " és + között !!

@app[160423]Opsz, az előzőben van valami kavarás, néhány funkció a régiből került bele. Ez viszont jó. Sőt, van már ilyen is: run "package.Name". Ehhez a program csomagnevét kell tudni, amit pl. az ES File Manager App része is kiír (mert a rendszer nem). De egyszerűbb a netről bemásolni. Pl.: SINGLE ( RUN "jp.sblo.pandora.jota" )  SINGLE ( RUN "uk.co.nickfines.RealCalcPlus" )  SINGLE ( RUN "org.madore.android.unicodeMap" ).

@thon[A magam részéről most inkább a coat-tal bíbelődöm, semmint a fejlesztéssel, de azért jönnek szembe dolgok. Ami döntést igényel: a COAT parancsok nevét (pl. a multi jó példa) mérlegre kell tegyük. Vagyis: az én javaslatom megvan, de kritizáld meg alaposan. Ha lesz doksi, azt html-ben kell elkészíteni (mégis), mert akkor nagyjából 20 sor, és megjeleníthető. Az coat.log-ot is meg akarom jelentetni egyébként. Tudom, hogy legjobban a file-választót hiányolod, de az nem egyszerű kérdés.]

@s5[Kijelölés2]

CSAK TESZT!! @app[160411]

A benne lévő test.txt file 2. álló layoutján van egy érdekes teszt a kijelöléssel. (Inkább felmásolom a test.txt-t is) A SHIFT állítja be a kijelölést. Csak ezt nézd meg egy kicsit, hogy miként működik, mik a kifogások, stb. A COAT még nem így lesz, ahogy most van, úgyhogy azt nem kell elsajátítani, csak az ugrás/kijelölés kérdéskört alaposan, nagy szövegen is tesztelni. Nagyon nehéz megtudni az androidon valamit is a szövegről, úgyhogy kérdéses, hogy minden editorral jól működik-e, de jotával jónak tűnik. Azért nézegesd egy kicsit; már feltártam a fő vonalakat. Ha valami apróságot szó/para beállítást módosítani kell, az menni fog. Ja, és BMP-n kívülivel is működnie kéne. Szólj, ha hibát találsz! A hibákat nagyon nehéz reprodukálni (az idő is számít), úgyhogy próbáld meg már ott reprodukálni, és PONTOSAN felírni/megjegyezni, hogy miként jutottál a nem várt viselkedésre! Tudom, ez egy nehéz feladat, de ezzel nagyon nem birkózom egyedül. Én mennék még egy kicsit tovább a változtatásokban, csak közben tudnom kéne, hogy ez működik-é.

Kis segítség:
1st - kijelölés eleje mozog, 2nd - vége mozog, semmi - hagyományosan (az utolsóként kijelölt mozog) de csak azt tudom, amit ÉN jelöltem ki!
L - R egy-egy karakter beolvasással
WORD (W) egy-egy szó - 1st az elejére, 2nd a végére ugrik (ez lehet, hogy nem így a logikus, ahnem irány alapján
PARA (P) bekezdés elejére (CR után) végére (CR elé) ugrik, ill üres bekezdést átugorja. Lehet, hogy az üres karaktereket is át kéne ugorni?
BEGIN/END elejére/végére ugrik. Kijelölésben csak az első (begin) és hátsó (end) kurzort mozgatja. Ez vajon jó így?
Lesz:
SELECTALL
TOGGLECURSOR - ami vált az első és hátsó kurzor között a nem megadott kurzornál.

@lad[Az a baj ezekkel, hogy maga a tesztelés küzdelemmel jár. Nem jutok arra a layoutra, van egy Lay1 gomb, de az csak kiírja, hogy Lay1. Megnyitottam a test.txt-t, kerestem, hogy hol van az a rész, de közben sikerült össze is firkálnom azokkal a gombokkal, amik kiírják, hogy single meg double, úgyhogy most letöltöm PC-n és megkeresem.]
@lad[Aha. Szóval a szerveren külön meglevő test.txt ≠ a programban benne levő test.txt. Egy teljesen más képet kaptam.]
@thon[Hát az meg hogyan lehet? Ugyanazt töltöttem fel!?]
@lad[Nem tom…]
@lad[Mármost nekem a Shift csak egy gomb erejéig hatásos, bár ha minden egyes mozgógomb előtt megnyomom, akkor kétségkívül működik, kijelölget, az a vége mozog, amelyiknek kell stb. Ha így kell neki működni, akkor működik. Jotában és az itteni szerkesztőben mindenképpen.]
@thon[Ha kétszer megnyomod, akkor sötétkék lesz, és úgy marad. OFF - META - LOCK kört jár körbe.]
@lad[Ja persze. Bocsánat, hülye vagyok, órák óta kínlódok egy pofonegyszerű kis programocska debugolásával és már semmi agyam nem fungál.]
@lad[A programomat megcsináltam. Ezek után nincs erőm kideríteni, hogy mit szúrtam el, amikor a teszt után visszatöltöttem a szerverről a március 16-i változatot, installáltam, visszakapcsoltam az eddig használt kinesára, és bolhacirkusszal vannak írva a gombozaton az összes jelek. Öreg vagyok én már ehhöz.]
@thon[Azóta változtattunk az addtitle méretén. Csak épp ezek tesztváltozatok, egyik sem lett - még - végleges. Szerintem ez kell neked:]@app[160329]@thon[ De használhatod a legújabbat is, az csak többet tud (de az eredetieket mind tudnia kell.]
@lad[Ah, rebetli. Ez volt az.]
@thon[Nahát! Elcsodálkoztam, hogyan kezelik a kijelölést különböző programok, különösen a szójelölést. Pl. MS és Libre office is a szavak elején ugrál. Ezzel szemben a FF és Chrome is sokkal ügyesebben, balra az elejére, jobbra a végére ugrik. Ezt még soha nem vettem észre.]
@thon[És csak szerénytelenség nélkül: a mi algoritmusunk jobb! :) ]

@s5[Kijelölés kérdése]

@thon[Érdekes problémába futottam: hogyan kezeljük a kijelöléseket?]
@thon[Minden kijelölésnek KÉT végpontja van ugye; melyiket mozgassák a mozgató billentyűk?
Csináltam egy olyat, hogy a balra az elsőt mozgatja, a jobbra meg a hátsót, de ezzel az a baj, hogy csak szélesíteni lehet a kijelölést.]
@thon[Ebből jött az ötlet, hogy mindkét végre csinálok egy-egy joystickot, és akkor mindkét véget lehet mozgatni - ami nem hátrányos egy ilyen tableten. Csak hová rakunk ennyi gombot?]
@lad[Ez a kérdés nem kérdés, amíg mi döntjük el, hogy mely gombokra van szükségünk és hova tesszük őket. Rengeteg gombunk lehet… apropó, a doksiban, ha végre hozzájutok megint, a korlátokról is szól egy oldal, ott majd Neked kellene megmondanod, hogy mik azok.]
@thon[Szerintem mások ezt úgy csinálják, hogy az egyik értéket fixen tartják, míg a másikat mozgatják. Ennek az a hátulütője,  hogy ilyenkor ki kell választani az első fix pontot, és utána a másikat beállítani. Ez persze első ránézésre egyszerű, de a képernyőn - legalábbis nekem - nem olyan egyszerű beállítani: vagyis először durván ujjal kijelölöm, aztán csak precízebben kell beállítani a két végpontot.]
@lad[Igen, így csinálják. Hogy mennyire könnyű beállítani, sok mindentől függ, képernyőméret, betűméret, ujjméret; néha tényleg nem könnyű eltalálni.]
@thon[Kíváncsi vagyok a véleményedre.]
@lad[Szerintem ezt a kétjoystickos megoldást ki lehetne próbálni, érdekesen hangzik.]

@thon[Találtam még problémát: felülírásnál vagy kijelölésnél nem fog működni a visszavonás, vagyis a törölt részt nem vonja vissza,csak a beírást. Ez vajon mekkora gond?]
@lad[Hát egyfelől mindegy, mert akkor is így van, ha tetszik, ha nem. Másfelől tisztességes szövegszerkesztőben azért van egy undo funkció is.]
@thon[Ez csak részigazság! Az "undo" nálunk nem a hagyományos visszavonás, hanem a double, list stb. billentyűk visszavonják amit beírtak, hogy mást írjanak a helyére. Másrészt minden megoldható (csak nagyon körülményes), kérdés, hogy mennyire akarjuk ezt megoldani. Hozzácsaphatjuk a jövőbeni igényekhez.]
@lad[Rész, de igazság. Ha a visszavonás nem működése azt eredményezi, hogy egy F betűt nem tudunk többé visszanyerni, hanem újra be kell írni, akkor újra be fogjuk írni, nem kopik el a ceruza. (A múlt héten vettem hatot.) Ha egy fejezetet jelöltünk ki véletlenül, aztán lenyomtunk egy betűt és a visszavonás nem működése folytán a fejezet nem jön vissza, akkor ott az undo.]

@thon[Csak úgy helyzetjelzésnek: dolgozom a mozgás/kijelölés problematikán. Ez igazából még egyszer igényel minden egyes metódust, ami a beírással/törléssel/mozgással kapcsolatos. Amúgy tetszik az oldal új design-ja. Bár az android oldal eléggé bővül, csak nem közöljük:) Még. Felmerült bennem, hogy a két fotó helyett egy-egy rajzolt arckép nem illeszkedne-e jobban az arculatba? Ez nem javaslat, inkább ötlet; másrészt viszont, aki ismer és szeret, és úgy rajzol egy arcot, az kifejezőbb is lehet, mint egy fotó.]
@lad[Maradnék az igazi arcunknál, pusztán mert az az igazi. De nekem is van egy gondom nagyjából ugyanezzel a részével. A vesszőgombom így néz ki: ''erasespace before autospace after''. Ez remekül megy is. Viszont ha visszamegyek a szövegben és beírok egy pótlólagos mondatot, akkor a vesszők után nem mindig kapok szóközt. Nehéz megtalálni, hogy mitől függ; most azt találtam, hogy ha törlök egy mondatvégi pontot, vesszőt írok helyette, és folytatnám a mondatot, akkor nem lesz szóköz a vessző után, nyilván mert már volt egy a pont után, tehát az ''autospace'' nem csinált másikat; csakhogy a szóköz most a kurzor előtt vándorol, és a vessző után közvetlenül íródik a szöveg. Át kellene lépni azt a szóközt, amikor a vesszőt beírom, és úgy folytatni.]
@thon[''erasespace around autospace after'' - én így használom, akkor törli a szóközt, és újat ír. Ráadásul csak egyet enged. Most épp rohanok, bocs...]
@s5[Új struktúra]
@app[160331]
Ez ismét csak kipróbálandó verzió! Nem biztos, hogy ez lesz a végleges. A COAT fileban is változások szükségesek (ám nem sok). Doksit még nem változtattam:
ALTERNATE > BUTTON helyére megy, a paraméterek közül törölni kell
LIST > BUTTON  helyére megy, a paraméterek közül törölni kell
SPACETRAVEL > BUTTON  helyére megy, a paraméterek közül törölni kell
ENTER > BUTTON  helyére megy, a paraméterek közül törölni kell
SWITCH > SWITCH ( BOARD ... - vagyis BUTTON helyett SWITCH, a SWITCH helyett BOARD lesz
META... > META ( CAPS... - vagyis BUTTON helyett META, a METACAPS... részekből pedig a META törlődik
MODIFY > MODIFY ( ROLL ... - vagyis BUTTON helyett MODIFY, a MODIFY helyett ROLL lesz

A kód most sokkal strukturáltabb (lesz), ami a bővítésnél előny. Praktikusan egy gigantikus elágazás helyett most csupa közvetlen metódushívás van. Ennek ellenére a kód nem lett gyorsabb, amin csodálkozom. Valószínűleg a debug rész (mármint a coat üzenetek, amik háttértárra is íródnak) akkora benne, hogy érdemben nem változik a sebesség.

A coat még mindig nem egységes, néhol nem tetszik. Ennek ellenére ebben az irányban kellene mennünk, mert így logikusabb a felépítés.
Hátrány: többféle button típus van, de a default csak a sajátra vonatkozik.
Előny: viszont a label-ek már nem korlátozódnak a saját azonosítójukra, pl. mindegyik button típus fogadja a button labelt, ill. hasonlóan létezik packet label is közösen.
Tényleg nem tudom, mi a jobb, (hiszen ez filozófiai kérdés), de ez tűnik annak. A BUTTON-t megtartottam, SINGLE és DOUBLE típus helyett is használható.

Ja, doksi nélkül nehéz lesz! Szóval a BUTTON vált szét több típusra:
 BUTTON ( packet/FIRST (packet) SECOND (packet) REPEAT) - SINGLE, ha nincs second packet, DOUBLE, ha van
 SINGLE ( packet/FIRST (packet) REPEAT )
 DOUBLE ( packet/FIRST (packet) SECOND (packet) )
 ALTERNATE  ( packet/FIRST (packet) SECOND (packet) )
 LIST ( ADD (packet)... )
 SWITCH ( BOARD id LOCK )
 META ( CAPS / SHIFT / CTL / ALT  LOCK )
 SPACETRAVEL ( packet )
 ENTER (textpacket keypacket  REPEAT )
 MODIFY ( ROLL id REVERSE )
és persze az eddigi paraméterek: ADDTITLE, COLOR stb. maradtak.
@lad[Hadd ellenőrizzem, hogy megértettem-e, mielőtt hozzányúlok. Ehelyett: ''button (text 'ж' color vfb)'' az kell, hogy ''single (text 'ж' color vfb)'', eddig értem. Lehet mondjuk ''double (first (text 'ж' color vfb) second (text 'џ'))'', és akkor sima érintésre ж betűt kapok, körözésre џ-t. Ha ehelyett ''alternate'' áll, akkor ismételt böködésre a két betvet váltogati… ezt már a Coat-leírásból puskáztam… próbálom elképzelni, hogy ez mikor hasznos. Ha ''list'', akkor megadhatok huszonhét és fél betűt, de hogyan érem el őket?]
@thon[Tableten valószínűleg nincs nagy szükség ezekre, mert praktilusan akárhány billentyűd lehet. De egy telefon kis képernyőjén igen hasznosak. Alternate lehet minden nyitó-záró pár, és spóroltál egy billentyűt. Egy sms-ben úgyse használsz sok egymásba ágyazott zárójelet. A list ugyanolyan, mint a double, csak több tagból áll. Lehet pl. v-w-.www vagy c-cc-.com. Nagyon sokat nem érdemes sorba rakni, mert nehéz elérni, de három vagy négy jól használható: ONSTAY megadásával addig váltogatja, amíg tartod rajta az ujjad. Majd kipróbálom alternate móddal is, lehet, hogy az jobban követhető.
Az a helyzet, hogy ezeket a típusokat néhány sor megírni. Lehet, hogy soha nem lesz rájuk szükség, de ki is akartam próbálni, hogy miket lehet csinálni.]
@lad[De hisz akkor ezzel azt is meg lehet csinálni, amit a nyomógombos teflonok csinálnak SMS-írásnál, csak sokkal rugalmasabban, mert én döntöm el, hogy hány gombom legyen és micsináljanak. Módosítót is lehet vele spórolni, ami szintén jól jön kicsi képernyőn. Szerintem baba.]
@thon[Egy fontos kiegészítés: az összes többszörös billentyű csak akkor működik, ha az elsőként végrehajtott feladatot vissza tudja vonni. Ez praktikusan azt jelenti, hogy szöveget küldött el. Az utolsó elem (pl. double esetén) lehet bármi, de akkor azt már nem tudjuk visszavonni - vagyis nem kezdi újra a váltogatást.]
@lad[Persze megint késésben vagyok, egyhetes verzió és még nem próbáltam ki, csak hát ahhoz neki kell ülni átírni a kódot…]

@s5[Új addtitle elrendezés]

@thon[Kizárólag próbaváltozat! (Bár valószínűleg ugyanúgy működik, mint eddig.)]
@app[160328]
  * ADDTITLE változott a leírásnak megfelelően, ezt próbáld ki; hogy jó-e (jobb-e). Szerintem pontosabban lehet vele pozícionálni.
  * Most éppen kettőz a nagybetű helyett, ez majd választható lesz (egyszer majd)
  * A SPACETRAVEL ki tudja kapcsolni az auto-funkciókat, és ezt vissza is jelzi (internetes beírásnál hasznos). Lesz majd egy marker-billentyű ilyen feladatokra.

@thon[Első kérdés rögvest: lehet, hogy jobb, ha a descent nélkül helyez középre (pl. CAPS lesz középen). Ez minimális változtatás, de jobban néz ki. Azt persze biztosítani kell, hogy így is elférjen a keretben, de ez megoldott.]
Mellétöltöttem két hexagon file-t is, csak nem tudom, hogyan fogjuk idetenni, vagyis a coat1000-be.  Az svg inkscape segítségével szerkeszthető, a pdf ugyanazt tartalmazza.
@lad[Nem lehet gond, ugyanúgy belinkeljük, mint bármi mást. De a jobbfajta böngik az svg-t egyből mutatják képként, illetve kimenthető képként is.]
@app[160329]
Szerintem ez néz ki jobban, csak annyi a különbség, hogy vertikálisan nem az "Ly", hanem az "MMM" közepére teszi magát.

Még változik, úgyhogy ne éld bele magad nagyon mélyen, de azért próbálgasd! Szerintem sok coat módosítás nem kell, csak a SIZE értéket kb. megfelezni (1000->600 arányban). Véleményre kíváncsi vagyok, inkább a pdf alapján; de ki is próbálható.

@lad[Hát amikor föltettem az új (még a 28-ai) változatot, nagy lóbetűket kaptam, mert ugye a kódban kétezres méretek vannak; átállítgattam, szerintem most jó.]

@thon[Szerintem azért jobb, mint az előző, mert meg lehet jósolni, hogy pontosan hogyan férnek el a karakterek. De nézd majd meg, hogy jól pakolja-e ki őket, stb.]
@lad[Azt hiszem, igen. Kellett némi igazgatás, hogy jó helyre kerüljenek, és oda kerültek, ahova a pillanatnyi számok küldték őket.]

@thon[Prágában ünnepeltük a Húsvétot cseh és szlovák barátainkkal. Anna neki is látott csehül tanulni, rokon lelkek vagytok! :) ]
@lad[Promiň, milyen dolog ez mámeg, válaszolsz valamire, és rögtön beteszed az archívumba? Anna miből tanul?]
@thon[Igaz, csak úgy láttam, hogy egy teljesen új fejezet indult, és ezért felhoztam a címet. Anna egyébként leginkább élőszóból, simán elveszett a szlovákok és csehek gyűrűjében napokig. Még szerencse, hogy az állítása szerint nincs nyelvérzéke... Egyébként nem is bánnám, ha esetleg írnátok egymásnak; egy nyelvi specializáción (mármint ott tanul) örülnék, ha olyannak is hallaná a véleményét, aki a nyelvek szerelmese. Persze nem biztos, hogy 15 évesen pont erről fog beszélgetni...]
@lad[Részemről nincs akadálya, pendítsd meg neki. Egyébként én is élőszóból tanulok, annyi különbséggel, hogy az én élőszavaim filmre vannak véve, tehát sokszor lejátszhatók. Csak hát nagyon lassan megy… ha ő napokat töltött a szlovákok és csehek gyűrűjében, jó esély van, hogy már többet tud nálam.]


Hirtelen tipográfiai segítség kellene, hogy középre tudjam rakni a szöveget. A többire majd válaszolok folyamatban.
Font Size: 1000
Ascent: -927.7344 Descent: 244.14063
"Ly" -750 képpont baseline felett (ascentnek megfelelő mért érték), 219 képpont baseline alatt (descentnek megfelelő tényeges méret lemérésével) Magasság: 969 képpont.

Mi a nyavajában méri az ascent és descent értéket? Mert minden size értékre mást kapok, de az összeg nem adja ki sem a size-t, sem a képpontokban mért méretet.
Mellesleg a font size mértékegységét sem értem.
Azt hiszem, a tényleges mérést fogom használni (vagyis lemérek egy "Ly"-t baseline-tól fel és le, aztán size szerint arányítom), de mégiscsak szeretném tudni, miben van az ascent és descent?
@lad[Hűha… anno brekeke volt a Windowsnak valami virtuális mértékegysége, de én húsz éve foglalkoztam effélékkel… dip! Ez az, keress rá a Wikipédiában, hogy Device independent pixel, ez lesz az.]
@thon[DIP?? Azt ismerem, de akkor végképp nem értem, hogy mihez viszonyít. "on the Android operating system a device-independent pixel is equivalent to one physical pixel on a 160 dpi screen" Ugyanis az aránya sem egyezik meg a ténylegesen kapott értékkel... No, én használom a ténylegeset, ez meg maradjon a fontfejlesztők dolga...]

@lad[Máma egy koreai embörke megkérdezte az Omnigloton, hogyan lehessék Galaxy 4-esen politonikus görögül írni. Küldtem neki egy képet a politonikus görög billezetemről, mert hát hogy hiszen énneköm ilyen már van, érdekelte, elküldtem neki a jelenlegi programot és a jelenlegi Coatot, még vacillál, hogy merje-e használni, nem ez az érdekes. Hanem hogy mi abból indultunk ki, itt lejjebb a tennivalók listájában is az áll, hogy legyen egy könnyen használható board. Csakhogy az embörkék nem könnyen használható boardot akarnak, hanem X vagy Y nyelven írni. Felhasználóink tehát akkor lesznek, ha nemcsak működő (és dokumentált) programunk van, hanem az is kell hozzá, hogy legyenek használható billezetek olyan nyelvekhez, amiken jelenleg nem lehet Androidon írni, vagy nem kielégítően.]

@thon[Áldott Húsvétot kívánok! Egyébként megjöttem.]
@lad[Nektek is. Merre jártál? 🐰]


@thon[Mit jelent, hogy "merje-e"? Összedönteni csak nem fogja a gépét...]
@lad[Nem tudom, csak vacillált.]

@thon[Szóval: az eddigi tapasztalatom az, hogy ez a billentyűzet teljesen egyénileg testre szabható. Nem mintha ezt eddig nem tudtuk volna, de akár egy könyvhöz, vagy egy jegyzeteléshez is kialakítható egy-egy kiosztás. Ez ugyanakkor nagy munka. A könnyen használható board nem ezt fogja helyettesíteni, hanem ad egy olyan felületet, amivel az alapvető tudást kipróbálhatják, tesztelhetik, aztán bővíthetik az emberek. Ezt a billentyűzetet úgyis csak az használja, aki sokat használja, az meg csinálni fog hozzá felületet is magának. De valahol mégiscsak el kell indulni.]
@lad[Igen. Jelenleg a következő a helyzet: pár napja megkérdeztem, hogy mely nyelvekhez szerettek volna eddig andis billezet találni, de sikertelenül. Jöttek javaslatok: burmai, mandzsu, pinjin (mármint nem olyan, ahol pinjinnel leírod a szótagokat és megkapod a kínai írásjegyeket, olyan persze van, hanem amivel olyan szöveget tudsz írni, hogy „nǚzìhǎofǔrén”, mert hát ez is kell kínai nyelvvel foglalkozó embereknek), és az eszperantó kapcsán elkezdtünk az optimalizált kiosztásokról beszélgetni Shah Hasannal, aki a statisztikaprogramot írta két éve. Én pedig csináltam egy burmai kiosztást, ami eleve úgy készült, hogy egy komplett bráhmi csomag része lesz; rengeteg bráhmi írásrendszer van, legalább harminc, és szerkezetileg meglehetősen hasonlítanak, miközben külalakra teljesen mások. Még nemigen láttam olyan programot, ami három-négynél többet támogatott volna közülük, az is Windowsra készült, ezer évvel ezelőtt.]

@thon[Nem volt terméketlen az elműlt idő; van egy-két bővítés, ami hamarosan érkezik. Sajnos átalakítás is lesz (pici), de kitaláltam a hatszög geometriájához jobban alkalmazkodó számítást. Hamarosan küldöm. Amíg csak mi használjuk, és nincs végleges, addig nem fogom a coat értéket növelni - ha egyetértesz. Az 1.000 legyen az, amit véglegesen kidolgozunk, és használni kezdünk.]
@lad[Igen, teljesen egyetértek.]

@s5[Módosítások]

Javasolt a [[coat1000]] elolvasása, még ha módosulni fog is.
@lad[Ja igen, az félbemaradt, mert a nap már megint csak huszonnégy órából és egy éjszakából áll.]

Szóval végiggondolva a lehetőségeket, van egy komoly logikai hiba, ami miatt muszáj lesz változtatni.
Jelenleg a 'BUTTON' utasítás rengeteg különböző utasítás összefoglaló neve. Ez azért gond, mert így nem tudjuk ezeket a külön csoportokat külön-külön beállítani. Vagyis pl. a BUTTON ( SINGLE TEXT "TEXT" ) előtt defaultként beállíthatnánk a REPEAT értéket, mellyel azonban a BUTTON (DOUBLE TEXT "TEXT" SECOND ( TEXT "TEXT" )) nem tud mit csinálni. 
Ez messzire vezet, de a lényeg, hogy **minden olyan "csoportot" külön utasítással kell létrehozni, amelynek önálló paraméterei vannak.** Ez jelenleg elsősorban a BUTTON szétosztását jelenti alcsoportokra.
@lad[Jó, nincs ellene nyifogásom.]
Most egy kicsit eltűnök, de ezen még dolgozom és gondolkozom. Megpróbálom úgy megcsinálni, hogy a coat a lehető legkisebb behatással módosítható legyen.


@thon[Azon ötletelek, hogy SINGLE button mellett ugye lehet REPEAT, vagy ha nincs, akkor nagybetűsít. Most csináltam olyat, hogy TWINS, ami dupla betűt küld, és akkor kell CAPITALISE (vagy- IZE?), ami viszont nagybetűsít. Még nincs kidolgozva, de kellene az elv. Hova tegyem? Opciókba? De jobb lenne coat-ba, mert akkor a többit ehhez lehet szabni. De még jobb a SINGLE-be, mert akkor csinálnék pl. DEFAULT SINGLE ( TWINS )-t. De ezt meg nem lehet, mert nincs SINGLE csak BUTTON ( SINGLE ). Szóval töröm a fejem, de valószínű mégiscsak módosítani kell a szerkezeten egy kicsit.]
@lad[Pillanat, az én műveltségem még nem tart itt. Mi az a SINGLE?]
@thon[ Hát ez: BUTTON ( SINGLE TEXT "t" ), csak a SINGLE-t nem írjuk ki, mert anélkül is tudja.]
@lad[A hajszoltan vágtázó események pászmákban zuhogó förgetege valahol elhagyott engem. Micsinál ez a SINGLE? Mi van, ha nem SINGLE, hanem mondjuk MARRIED?]

@lad[Segítség, segítség. Elfogyott a cavintonom. Valamikor szó volt olyan gombokról, amik a clipboardot kezelik, copy-cut-paste funkcicókat valósítanak meg, és sehol nem találom, hogy ez már benne-e van-e a programban-e, és ha nem, hogy működik…]
@thon[Jelenleg egy SEND 'c' FORCECTRL ON oldja meg. Meg persze 'p',] @lad[(v)] @thon[ha paste. Én még két dolgot szeretnék: 1. olyan billentyűt, ami felveszi a kiválasztott szöveget, aztán azt írja (mint a memória a számológépen) 2. Egy olyan komplex billentyű, ami első leütésre SHIFT-ként műkődik, vagyis a nyilakkal ki tudok választani szöveget. Ekkor azonban COPY-ként működik, és a kijelölt szöveget kimásolja. Ha ez is megvan, akkor PASTE-re változik, és vissza tudom nyomni a szöveget. Jobban belegondolva, ez lehet ugyanaz a billentyű: 1. SHIFT - nyilak működnek. 2. COPY - kijelölt szöveg, vagy a szó, ha nincs kijelölés. 3. PASTE - tárolt szöveg. 4. (hosszú leütés, praktikusan bármikor) visszavisz az elejére. Na ilyen billentyű még nincs...]
@lad[Értelek. Még egy bővítés hozzá: amikor a szöveget kiválasztottuk, akkor hosszú nyomásra legyen CUT, mert az is kellhet. Most mindenesetre akkor FORCECTRL-lal csinálok majd gombokat, mert néha jól jönnének.]

@s5[FONTOS!]

Össze kell írnunk, milyen teendőink vannak:
  * (Bővítés marad folyamatban, de a fejlesztés most egy kicsit megpihen)
  * Hibajavítás - ehhez minden apró rendellenességet fel kell jegyezni!! Én már találtam egy-kettőt @lad[Én biza egyet se.]
  * ;;y:Könnyen használható (és szabad billentyűket is tartalmazó) bemutató board;; 
  *;;y:Doksi (ennek sok része van, legfontosabb lenne a coat szabálykönyv,;; meg a settings)
  * ;;y:Ikon;; 
  * Döntenünk kell a coat parancsai felől. Mármint: minden egyes parancs ill. paraméter konzekvens és jól érthető-e.
  * Döntenünk kell a title-számítás mértékei felől. Mi legyen az egység, minek az ezreléke legyen megadva stb.
  * Véleményem szerint első tesztként (ha fentiek körvonalazódtak) feltehetjük az itteni Android oldalra, ill. a FB csoportba. Akit nagyon érdekel, az megtalálja pl. 'hexagon keyboard' kereséssel.
@lad[A listában sárgával jelöltem, ami az én feladatom.]
@thon[A settings szerintem az enyém, legalább első lépésben. Viszont a döntésekben szükségem van a segítségedre, mert azok coat írás közben derülnek ki/merülnek fel.]
@lad[Jaj, még valami. Jó lenne kijavítani egynémely döcögményeket az angol szövegekben, amik a settingsben és a logban megjelennek. Ehhez legcélszerűbb lenne összegyűjteni őket. Ha viszont összegyűjtöd őket, mi van, ha azt is beletesszük, hogy külső file-ból vegye őket, vagyis változtatható legyen a nyelvük?]
@thon[No, ez eredetileg is így van. Erre lesz szükségünk: A fileokat ne töltsd vissza, csak küldd át. A log nem így van (csak a coat), de az nyilván kevésbé érdekes.]
  https://github.com/Palmodroid/BestBoard/tree/master/app/src/main/res/values
@lad[Jó, a döcögményeket majd kijavítom, de ami a fordítást illeti, nem én akarom itt és most lefordítani tizenhét idegen nyelvre. A program jellege és a 21. század előrehaladott állapota miatt a lehetőségét szeretném megteremteni, hogy mások lefordíthassák. Oké, külső file-ból veszi, ez a része megvan, de abból csak egy lehet a kész programban.]
@thon[Szerencsére ez android, akárhány nyelvet el tud kezelni. A könyvtárszerkezet azonosítja a nyelvet és a beállítások alapján választja ki. Szóval akárhány nyelv definiálható a fenti file-okból.]
:O

@s5[Méretek]

Csak úgy érdeklődésből megnéztem: 
   ( find ./ -name '*.java' -print0 | xargs -0 cat ) | wc -l
http://stackoverflow.com/questions/1358540/how-to-count-all-the-lines-of-code-in-a-directory-recursively

ColorBoard: 1344 sor
BestBoard (eddig használt változat): 7925 sor
Best's Board (új változat): 18805 sor (és növekszik...)
@lad[👍]

@s5[BUTTON azonosító]

@thon[Gondolkoztam a dolgon. Még ez a változat sincs letesztelve, kipróbálva; maradjunk ennél. Ez nem jelenti azt, hogy elvetném a másik - néhány szempontból jobb - megoldást; de a változtatás megint több mélyreható módosítást vonna magával - de ezek egyike sem érinti magát az írást, csak a tervezést. Ideális tervező-nyelvet pedig csak akkor fogunk tudni kialakítani, ha tényleg tervezünk is. Szóval én most az aktív használat, és nem a további átalakítás mellett lennék. (Egyébként - a mi jó hír - az új programszerkezet simán elbírná ezt a módosítást, tényleg filozófiai és nem technikai megközelítésről van szó.) Próbáljunk meg abba az irányba mozogni, hogy többen használják ezt a programot, aztán majd meglátjuk.]
@thon[Apró változtatás viszont lehetséges: most a feles zárójelek közötti szöveget - szándékosan - átlépi. Ehelyett végre is hajthatná, legfeljebb csinálunk egy rem( ... ) parancsot az eredeti kihagyás számára... Hm?]
@lad[Hm! Ha ez azt eredményezné, hogy egy kihagyott fél zárójel egy parancsot tesz működésképtelenné, nem pedig onnantól kezdve az egész programszöveget, akkor mindenképpen hasznos.]
@thon[Nem igazán. Mert ott folytatódik a zárójel belseje a végtelenségig. Azon viszont gondolkodtam, hogy a legalsó szinten lévő utasítások esetén ellenőrizhetnénk, hogy milyen szinten vagyunk. Ha ez nem legalsó, akkor elmaradt egy zárójel...]

@lad[Jómagam közben másik problémával küszködök. Csináltam egy Quong layoutot és kipróbáltam angol szöveggel… hát mit mondjak, nem vagyok megelégedve vele. Faragtam sebtiben egy angolt magam is, az se sokkal jobb. Most azon tűnődöm, hogy lehetne algoritmizélni nyelvi layoutok létrehozását, illetve hogy mi alapján dönthető el, hogy melyik layout jobb egy adott nyelvhez.]
@lad[Hát ha én nekilátok programozni, ott kő kövön nem marad. Elkezdtem egy programot, ami fog egy Coatot, kiemel belőle egy blokkot, a tartalmából fölépít egy hatszögrácsot, aztán végigmegy egy megadott szövegen és pontszámokat ad a szavaknak aszerint, hogy hányszor kell fölemelni a ceruzát, amíg a kérdéses hatszögrácson azt a szót leírjuk – és végül eszerint értékeli a kiosztást. Hogy én ezzel mit kínlódok, el nem tudod képzelni. Rengeteg korlátozás van benne, mármint előre feltételez mindenféléket, és ha nem úgy van, akkor fejreáll, és hogy a végeredményként kapott számok érnek-e valamit, fogalmam sincs.]
@thon[Izgalmasan hangzik, de ezt talán egyszerűbben is meg lehet oldani...]
@lad[Mégpedig? Bármilyen ötletet lelkesen fogadok.]
@thon[Én egyébként azt gondolom, hogy a leggyorsabb az ismert layout.]
@lad[Ez egy nagy igazság, uram, viszont ha egy gyors layoutot ismer meg az ember, az jobb, mint egy lassúval – azonfelül ennek a kutakodásomnak az a célja, hogy létre lehessen hozni jó layoutokat különféle nyelvekhez. Ha közzétesszük és jön egy svéd emberke, nem lát kész svéd layoutot, nem lát módot arra, hogy maga tervezzen magának jó svéd layoutot, és megy vissza qwertyre. Ami egyébként nekem olyan szinten ismert layout, hogy ha kézbe veszem a billezetet és oda se pillantva belebökök a közepébe, azt a billentyűt találom el, amelyiket kerestem – de érintőképernyőn a kinesa mégis gyorsabb nála. Csak először meg kellett tanulnom.]
@thon[Hogy ki hányat bír megismerni, az erősen egyénfüggő. (Én pl. egyet) Szóval én mégiscsak a leggyakoribb karakterkapcsolatokat gyűjteném ki valahogy; csak azt kellene eldönteni, mi kerül belülre és mi kívülre. Ez egy izgalmas algoritmus persze. De a Te programod, ha jól értem nem azt mondja meg, hogy mi az optimális elrendezés, hanem, hogy az adott elrendezés mennyire optimális.]
@lad[Pontosan. Egyrészt mert halvány lilám sincsen, hogy lehetne layouttervező algoritmust alkotni, másrészt mert nem tetszik a quong, írtam vele angolul és lassúnak bizonyult, csináltam sajátot, az is… szóval jó layoutokat szeretnék, és ennek egyik lépése, hogy valamiképpen értékeljük a meglevőket. Jó layout az, amelynél a lehető legkevesebbszer kell fölemelni a ceruzát. Az mindegy, hogy mennyi ideig keresgéled a betűket, amíg még nem szoktad meg – majd megszokod, ha egyébként gyors.]
@thon[Ötleteljünk! Először travelspace nélkül. Melyik a leggyakoribb karakter? Tegyük középre! Keressük ki a hat leggyakoribb mellette lévő karaktert! Tegyük köré, mégpedig úgy, hogy mindegyik a két leggyakoribb párja mellé kerüljön. És így tovább, az üres helyeken. Nem biztos, hogy a legjobb, de mégis ezen az úton indulnék el. A travelspace annyi különbséget tesz, hogy a 6 leggyakoribb, párban állóval kell kezdjük, mert a közepe ismert. Ja, és nem tudom, mennyire lehet automatizálni.]
@lad[Majdnem így tervezek layoutokat, annyi különbséggel, hogy a szóközt rakom a közepére. Ha emlékszel, két éve Shah Hasan írt egy remek betűgyakoriság-mérő programot, annak az eredményeit használom. Csináltam már cseh, finn, angol kiosztásokat. És egyik vacakabb lett, mint a másik.]
@thon[Meggyőztél. Akkor mégiscsak az eredeti ötlet a nyerő.]
@lad[Melyik eredeti? Ez az egyetlen módszer pillanatnyilag.]
@thon[Az eredeti és egyetlen]

@thon[Sebesség kérdése]
A kódot nem nagyon nehéz átalakítani, a coat-ot már inkább, így, ha változtatunk, akkor most változtassunk.
@lad[Részemről tényleg bárhogyan, az eddigiekhez is alkalmazkodtam, ha nyögve is, az ezutáni változásokhoz is fogok.]
Amikor egy paramétert beolvasunk, akkor annak a leírását mindenképp ki kell keresni. Mindegy, hogy flag vagy komplex, ez akkor is ugyanannyi idő. A különbség abból ered, hogy a paraméter (pl. double) tartalmazhat egy metódust, amit azonnal meghív. Ha ezzel szemben "közös" paraméter van (pl. button) akkor egy "közös" metódus van. Ez a metódus már ismeri a paramétereket egy nagy csoportban, de minden egyes flag-re át kell néznie az összes lehetséges paramétert (ez egy gigantikus if/else ág), hogy megtalálja, melyik típusra kell elkészíteni a gombot. Még nagyobb gond, hogy a "kihagyott" paraméterek ( pl. single) a sor végén állnak, vagyis akkor, ha semmi más nem igaz, akkor kerül kiválasztásra. Valószínű az időkülönbség nem nagy, (pl. kisebb, mint a debug ki/be kapcsolásakor), de nem is elhanyagolható rengeteg gombnál. Ráadásul a lista minden új típussal tovább nő, mint a másik megoldásban a lista nem változik, hiszen az új paraméter már tartalmazza, hogy melyik metódust kell meghívnia. 
Egyébként úgy jutott eszembe, hogy egy új gombot akartam csinálni (TIMESTAMP), ami viszont rögtön 4 új paraméter (STAMP TIME DATE FORMAT) bevezetését tette szükségessé, vagyis még négy alkalommal kell végignyálaznia az ÖSSZES megkapott paramétert, hogy ez vajon szerepel-e közte. A Másik módszerrel ez nem jelentene időnövekedést.

Csak egy gyors kérdés: nem akarom ugyan átírni megint az egészet, de rájöttem, hogy a BUTTON azonosító felesleges. Egyszerűbb lenne helyette az eddig paraméterként alkalmazott SINGLE, DOUBLE, ALTERNATE, SPACETRAVEL stb. használata. Vélemény?
@lad[Ellene szavazok, ha programszerkezet-technológiailag nem jelent gondot. Megvan annak az előnye, ha a gomb csinálására szolgáló parancsot //gomb//nak hívják, ránézésre látod, hogy hol van a programban, áttekinthetőbb. És ha a billentyűtervező program nincsen tele gombokkal, akkor miért hívják a nyelvet Kabátnak?]
@thon[Megnyugodtam. Bár valamivel gyorsabb lenne, nem ellenőrizne mindenre minden egyes buttont. A block meg lehetne buttons éppen. De így is maradhat technikailag.]
@lad[Ja, ha sebességnövekedés várható, akkor azért vegyük fontolóra. Lehet, sőt biztosan lesz nekünk még több száz gombunk per Coat. Lehet tudni, hogy szignifikáns-e a különbség?]

@thon[Szóval a filozófia a következő:]
Egy több alváltozatból álló elem megalkoztása két módon történhet:
  - definiáljuk a főváltozatot (BUTTON) és FLAG-ekkel módosítjuk alváltozataira. Ez a módszer lehet, hogy jobban olvasható; kicsit valószínűleg lassúbb.
@lad[Ha szignifikánsan lassúbb, akkor nem javasolom, mert sok kicsi sokra megy. Egy komplett Coat simán állhat tartalmazhat egy-kétezer gombot, értve itt csak a forráskódban szereplő BUTTON utasításokat; a jelenlegi kódom, most megszámoltam, 323 BUTTON-t tartalmaz, amik ugye a BLOCK-ok sokszori meghívásával még többszöröződnek. És még sehol se tartok, csak latin, cirill meg görög van benne, emellé minimum még vagy féltucat írásrendszert föl akarok venni.]
  - definiáljuk külön parancsokkal az alváltozatokat, amik - természetükből eredően - úgyis tudják, hogy melyik főváltozatnak a részei.

Most csak meg kell találni ezeket a részeket a nyelvben, és dönteni felőlük. Egy hibásat máris találtam, amit így javítunk: META CTRL ill. FORCE ( CTRL ON ), ahol META CTRL és ON mind flag-ek, és nem paraméterek (a flag ugyanis önálló parancs).

Probléma: ezért éreztem problémásnak a zárójelezést. Ugyanis a flag, mint önálló parancs NEM kerülhet zárójelbe. Emiatt a fenti példában NEM használható a META ( CTRL) CSAK a META CTRL; viszont: A FORCE ( CTRL ON) NEM írható FORCE CTRL ON-ként - vagyis a program ismerete nélkül nem lesz egybevágó az elgondolás. 

Ezen még törjük a fejünket mindannyian.


@s5[Billentyűk számozása]

@thon[Jól jöhet a tervezésnél. A settings legvégén, a debugban kapcsolható...]
@lad[Most bekapcsoltam, de nem látok semmi különbséget.]
@thon[Hát az hogy lehet? Nekem minden hexagon tetejére ír egy számot, hogy melyik oszlop.]
@lad[Semmi, nem kell törődeni vele, én lenni bamba, rossz helyre kattintani. Szép számok. Javaslat: még egy kapcsoló, ami két hely (mondjuk felső és alsó sarok) között választ, mert amikor a loftra kerülő karaktereket tervezi az ember, ezek a számok útban lenni, pedig akkor is hasznosak.]

@lad[Kinesa 36: görög és cirill is van rajta. Tess’ mondani, a logban a gomboknál a C:11/R:8/A:1 az mit jelent? Csak mert mindegyiknél ennyi. Számok változni sose is.]
@thon[Az nem a button, hanem a layout: 11 oszlop, 8 sor, és align == 1, már igazából nem kellene, ott maradt.]

@thon[Elfelejtettem a spedometer limitre válaszolni. Szóval leütöd az utolsó betűt, letámasztod a macskának a gépet, és elmész ebédelni a jó kis halastavas étterembe a cimborákkal (mondjuk április 8-án?) A gép meg csak számol, csak számol, csak számol... és a sebesség csak esik, esik és esik. Pedig nincs is senki a gépnél. Na ez a limit a bambulási idő. Ha rövidebb idő után ütsz le valamit azt beszámolja az átlagba; de ha több idő telik el, akkor kihagyja, mert feltételezi, hogy nem a billentyűt nem találod, hanem bambulsz.]
@lad[Kizárt dolog. Vanessa kitagad, ha a gépet egy macskának támasztom neki.]
@lad[Apropó sebességmérő, javaslom a c/m helyett a cpm rövidítést, mert ez az elterjedt. És akkor már bpm, bár ez nem szokásos.]
@lad[Mi van április 8-án?]
@thon[Esetleg elmehetünk egy BestBoard megszületését megünneplő ebédre... Ja, cpm, azt csak átírom.]
@lad[Megszületését, hah! jövő ilyenkor is dolgozni fogunk rajta, annyi ötletünk van. Hisz még sehol is a CJK-támogatás alias rövidítéskezelő, a háromszögekre osztható hatszögek, a gombcsoportot gyártó parancs, a… a… a… De önni kétségkívül kell, felőlem ünnepelhetjük a BestBoardot éppúgy, mint a nyári kisegérképző tábort, mi a tervület? Hozhatol gyerököt is.]

@lad[Írtam egy kis programot, ami kitermeli egy Coat file-ból az idézőjelbe tett szövegeket, karakterekre bontja őket és a karaktereket sorba rendezi. Így kiderült, hogy a jelenlegi állás szerint 1761-féle karaktert lehet elérni a billezeten. (Valójában kb. egytucatnyival kevesebbet, mert némelyik csak feliratban szerepel, leírni nem lehet.) Persze a repülő ékezetek miatt, azok adják a nagy részét; a módosítók nélkül valamivel háromszáz alatt. Igazából vagy hatvannal több, mert a nagybetűk nem szerepelnek idézőjelben, hiszen metával jönnek.]

@s5[EXTEND]

@lad[A következő, ami engem érdekölne, ez az EXTEND nevű jószág. Hogy működik ez? Azt látom, hogy milyen tulajdonságokat lehet vele megváltoztatni, de kiknek és hogyan?]

Az EXTEND egy új képesség, még csak felületesen került kipróbálásra. Hátterében az az ötlet áll, hogy ugye definiálhatunk pl. egy "kinesa" alap-elosztást. De lehet, hogy bizonyos kiosztásokon erre még rá kellene tenni egy-két feliratot, vagy éppen további funkciót adni a gomboknak. Nekem pl. három ritkán használt betű nem fér el a telefonra optimalizált kiosztáson; ezeket szívesen rátenném egy másik betű hátára, másodlagos funkcióként.

Az EXTEND több dolgot is képes változtatni. Ugyanazon a pozíción kell kiadni, ahol a BUTTON volt, ugyanúgy illeszkedik a BLOCK paraméterei közé. Igazából egy speciális BUTTON utasítás.

COLOR - a legegyszerűbb, a háttérszín módosul

ADDTITLE - szintén egyszerű, egy további feliratot ad a meglévőkhöz. Ha nem adunk TEXT-et, akkor a billentyű határozza meg a feliratot (na jó, a mai verziótól, de ez sem volt egy komoly változtatás.) Az eredeti feliratok NEM törölhetőek, vagy változtathatóak, kizárólag bővíthetőek.

És a legfontosabb: funkció bővítés. Ez eredetileg SINGLE billentyűkre készült, vagyis ahol csak egyetlen packet van megadva (ha a SINGLE és FIRST parancsokat el is hagyjuk.) A SINGLE billentyű tehát Már tartalmaz egy packetett, és ezt az elsődleges funkciót meg is fogja tartani. De kiegészíthetjük egy (DOUBLE) SECOND (packet) résszel, ahol DOUBLE nem kötelező, és akkor lesz másodlagos funkciója. Működik az ALTERNATE SECOND(packet) is, ilyenkor nem double, hanem alternate billentyű lesz. És átalakíthatjuk LIST billentyűvé is, ahol a lista első eleme az eredeit first packet lesz, azt folytathatjuk több ADD (packet) utasítással. Ez az utolsó adta az ötletet az alapvetően LIST típusú billentyűk bővítéséhez: ilyenkor a már meglévők mellett további elemek adhatóak hozzá. Eddig ennyit tud; pl. double-ből nem tud alternate-et vagy list-et csinálni; de ez nem is lényeges szerintem.

Fontos viszont, hogy mindig az alapértelmezett ONCIRCLE tulajdonság kerül beállításra, vagyis körözéssel váltható ki a másodlagos tulajdonság (Bármi is volt beállítva korábban). Ha ezt változtatni kell, akkor az ONSTAY teszi ezt meg. Ilyenkor úgy működik, mint a repeat, vagyis csak ott kell maradnunk. Persze nem gyorsul az ismétlődés.

Ez utóbbival kapcsolatban: a telefon méretű billentyűzet teljesen más igényeket támaszt. Nincs lehetőség ált. sem a húzásra, sem a kőrzésre, túl pontatlan. Viszont egy név könnyebben beírható, meg speciálisabb billentyűzet is készíthető, vagyis jó rá a BestBoard. De pl. fontosabb a rezgésvisszajelzés meg az időzítés, mint tableten.

@lad[Ezeket nagyjából értem, azt hiszem. A gyakorlati alkalmazás még nem tiszta. Teszem azt, van egy kinesablock nevű blokkom, aki jelenleg a Kinesa gombjait tartalmazza. Van egy másik, kinesasymbol nevű, aki a Symbol Shifttel elérhető layoutokon helyettesíti az előző blokkot, és speciális jeleket tartalmaz. Mármost jó lenne a kinesablockbeli gombokra rátenni loftként a kinesasymbolbeli jelentéseket. Mi a módja? Újradefiniálom a kinesablockot, de most EXTEND-del?]
  let (kinesablock
    block (
  		extend (addtitle (loft text '©'))
	dl	extend (addtitle (loft text '¡'))
		extend (addtitle (loft text '¿'))
	ur	extend (addtitle (loft text '®'))
  …
@lad[Ez lenne az? Mindjárt kipróbálom.]
@lad[Múkodik! Csak nem a régivel megegyező néven kellett definiálni, hanem egy új néven, aztán rátenni az új blokkot a régire. Tündéri.]

@lad[Kinesa 35! A felső sor ötféle, a középső rész háromféle tartalmat vehet föl, és az EXTEND jóvoltából a betűk mindkét alternatív jelentése föl van tüntetve. Persze még épp csak elkezdtük…]

@s5[16.03.15 változat]

@thon[Csak apróbb módosítások. Viszont szándékosan nincs benne program által definiált default érték. A lenti eszmefutattást - mivel egy változathoz tartozott sorba raktam, uj jelölésekre kéretik rákeresni és adott esetben fejet törni.]

@lad[Közben áthoztam a módosítókat is a korábbi kódból, szépen működik, de jajgat az IGNORESPACE miatt.]

@lad[Jelentem, javasolt sorod:]
  DEFAULT ( BLOCK ( LAYOUT egyik ))
@lad[nem megy, azt mondja, hogy @OPENSQ`block@CLOSESQ This command is not allowed as default complex!]
@lad[A másik változat:]
  LET ( kozos BLOCK ( LAYOUT egyik ))
@lad[nem ad hibát, csak gombokat se. Így szól ez a szövegrész:]
  let (ly block (layout basic))
  
  block (draftblock layout ly row 8 column 1)
  block (funcblock layout ly row 2 column 9)
  block (kinesablock layout ly row 5 column 7)
  block (uprow layout ly row 2 column 2)
  block (leftrow layout ly row 3 column 2)
  block (rightrow layout ly row 8 column 8)
  block (arrows layout ly row 8 column 4)
  block (digits layout ly row 1 column 1)
@lad[De erre biz üres képet kapok.]

@thon[Töltsd le még egyszer, de a 19 órás példányt! Mellesleg a 150315 törölhető meg a SCR file is, merta zokat csak elrontottam.]
//IGNORESPACE// - ezt még nem módosítottam és //remove// helyett csak //contain//-t nézett: vagyis ugyanúgy működött, de nem vette ki, ezért a végén úgy érezte, hogy megmaradt felesben. Most már jó, egy szó javítás volt. Pontosabban kettő, mert két helyen szerepel.

//DEFAULT BLOCK// nem volt engedélyezve, most már van. A többiben a 'layout' felesleges, mert így a 'ly' layoutot keresi.  'block (draftblock ly row 8 column 1)' kell, ahol ly-t ugyanúgy értékeli ki, mint draftblockot. A layout már szerelep a let-ben.

Érdemes tudni: A koncepció az volt, hogy minden paraméter tulajdonképpen egy mérték és mértékegység kombó (csak fordítva írva). Mintha azt mondanám 'cm 1' vagy 'liter 7' vagy 'szín piros'. A LET-en belül ilyen értékeket tárolunk el, majd teszünk bele a parancsba a label helyett.

@lad[Nagyon baba, és íme Kinesa 31: tíz layouttal egymástól függetlenül váltogatható a felső sor (bal oldali narancsszínű gomb) ötféle állapota, illetve a Symbol Shift (jobb oldali narancs) kétféle állapota. Valamikor majd megcsinálom azt is, amit korábban akartam, hogy a Symbol Shift a betűkre is jeleket adjon, mert jelenleg nincs sok értelme, hogy különválasztottam a Caps Shifttől.]

@thon[Klassz! Azt még nem is mondtam: óriási ötlet, hogy a háttér változik!]
@lad[Inkább csak amolyan debuggingnak szántam, de lehet, hogy meg is lehetne tartani, még nem tudom.]
@thon[Szerintem könnyebb látni, hogy melyik lapon vagy, nem kell csak a jelekre figyelni. Én megtartanám, különösen egy olyan elrendezésnél, ahol csak egy-két dolog változik.]
@lad[Aha, lehet, hogy jól jön majd.]

@s5[ÚJ PROGRAM 06.03.14]
@thon[Elkészült az új változat!]
👍
@lad[Akkor nekilátok Coat-programozni.]
Ez a változat 'használható', mert már tudja a dokumentált képességeket. Ugyanakkor 'fejlesztői', mert még nincs hozzá kész coat program.
A tulajdonságok még bővülhetnek, (vagy esetleg változhatnak is, ha a coat megírása közben jónak látjuk), ennek ellenére ezt, mint alapot, véglegesnek tekintem. Vagyis ettől a ponttól csak belepakolunk, kivenni már nem szeretnék semmit.
A csomag név utal kis virtuális otthonunkra: org.lattilad.bestboard
A program az új számozás szerinti coat 1.000-t (vagyis [[coat1000]]) ismeri.
Többszörös mélységben kezeli a billentyűzeteket.
Újraindításnál megvárja az sd megjelenését (korábban összeomlott).
Van benne sebességmérő (jelenleg a monitor csak ezt tudja), karakter/percben az elküldött unicode karaktereket ill. button/percben a leütött main (vagyis nem meta és switch) billentyűket jelzi ki. 
Tudja a rezgésvisszajelzést (alaphelyzetben nincs bekapcsolva), ami másodlagos funkcióknál hasznos lehet. (Bár, ugye, néhányan nem szeretik :) )
Valószínűleg a beállításokról is kellene írnom valami magyarázatot, nem mindenhol egyértelmű.
Szerintem semmi olyan nem hiányzik már, amit a korábbi változatok meg tudtak csinálni. Egyébként részletek a todos-ban.

Hiányosságok (mert persze azok is vannak szép számmal):
Még nem csináltuk meg az ikont, és persze, hogy nincs még útmutató, hisz még én se tudom, mire képes...
Nincs még file-lista, mert félkész a hozzá szolgáló program. Remélem kibírjuk.
Nem lenne nagy dolog, de még nincs meg az editormező típusának megfelelő beállítás sem.
Kéne ugye egy képméretellenőrző, de ha Te nem tudtad összedönteni, akkor más se lesz rá képes egy normál méretű adathalmazzal :)
Meg kellene egy int-preferences, de az meg van oldva "kézzel", és elég nagy munka.
Meg a modify nem módosult, de annak is csak a belső tárolása fog módosulni, ugyanígy használható lesz.
Szóval van még teendő (ld. ismét todos), de addig is élvezzük az új művet!

@s6[Első tesztelés, március 14.]

@lad[Múkodik! :D]
@lad[Eddig van egy ilyenem: ''addlayout (id cseh halfcolumns 20 rows 8 align odds forcecaps off asboard start)'', és erre rátettem egy blockot. Van továbbá ''default (addtitle (size 2000 yoffset 250))'', ugyanis amint a ''size 2000''-et odaírtam, a betűk fölmásztak a hatszögek felső részébe. Ez szándékos?]
@thon[Érdekes, nekem működik. Van egy olyan, hogy _bestboard/coat.log, azt feltétlen nézd végig error-ra vadászva - ill. ki is írja, hogy mi fáj neki. Nem szabad, hogy error legyen benne a végén, mert akkor furcsán is működhet. Még csak a rendes működést csináltam meg, a hibajavítást nem.]
@lad[Ezt teszem, nem volt hiba, amikor ezt írtam.]

nekem is stop most őrajta írok nincsenek írásjelek stop még enter sincsen stop ha törlöd a yoffsetet az addtitleből hol lesznek a feliratok kérdőjel stop
@thon[Először hagyd, hadd tegye ő ki az alapértelmezett title-t. Az addtitle nem változott, akkora a betűméret, hogy 5M és egymás felett 4 sor mindenképp elférjen. Default betű középre kerül, 1000-es méretben, vagyis nincs átméretezve. Az értékek ezrelékben vannak, vagyis a méret a fenti betű ezreléke, míg az eltolás a hatszögnek felel meg.]
@lad[Hát először hagytam, csak akkor pöttömkék voltak a feliratok.]

@lad[Más. Ha bekapcsolom a vibrációt (számértékek alapértelmezésen) és gyors mozdulattal leírom, hogy vlaku, ami csehül pont a vasút birtokos esete, akkor egy pillanatra fölhangosodik a vibráció, nem szép.]
@thon[Mi az, hogy felhangosodik? Igazából csak a rezgés hosszát lehet beállítani, külön minden típushoz. Szerintem a Te sebességednél kisebb érték kell, vagy csak a secondaryhoz kell érték.]
@lad[Nem tom. Majd ki fogok vele sérletezni.]

@lad[Még másabb. Ugye a BLOCK célja az, hogy ugyanazt a gombcsoportot több boardon is föl lehessen használni. De hogyan?]
Így: a lényeg, hogy a LET részben nem szabad LAYOUT/COLUMN/ROW információt megadni. Azt csak akkor kell, amikor ténylegesen elhelyezed a blockot egy BLOCK utasítással.
LET ( abc BLOCK (
BUTTON ( TEXT "a" )
BUTTON ( TEXT "b" )
BUTTON ( TEXT "c" ) ) )
BLOCK ( LAYOUT lay2 COLUMN 1 ROW 3 abc )
BLOCK ( LAYOUT lay3 COLUMN 2 ROW 4 abc )
BLOCK ( LAYOUT lay4 COLUMN 3 ROW 5 abc )
@lad[Jaj, értem. Nem a BLOCK-on belül kell neki azonosító, hanem őtet kell betenni egy értékadásba. Mutattad is már, csak hát szenilis vagyok.]

@lad[Ja igen. A monitor aranyos, csak kellene neki háttér- és betűszín-állítás, mert a gombok körüli rendes háttér inkább azért valami sötét, hogy ne vegye el a fényerőt a gomboktól, akkor viszont a fekete feliratok nemigen olvashatók. De láttam, hogy benne van a listában.]
@thon[A MONITOR utasítás már működik, de a hátteret nem akartam másra állítani, mint a layout színe. Abból úgyis csak egy kevés látszik lent meg fent.]

@thon[Feltámadt bennem a kétely. Azt nem tudom, hogy a sok labelen belül az addtitle (mint paraméter egy labelben) hogy fog működni. Mert a paramétereket előre kiértékeli... No, majd meglátjuk.]
@thon[Egyébként nem mondom, hogy könnyű, de azért nem lehetetlen ezt a régi coatot átalakítani...]
@lad[Inkább mégiscsak újraírom, pontosabban egyes szakaszokat másolok ugyan, de csak kisebbeket. Nem kell annak pont ugyanolyannak lennie, mint a korábbinak.]
@thon[No, ez érdekes, mégiscsak úgy működik, ahogy elképzeltem. Viszont egy fontos koncepcionális problémáról beszélnünk kell. Ez egy leírónyelv és nem programnyelv - vagyis nincs felkészítve arra, hogy útközben a konstansok megváltoznak. A gond a következő: ugyan van most label funkciónk, de a label-en belül az összes paraméter már kiértékelésre kerül. Ezt követően hiába változtatnád meg a labelben szereplő részértékeket (pontosabban azok további labeleit), annak már nem lesz hatása az eredet labelre. Ez nagyon fontos, mert a labelek úgy tárolódnak, ahogy létrehozásukkor voltak, és nem számolódnak újra a felhasználásukkor. Ezt fontos tudni, ha a LET mellett megengedjük az értékek változását. Amivel igazából továbbra sem értek egyet, mert nem illeszkedik a koncepcióba. Bár technikailag kétségtelenül hasznos lehet.]
@lad[A döntés mindig a Tied. Szerintem ami hasznos, az hasznos.]

@lad[Kicsit kipróbáltam a sebességmérőt. 210 karakter, ha Kissyt írok, és 276, ha leírom az Eszmélet első versszakát, amit ugye nem nekem kell kitalálni, ezért gyorsabb. A settingsben a speedometer limit mit jelent, hogy működik?]
@lad[Javaslok karakterszámlálót is. Nem úgy, hogy megkérdeznénk a szövegszerkesztőt, csak szimplán számolni a leírt karaktereket vagy gombnyomásokat, egytől kezdve, amíg nem nullázzuk a számlálót.]
@thon[Szóval a b/m az "leütött" billentyű per perc, a "c/m" meg az elküldött unicode karakter/perc - szóval mindkettőt tudja. A törlést nem számolja vissza, mert ahhoz mindent újra kellene számolni. Az össz-karaktert is számolja (mert különben honnan tudná az átlagot), csak azt nem tudom, hova lehetne írni. A monitor sorra nem akarok többet, legfeljebb ki lehetne cserélni. Vagy a settingsbe írjuk ki a részadatokat?]
@lad[Én nem érteni kérdés, hát a monitorsor végignyúl a képernyő teljes szélességén, és használunk belőle két centit. Miért ne lehetne ott a karakterszámláló is?]
@thon[Persze, bármi lehet, csak hány számlálót érdemes odatenni? Azt gondolom, hogy több lehetőség lesz, amik a beállításokban egy checkbox-szal ki-be kapcsolhatóak lesznek. Írjuk a többi közé!]
@lad[Szerintem akárhányat. Miért ne? Hely van. Számítási időben ez, gondolom, minimális. Akkor miért ne?]

@thon[Kellene egy DEFAULT ADDTITLE, amivel a program induljon. Azt is lehet, hogy a méretezést kompletten megváltoztatjuk. Mert így tényleg kicsi...]
@lad[Kicsi bizony.]
@thon[Ehhez akkor kellnek adatok, addig please kezdj minden coat-ot agy DEFAULT ADDTITLE-vel, ez fontos!]
@lad[Azzal kezdem, de hát egyelőre csak egy coatom van.]

@lad[No, összeomlasztottam. A következőt találtam ki. Van a szövegben ez:]
@thon[Ezt az összeomlást ténylegesen értetted, vagy csak nem működött? Mert a labelben hiényzott egy 'error = true' sor, így aztán keywordnál null-t próbál meg hozzáadni, ami valószínű nem megy. :) ]
@lad[Abszolúte szó szerint, lejjebb ki van fejtve, állandó //Unfortunately, Best’s Board has stopped// feliratok voltanak.]
  block (draftblock layout cseh column 1 row 8)
  block (funcblock layout cseh row 2 column 9)
  block (uprow layout cseh row 2 column 2)
  …
  block (draftblock layout symbol column 1 row 8)
  block (funcblock layout symbol row 2 column 9)
  block (shuprow layout symbol row 2 column 2)
@lad[Már nyolc-nyolc ilyen sorom van mindkét layouthoz. Ezek egy vagy két dologban különböznek: a layout nevében és egyes esetekben a block nevében. Hogy készül egy ilyen sor? Hát logikusan úgy, hogy az ember lemásolja a felső sort, beteszi alulra és átírja a layout nevét, meg a block nevét is, ha kell. De lehetne ezt egyszerűbben: ne kelljen átírni a layout nevét. Legyen az eltárolva egy változóban, aminek értéket adunk előbb a ''layout cseh'' sorok, aztán a ''layout symbol'' sorok előtt is:]
  let (ly cseh)
@lad[– és szépen össze is omlik a program. ERROR: @OPENSQ`cseh@CLOSESQ This command is not allowed as label complex! mondja, és részéről a fáklyásmenet, unfortunately stopped, valahányszor ki kellene nyitni a billezetet.]
@lad[Ez azért nyilván nem szép tüle, akkor se, ha én írtam hülyeséget. Hiszen így kellett volna, ugye?]
  let (ly let (cseh))
@lad[Különösebben meg se lepett, hogy így se jó. Ez ellen bármit a világon, de tenni kellene, mert ráadásul veszélyesen omlik össze, a rendszer kiabál, hogy ez a program itt egy héten belül tízszer összeomlott, és uninstallálni kellene. Egy héten értsd másfél percen belül tízszer, hiszen valahányszor valamit megnyomok, a Best értesítést kap, akkor is, ha nincs a képernyőn semmilyen billezet, és minden egyes alkalommal összeomlik.]
@thon[Javítva. Egy sor hiányzott.]

@lad[Mindenesetre hasznos lenne, ha egy változó értékét egyszerűen odaadhatnánk értékül egy másik változónak. Akkor nagyobb szövegblokkokat le lehetne másolni változatlanul, de a másolat valami másra vonatkozna, mert előzőleg megváltoztattuk a kérdéses változó értékét.]
@lad[No. Jót játszottam vele, de most már mék alud, nézd meg a kinesa28-as változatot a file-ok között. Két switchet is tartalmaz, kétoldalt sötétlila gombok, ezekkel négy layoutot váltogat.]

@thon[Az a baj, hogy a coat program igazából csak adatok feltöltésére való. Adat - és hogy hova kerül, ezt a két értéket tartalmazza. Egy kicsit persze megbolondítva, különösen a blocknál, hogy az egyforma adatokat csokorba lehessen szedni. No, ugyanezen oknál fogva a 'let' számomra konstans érték volt, nem is gondoltam arra, hogy meg kéne változtatni, mert pl. a black az mindig ugyanaz a fekete legyen. Emiatt nem volt értelme keyword-ot betenni a label-ek közé, ezért nem fogadja el a 'cseh' értéket - hiszen az keyword. De mi értelme lett volna egy keyword-ot átnevezni másik keywordra? No, nem baj, próbálgatás közben tanulunk, tehát ezt a funkciót is bele lehet tenni, írjuk fel a többi közé. Bár lehet, hogy ez nem lesz egyszerű, hiszen a keyword-ok közül meg van határozva, hogy mi engedélyezett egy parancsban és mi nem. Mert hisz az sem lehetetlen, hogy szeretnénk egy LET ( doboz BLOCK ) utasítást, hogy a BLOCK helyett később doboz-t írjunk - de ez nem megy; vagyis inkább egy kész és komplex nyelvi értelmezőt kellene használni, nem egy ilyen hobbi-programot. Mindegy, csak gondolkodom; írjuk a feladatok közé.]
@lad[Hát ha nem teszöl különbséget a nyelv kulcsszavai és a változónevek között, akkor persze vannak komplikációk. De én csak arra gondoltam, hogy egy változó értékét lehessen átmásolni egy másik változóba.]
@thon[Én arra gondoltam (eredetileg), hogy az utoljára megadott layout tárolásra kerülne, tehát vagy az ADDLAYOUT (ID layout ...) után vagy egy BLOCK (LAYOUT layout ) után minden további hívás a layoutra vonatkozna. Ezt lényegesen egyszerűbb megtenni, és ugyanazt a funkcionalitást adja. Hozzáteszem: jelenleg a coat még elég egyenes (vagyis körülményes) szabályokat követ - vagyis, képes mindent megjeleníteni, ami a szabályok szerint van leírva; de nem képes sem a hibás részek kiemelésére, sem az összetett vagy ismételt részek egyszerűsítésére.]

Hopili! Megvan! (Az oké, hogy a keyword nem szerepel a konstansok között, de megoldható.)
Szóval: Te egy BLOCK parancs LAYOUT paraméterét szeretnéd univerzálissá tenni. Ez labelezhető:
  LET ( kozos BLOCK ( LAYOUT egyik ))
Ettől a ponttól kezdve a BLOCK ( kozos ... ) már tartalmazza a 'LAYOUT egyik' paramétert.

Sőt!

Még jobb a default használta:
  DEFAULT ( BLOCK ( LAYOUT egyik ))
Ugyanis ettől kezdve minden egyes BOARD (...) úgy értelmeződik, hogy BOARD ( LAYOUT egyik ... )

És!

Mivel mindig az utolsó paraméter számít:
  DEFAULT ( BLOCK ( LAYOUT egyik ))
  BLOCK ( LAYOUT masik ...)
Itt ugye BLOCK ( LAYOUT egyik LAYOUT masik ... ) utasítást értelmezünk, de mivel a LAYOUT nem multiplex parancs, ezért az utolsóként megadott 'masik' értéket veszi fel. Persze egy következő BLOCK (...) parancs már megint a default értékkel kezdődik, vagyis a LAYOUT egyik-re szól.

Így szerintem megoldható és egyszerűsíthető. Tudom, hogy azt írtam, hogy a LAYOUT/COLUMN/ROW használata nem célszerű, de azért, mert akkor minden ugyanazzal a pozícióval kezdene. De a fenti módon mégiscsak hasznos lehet. 
@lad[Döbb. Szó bennszakad, lehellet megszegik. Furmányos egy szoftvert alkottál, főorvos úr.]

@thon[Kérdés:] 
A META értékek két helyen is szerepelnek: gombként META SHIFT/CTRL/ALT/CAPS és a kényszerített beállításokban: FORCESHIFT/FORCECTRL/FORCEFORCEALT/FORCECAPS ON/OFF. De ez így nem jó, és össze is keverhető az egybe meg különírás. Két ötletem van:
  - Marad a META SHIFT megoldás viszont a FORCE... rész módosul ALLOW SHIFT ill. DENY SHIFT utasításokra. Az kérdés, hogy ilyenkor ez legyen: ALLOW (SHIFT CTRL ALT) vagy ez: ALLOW SHIFT ALLLOW CTRL ALLOW CAPS. Az első esetben a zárójel akkor is kötelező, ha egy érték van: ALLOW (SHIFT)
  - Mivel az első eset a gombra, a második a statusra vonatkozik, a gombot ugyanígy egybeírjuk: METASHIFT, METACTRL, METAALT, METACAPS. És akkor a FORCESHIFT... parancsok maradhatnak ON/OFF paraméterrel. Vagy lehet SHIFTMETA és SHIFTSTATUS az írásmód, de az ugyanaz a módszer, csak máshogy írjuk.
Vélemény?
@lad[Nem nagyon. Még föl kell fognom. Ránézésre az ALLOW (SHIFT CTRL ALT) tetszik a legjobban.]
@thon[Időközben METACTRL és FORCECTRL ON/OFF-ra alakítottam. Így ugyanis a négy meta-functiót ténylegesen más azonosító jelöli. De lehet, hogy az ALLOW/DENY jobb lenne, csak a Te általad írt forma az ún. list, amiben kötelező a zárójel. Próbáljuk ki, aztán meglátjuk.]

@thon[Kérdés:] 
ERASESPACES helyett ERASESPACE, azt is keverem sokszor.
@lad[Rendicsek.]

@thon[Kérdés:] 
Mi legyen az X- és YOFFSETtel? HORIZONTAL és VERTICAL? HOFFSET és VOFFSET? Vagy maradjon?
@lad[Szerintem maradjon. Világos, egyértelmű, és mindenhol x-szel meg y-nal jelöljük a koordinátákat, a h-t és v-t nem is értené senki.]

@thon[Kérdés:] 
A 'KEY KEYDEL' írásmód sem tetszik. KEY... bevezetővel jelöltük a hardkeyeket IS és a key packet elnevezését IS. Milyen lenne a SIMULATE KEYDEL? Vagy HARD KEYDEL? Vagy SEND, ha már egyébént kivettük? Pl. SEND KEYDEL az elég egyértelmű. Vagy valami más?
@lad[SEND KEYDEL a voksom.]

@thon[Kérdés:] 
No és a zárójelezés is kezd elég össze-vissza lenni a számomra. Vagy érthető? De ezt nem igazán tudom kikerülni.
@lad[Nem tudom. Elég sokat zárójelezgetünk mindenféle programnyelvekben, általában ki szoktuk bírni. De van egy javaslatom: ha egyébféle (szögletes, kapcsos, akármilyen) zárójeleket is megengedsz a gömbölyűek mellett, akkor a tervező írhatja úgy a programját, hogy ezeket váltogassa. Nálunk a másféle zárójeleknek nincs hatása matematikai műveletekre és hasonlókra. A szerkesztéshez minimálisan elvárható jelkészletet ez nem növelné, mert nem lenne kötelező többféle zárójelet használni, csak megengedett.]
@thon[Fentiek ok. Zárójeleket meglátjuk, nincs akadálya a vegyes használatnak sem. A gond azonban a BUTTON alatt van, ahol sok a FLAG-gal jelölt paraméter. Néha nem logikus, hogy valami két FLAG, vagy egy egyparaméteres utasítás paraméterrel. Az első esetben tilos a zárójel, másodikban megengedett.]

A véglegesítés előtt ezek elég fontos kérdések; bár a választ csak néhány legyártott billentyűzet után fogjuk megkapni...

@lad[Megint kiesek pár napra, ugyanaz a bajom van, ami 2014-ben, csak szelídebb változatú; remélem, az is marad.]
@thon[Jobbulást! Gyógyulj meg mielőbb!]
@lad[Köszi. Még nem száz százalék, de alakulok.]

@thon[Elkészült a következő, már közel véglegesnek mondható változat. Még a FORCEMETA megoldás nem tetszik, de alapvetően már csak bővítésben és hibajavításban gondolkodom. Ha bólintasz, átkerülhet a használható helyre, mert - elvileg - mindent meg tud csinálni, amit az előző, sőt. Sajnos, nem volt erőm leírni a tudományát, de a test.txt szerintem nagyjából mutatja, amit tud. Erre szerintem érdemes már módosítani a végleges coat változatokat is.]
@lad[Nekem tetszik, csak annyira átvariáltad a kódot, hogy megint egy kukkot sem értek a szövegből… :'(]
@thon[Nem baj, kicsit összetettebb lett a program :) Viszont, ha egyszer megvan, akkor már minden sokkal egyszerűbb lesz! Írogasd ide a kérdéseket, akkor egyszerűbben tudok magyarázni. A lényeg egyébként a default és let utasítáokon lesz. ]
@lad[Örömmel. Első kérdés: hogy néz ki most a Coat nyelv leírása? 😈]
@thon[Hát így:] [[coat1000]] @thon[A formázásban lehet, hogy kérek segítséget. Meg talán a magyarról-magyarra fordításban is. De ilyen késői órán csak erre futotta... Ja, apró változások vannak a kódban; használd az újat!]

@thon[Íme, a folyamatbén lévő fejlesztések! Viszont még mindig nem a végleges, úgyhogy csak kipróbálásra (azaz a teszt megtekintésére, játszásra, esetleg kisebb módosításokra való)!]
@lad[Máris kipróbálom, de a nyelvet illetően már teljes bennem a zűrzavar. A] [[coat1000]] @lad[oldalon levő nyelvváltozatot eszi meg a mostani programváltozat, vagy az egy későbbre szóló terv?]
@thon[Erősen készül a végleges, vagy legalább véglegesen próbálható változat. Ez a változat egy részét már tudja, addig, amíg a szövegben jelöltem. De várd meg a véglegest, ezt csak nézd meg alaposan - mármint próbáld is ki, de ne akard a komplett billezetet átírni. Ha megvan a végleges, akkor még a nomenklaturán csiszolhatunk.]
@lad[Rendicsek. Mondjuk nem esök kétségbe, ha nem kell most átírnom a komplett billezet, elvállaltam egy-két időigényes feladat, azoknak szeretnék a végére járni.]

@lad[{02.26., 13:10} Jelentem, többé-kevésbé kihevertem a betegségeimet, és most nekilátok átírni a billezetet az új Coatba.]
@lad[Először húsz perc után akadtam el, de a mintafile segítségével sikerült kibogoznom, hogy bár a leírás ADDLAYOUT-ot kíván, ADDBOARD kell, és a BLOCK-ban erre kell hivatkozni…]
@lad[No, egyórás küzdelemmel lett hat gombom, de iszonyatosan elfáradtam. El nem tudom képzelni, hogy a nyolc-tíz boardot és több száz gombot tartalmazó rendszeremet mikor leszek képes átírni, amikor nem is értek belőle egy szót se.]
@thon[Üdv ismét a fedélzeten, Kapitány! Nincs még kész, igencsak elakadtam az egymásba ágyazott visszalépések kérdésén (is). Emellett elvileg strukturáltabb megoldást kínál, úgyhogy érdemes lesz venni a fáradtságot. Javarészt azért copy/paste meg find/replace segítségével átalakítható...]
@thon[És ami még fontos: a fejlesztői változat egy kicsit le van maradva: ahogy a kóddal előrébb jutottam, úgy bővítettem a leírást. Viszont az utolsó verziók nem működőképesek, ezért a leírás még nem kipróbálható. A fenti változat tesztelhető, de élesben még nem bevethető. A tesztelés pont ezt jelenti: hat gomb, és hogyan működnek.]

@lad[Né csak, nem szembejött velem három könyv megint…]
@thon[Ma lett FINDFREE is, de még nincs feltöltve :) Most nincs időm letölteni, de eszembe jutott: nem lehetne e kettőt (könyv/bestboard file-ok) különválasztani? Akár a privat-ba, bár azt alig használjuk.]
@lad[Dehogynem.]
@thon[ÉS még egy: próbáld ki légy szíves, de google chrome alatt a vicky szerkesztő használhatatlan lassúsággal megy. Amúgy van firefox, de itt forszírozzák a krómot, mert jobban együttműködik mindennel (pl. orvosi program) Ami egyébként gáz, mert a helyes fogalmazás: Ez a kalap szerencsétlenség nem hajlandó semmi mással működni. No, én elvagyok FF-szal, csak a hibajelenségre hívom fel a figyelmet. ]
@lad[Nincs mit kipróbálnom rajta, nekem ugyanolyan jó, mint volt, Nálad lehet valami galiba.]

@thon[Ennél csak az a probléma nagyobb, hogy én is pontosan így vagyok vele. Az írást már egyébként elkezdtem: ][[Coat]]és[[Coat1000]]@thon[ a második az újabb. Emellett a programkódban van egy Commands.java osztály, itt: ]https://github.com/Palmodroid/BestBoard/blob/master/app/src/main/java/dancingmoon/bestboard/parser/Commands.java
@thon[Az "add" részeket kell átnézni.]
@thon[...és alighanem meghagyom Neked a Vickyszerkesztést...]
@lad[Köszönöm, ebből már meg tudom írni, majd kérdözök, ha valamit nem tudok.]

@lad[Van egy problémám, főorvos úr. Valójában nem az, nagyon is jó: fantasztikus sebességgel haladsz a fejlesztéssel, egyre újabb dolgokat ötlesz ki és valósítasz meg. Viszont nekem csak ez az egy fejem van, pont mint Süsünek, és ez azt okozza, hogy elveszek a nyelv változásai között. Mire megírnám a dokumentációt egyes utasításokhoz, már esetleg rég nem léteznek, vagy nem úgy; ami hagyján, de esetleg addigra nem is emlékszem a változásra, és szépen megírom a régi dokumentációját. Aztán csodálkozunk, hogy miért nem jó.\\ Ezért arra gondoltam, hogy kellene egy jegyzék a jelenlegi Coat-változat összes utasításáról, egyetlen oldalon, összes paramétereikkel stb., minimális magyarázattal. Aztán ebből már megírom a bővebbet. Össze tudnánk hozni egy ilyet? Esetleg mindjárt elkezdem.]
[[Utasításkészlet]]

@e[Vigyázat! Csak teszt! De felülírja az előzőt, utána vissza kell telepíteni azt!]
@app[160125]
@thon[Ez is még csak egy köztes változat, de érdemes a test.txt-t kicsit bogarászni. Tudja bővíteni a gombot felirattal, ill. változtatni a háttérszínét. DEFAULT és LET (CHANGE, ha változtatni akarsz egy meglévőt) elég jól működni tűnik az ADDTITLE (slot helyett), meg a BUTTON utasítással is. Elvileg kinesa.txt is eljut az üres billentyűzetig, de tovább - természetesen - nem fog. Bocs, hogy át kell írni. Tervek: a single packet button is még bővíthető lesz double v. alternate packetre, meg lesz még valami nextfree, meg még a BOARD helyett is LAYOUT lesz, és nem LINK, hanem a BOARD fog egy PORTRAIT és egy LANDSCAPE LAYOUTot összetenni szabadon választható keyword alatt. Majd valaha... Tudom, hogy megkevertem egy kicsit, de nagyon kéne tesztelni, ha nem is "éles" billentyűzettel.]

@thon[Van újabb érdeklődő! Kérünk szépen egy hozzáférést: gallzoltan`@gmail.com-ra, Zolinak! Hála és köszönet! Id lehet Zoli, a szín talán LVM, vagy amelyik a hasonlókból jól mutat.]
@lad[Megvan, elvileg a rendszertől kapott értesítést a postafiókjára, ha nem, vagy az nem elég informatív, szóljatok.]

@lad[Csináltam egy puskaoldalt a Vickyhez, ez részletesebb a korábbiaknál.] [[:puska]]
@lad[Valamint egy leírást arról, hogy kell blogot üzemeltetni a Vickyben, ugyanis lesz egy albérlő blogunk, ezért megoldottam, hogy több blog is mehessen.] [[:utmutato]]

@e[Vigyázat! Csak teszt! De felülírja az előzőt, utána vissza kell telepíteni azt!]
@app[160122]
@thon[Kicsit eltűntem, de nem nagyon. Megjártam a világot, közben kipróbáltam egy ötletem, és eddig tetszik. Ha esetleg nem tetszene, akkor sem tudom visszacsinálni, legfeljebb visszamegyünk egy előző változathoz... Egyébként erről már beszéltünk eddig is, csak idáig nem tudtam, hogyan megoldani.]
A //BLOCK// utasítás definiálja a billentyűk egy csapatát (önállóan billentyűt definiálni viszont jelenleg nem lehet). A //BLOCK// tetszőlegesen bővíthető //LET// segítségével, így előre definiálhatunk billentyűcsoportokat. Ld. test.txt
A lényeg: a //LET BLOCK és BLOCK// utasításon belül relatív módon definiáljuk a billentyűket és aztán a végleges //BLOCK// helyezi azokat egy adott pozícióra. (Ezért nem lehet billentyűt önállóan definiálni: kell a BLOCK, hogy akár csak egyetlen billentyű pontos pozícióját megmondja)
Ha nem adunk meg irányt, akkor a következő bill. automatikusan jobbra lép. Explicit irányok: L-R-UL-UR-DR-DL, amiket tovább rövidítettem. HOME visszalép a BLOCK-ban megadott abszolút pozícióra. SKIP, ugyanaz, mint a L-R, kezeli a negatív értékeket is. (1=1 bill-t átlép!) CRR és CRL egy sorral le, az induló bill. alá lép; ettől kezdve ez lesz a CR induló pozíciója (így ugyanis több lehetőséget adhatunk meg, mintha mindig csak lefelé lépne). Az abszolút értékek 1-gyel kezdődnek (eddig 0 volt!) és minden már látható cella (a fél is) 1.-nek számít.
Ja, a default és let utasítások egy-két dolgot (pl. slot) is feleslegessé tesznek...
@lad[Még emésztem.]
@thon[Még én is dolgozom vele, addig csak teszteljük, próbálgassuk és csiszoljuk. A végleges layoutot ne írd rá át, amíg késznek nem nyilvánítjuk, ne kelljen feleslegesen dolgozni. A lényeg: eddig meg kellett adni először a boardokat, AZTÁN a hozzájuk tartozó billentyűrészt. Most viszont előre megírhatjuk a részt labelként, AZTÁN összerakhatunk egy layoutot a billentyűrészekből.]
@lad[Elméletben nagyon tetszik, így lehet részekből összerakni egy kiosztást, ez a jó módszer. Csak a gyakorlatban nem tudom kipróbálni, mert hiába írom át a coat.txt-met ezres verziószámra, jajgat, hogy rossz, nincs benne board definiálva. Pedig ugyanazok az ADDBOARD-ok vannak benne. Csak a test.txt-vel megy.]
@thon[Ez érdekes. Nekem megy (kinesa, ami benne van a programban). Igaz, nem jelenik meg semmi (vagyis üres és szürke a board), de ennek az az oka, hogy most csak a BLOCK-on belüli BUTTON érvényes, az meg nincs. Nálad critical error van? Küld majd át a konkrét file-t, kérlek! De már csak holnap...]
@lad[Igen, critical.]
@coat[kinesa24.txt]
@thon[ok. Nálam megy. Majd küldök új kódot, valahol ott lesz a hiba...]

@s5[Hatszög]

@thon[Új elgondolást találtam ki  koordináta-rendszerre. Kis újévi gondolkodnivalónak logikai feladat: Miként kell megjelölni a HAT irányt, amerre egy szomszédos hatszögre jutunk? (angol, rövid és egyértelmű megnevezés kell) 2. Tudjuk, hogy hol volt az indulópont, akkor miként kell meghatározni, hogy hol legyen a következő "sor" kezdete? Alatta balra vagy jobbra? És a következő? És a következő? Nem egyszerű! Jó gondolkodást!]
@lad[Hopp, nekem ez a kérdés valahogy kimaradt, talán véletlenül kidobtam az értesítést. 1. Javaslatom: vízszintesen a left és right, ferdén pedig a lup, rup, lown, rown szavak, ezeken látszik, hogy minek az összevonásai, rövidek és könnyen megjegyezhetők. 2. Balra. Mindig balra, mert ha jobbra lépsz, kihagysz egy gombot vagy a helyét.]

@app[151230]
Ez egy absz. fejlesztői változat. Különbséget nem fogsz benne látni (egy két nagyon finom változástól eltekintve), de a szerkezetben komoly optimalizálásokat csináltam a következő tervekhez. Ha ezt használod, az csak azért jó, mert ha elrontottam valamit, akkor előbb előjön a hiba, ha többen használjuk. @e[Az utolsó ellenőrzött  változat: ]@app[151228]

@lad[Nédd má, megint szembejött velem egy könyv…]
@thon[Egész jó irodalmakat ásol elő...]

@thon[Csak nem bírtam nyugodni. Elég komoly változtatásokba vágtam a körfűrészt, jön a coat 4! Ötlet bonyolult, majd elmondom, ha kiforrott, csak szólok, hogy az utmutatóban valószínű változtatni kell majd... Addig kéretik a lentebbi kérdéseken is fejet törni.]
@lad[4? Négy-e? Hisz még hármas se volt. Vagy ezután a 8 jön, 16, 32, 64? Nekem jó. Forrald csak!]
@thon[Ja. 3.]

@app[151228]
Az ikonról is a settings jön elő. Ez nem biztos, hogy mindig így lesz, mert sokszor kell a tokenizáló rész; de a lenti módon a settings MINDIG elérhető.
@lad[Jé. Mire kell a tokenizáló? Én még sose használtam.]
@thon[Pedig már igazán programozhatnál egy kicsit :) Az alakítja át a kulcsszavakat kóddá.]
@lad[Tudom, mi a tokenizálás, BASIC-bővítőket írtam C16-osra, de mire kell ez abban a formában a usernek, ahogy az ikonról elérhető?]
@thon[Nem a usernek kell, hanem nekem... Ez ugyanis a fejlesztői változat :)]

A settings-en belül van egy "New text session..." kapcsoló. Text session az, amikor csak text küldéssel dolgozunk. Praktikusan új text session egy új beviteli mező, vagy ha a kurzort érintéssel arrébb visszük. Normál esetben ez úgy működik, mint egy gomb: vagyis az átmenetileg bekapcsolt meta állapotokat kikapcsolja. Ha viszont ezt a kapcsolót tiltjuk, akkor az autocaps állapotot csak egy másik text fogja felülírni, az egyéb meta állapotot meg bármilyen gombnyomás (de kurzor érintéssel történő mozgatása pl. nem).
Az én véleményem szerint ez a mező fixen bekapcsolt kéne legyen, mert a működés úgy következetes. De technikailag kikapcsolható, így (Attila kérésére) lett ilyen is.
@lad[Ezt majd próbálgatom.]

@lad[Újabb hiányosságot találtam: a settings nem érhető el másképpen, csak ha van a gombozatodon egy errevaló gomb. Mert ha megnyomod a program ikonját, akkor egy tokenizélőt kapsz. Akartam csinálni (sőt csináltam is) egy tibeti billezetet, mert valaki kérdezte az Omnigloton, hogy lehet Androidon tibetni, és akkor már ugye kicsi reklám a programnak. De nem tudtam előcsalni a settingst, mert a legutóbbi frissítésnél valamit eltolék és egy korábbi változatú txt volt érvényben. Kiderült, hogy a kinesa.txt működik, de a legújabb állapot a coat.txt-ben van. Mármost a jó ES File Managerben file-t lemásolni más néven nem lehet, a korábbit meg akartam tartani, szóval kicsit macerításosan, de megoldottam, hogy a coat.txt-met most már kinesa.txt-nek //is// hívják, csak azért, hogy megnyomhassam rajta a settingst és beírhassam, hogy tibetan.txt, kipróbálhassam, csinálhassak róla egy képernyőfotót, aztán persze visszakapcs a tavalyi Best’s Keyboardra és a legutóbb használt alkalmazások listájában a settingsre, hogy beírhassam a coat.txt nevét megint, hiszen a tibetin nincsenek latin betűk. Szóval kellene, hogy az ikont megnyomva jöjjön a settings, és ott borzasztóan kellene egy file-választó…]
@thon[Teljesen rossz a megközelítés! A billentyűzetek (az összes) beállításai a rendszerbeállítások alól érhetőek el! Settings/Language and Input/BestBoard mellett a fogaskerék! Az más kérdés, hogy ezt ki lehet tenni az ikonra IS. Viszont az fontos kérdés, hogy mi legyen az ikonon, mert szerintem oda inkább a felhasználói leírás kellene; ami egyébként akár a settingset is elérheti pl.]
@lad[Puff. Nekem logikus volt, hogy az ikonon jöjjön a settings, egyébként mindkettő jócskán el van dugva (ki kell mászni a home screenre, ott elővenni az ikont, avagy beballagni az Android Settingsbe), szóval nem árt, ha van a boardon gomb hozzá, de megesik, hogy nincsen. Mindazonáltal a file-választó akkor is nagyon kellene, mert mi dolog ugye, hogy egy billentyűzetprogramnál néha csak akkor lehessen billentyűzetet változtatni, ha előveszünk egy másik billentyűzetprogramot. Illetve most jut eszömbe, megeshet, hogy egynémely felhasználó a saját írásrendszerével nevezi el a file-ját, nagy lelkesen megírva PC-n, ahol már van neki ahhoz való billentyűzete, aztán rátölti a kis български.txt-jét az Androidra és nem tudja bekapcsolni, mert cirill billezet kellene a cirill billezet eléréséhez…]
@thon[Nem úgy tervezték, hogy bárki is komoly billezetet használjon, és még nem is jöttek rá, hogy ez hiányzik. Több sebből is vérzik ez a rész, de ettől még az android így működik, a bestboard meg alkalmazkodik. File választón dolgoztam, amikor nekivágtunk a billentyűzetnek. Ha vissza tudok térni még hozzá, akkor lesz az is, addig irigálunk. Egy félkész (félhibás) van. Kevés file mellett ez persze nem gond, majd megpróbálom beleszerelni. 
@lad[Hajráf. Ez egyike azoknak a dolgoknak, amik szerintem kellenek ahhoz, hogy a kettes változatot befejezettnek nevezhessük és kiállhassunk a világ elé. Meg az ikon. Meg a dokumentáció…]

@lad[Idén valahogy nem jeleskedtem a karácsonyi jókívánságokban, jórészt ellustálkodtam. Viszont a feltöltött file-ok listájának tetején találsz két újabb könyvet. Boldog karácsonyt!]
@thon[Csak kisbetűsítsd légy szíves, mert így nem engedi!]
@lad[Ajaj, ezt már megint elfelejtettem, bocsánat…]

@app[151223]
A "repeat" mechanizmus teljesen más elven működik. Kiküszöböli a TOUCH_SLOP miatti hibát: némely készüléken csak az ujj mozgását észlelte, a tartást nem. És egyenletesebb is a repeat.
@lad[Nálam tartással is ment, úgyhogy én nem érzem a különbséget, de jó, hogy ez másoknál is már jó lesz.]
@thon[Igen, a note nálam is ment, az sgsii viszont csak ha mozgattam az ujjam. Onnan tűnt fel. Gépbe égetett tulajdonság, de megkerültük.]

@s5[Kombinált gombok]

Jelenleg vannak: ButtonMainTouch (vagyis a betűk) és ButtonMultiTouch (meta, link) gombok.
A MainTouch vonal gombjai: Packet, DoublePacket, (lesz majd AlternatePacket stb.) mindegyike egy Packet-et (ami lehet szimulált Key, Function és persze Text valamelyike) tartalmazhat.
De:
SpaceTravel: speciálisan működik, csak érintéskor vagy elengedéskor reagál (egyébként Packet-et küld, amit át is definiálhatunk)
Enter: még speciálisabb, mert PacketText és PacketKey egyaránt van benne, de tud visszajelzést is.
(A DO backspace ill. DO delete azért DO, mert azok sima Function-ok, amiket bármelyik MainTouch gombra rápakolhatunk.

DE (és itt jön a kérdés) elakadtam:

A BACKSPACE/DELETE igaziból egy komplett gomb kéne legyen, mert adott esetben a meta gombok mellett PacketKey-t (DEL ill. FW_DEL) kellene küldenie.
Még nagyobb --gomb-- gond a autofunkciókat kikapcsoló gomb, mert kéne rá visszajelzés. Ugyanakkor rá lehetne tenni a SPACETRAVEL-ra.
A másik gond a "settings", amit régen rátettünk az ENTER-re. (most speciel külön van)

@A lényeg: kombinált gombokat tudok készíteni, de a kombinálást egyik esetben sem tudom úgy megoldani, mint a sima MainTouch gomboknál, mert speciális, saját működés (programrész) kell hozzá. 
A kérdés nyilván nem az hogy legyen/ne legyen/mi legyen. Hanem inkább az, hogy milyen ötlettel lehet ezt "globálisan" sőt holisztikusan megoldani. Vagyis pl., nem tudom jelenleg a coatban leírni, hogy legyen egy enter, ami körözésre backspace. Holott, egy-pár programsorral lehetne ilyet csinálni. De __minden__ kombinációt nem tudok felprogramozni (mint ahogy pl az enter/bs kombó is teljesen felesleges.)

@s5[Ikon]

@lad[És kell neki egy ikon! Hirtelen döbbentem rá, hogy az még nincs neki. Ötletem: rajzolok egy jó nagy magányos gombot és ellátom egy csomó felirattal, egypár betű különféle ábécékből, egy-két szócska, írásjel, és ő lehetne az ikon. Megfelel?]
@thon[Nekem a régi bestboard facebookos kép jobban tetszik. Annak egy része nem lehetne? Vagy olyasmi? Szóval, hogy legalább a mellette lévő színes gombrészletek láthatóak legyenek. De egyébként teljesen megfelel.]
@lad[Dehogynem. Bármi lehet. Ha már meglevő képet használsz, ahhoz nem is kellek, bárhonnan kivághatod. De van alternatív ötletem is. Az előző ötlet a jó nagy magányos gombbal, de ne legyen többé magányos. Egy gomb az ikonon, többféle felirattal, és mellette látszanak további gombok részletei. Vagyis hét gombot kell rajzolni hatszög alakban. További ötlet az ötlethez: ha a feliratok olvashatók (márpedig úgy lenne értelme), akkor látsszon az ikonon, hogy nem valóságos billezetről való a kép. Úgy értem, más billezetprogramok használhatnak olyan ikont, amin látszik egy darabka a QWERTY kiosztásból, mert ők azzal dolgoznak. Ha mi olyan ikont használunk, amin a Kinesából van egy darab, az olyan érzést kelt, hogy ez márpedig Kinesa, azaz egy fura és mindenki másnak használhatatlan kiosztás. Ha viszont olyan az ikon, ami a valóságban nem lehet értelmes kiosztás, akkor érzékelhetőbb, hogy itt nem egy bizonyos kiosztást ábrázol az ikon, tehát a program sem egy bizonyosat csinál. Lehet, hogy az lenne a legjobb, ha a hatszög alakban levő hét gomb mindegyikéből látszana a középső rész, és ott hét különböző írásrendszerből lenne egy-egy karakter.]
@lad[No, egy kép ezer szóval is, tehát valami ilyesmi. De ez csak vázlat.]
@png[ikon1]
@thon[Lent még hagytam a megválaszolatlanokat. Fogorvosért együttérzésem.]
@thon[Ikon jó, név sztem legyen Best's Board, csak a csomagnév lesz bestboard.vmi.... Legalábbis nekem jobban tetszik.]
@lad[Te döntesz, de légy figyelömmel a kiejtésére. A Best’s Board már négy mássalhangzót torol össze.]
@thon[Nem, az enyém is csak egy vélemény. De a BestBoard túlságosan technikailag hat, a Best's Board mögött történet is van, ezért nekem jobban tetszik. A kiejtésen gondolkodhatunk, bár én nem szoktam mondogatni a programneveket. Egyébként a BetaBoard-ot (opp, nincs torlódás!) pont azért javasoltam, mert kifejezi, hogy ez még nem a "Best", sőt. A Best's Board nem kelt ilyen képzetet...]
@thon[A név legyen két sorban (nagyobb is úgy), a fekete-zöld szín nagyon nem jó, annál sokkal szebbet tudsz keverni, de a többi gyönyörű.]
@lad[Igen, nagyban. Kicsiben gyakorlatilag kivehetetlen, úgyhogy a betűket valami kontrasztosabb színnel kell majd írni.]
@thon[ Én tennék a hat szélső bill. valamelyikére latin betűt, akár hosszú ékezetes magyart v. bármi. Mer' az egyszerű pógárnak nem fog lejönni, hogy a név latin betűkkel van. Esetleg balra fenn 'Á', jobbra lenn omega? Mint egy másodlagos szimbolika. Apropó: nincs olyan kínai írásjel: ember aki géppel nagyon jól ír és nyugodt? vagy valami:)]
@lad[Rendicsek. A kínaival egy baj van: azt sugallja, hogy van kínai támogatás a programban. Márpedig nincsen, és anélkül gyakorlatilag nem lehet írni vele kínaiul.]
@thon[Na jó. Egyébként mi kell egy kínai támogatáshoz? ]
@lad[Hát ez hosszabb lélegzetű dolog, átgondolom és leírom.]
@thon[Viszont toljuk el egy kicsit, ne legyen centrált a bill. balra fel egy kicsit?]
@lad[Nem tudom, lehet.]
@thon[Színek tekintetében absz. megbízom az ítéletedben, lehet kontrasztosabb, vagy ami csak tetszik. Alternatívaként eszembe jutott, hogy valamelyik grafikusunknak megmutathatnánk, azoknak jobb szeme van az ilyenhez... A kínaival ráérünk. Ha leírni is ilyen összetett, akkor megcsinálni bizonyosan nem lesz mostanában időm.]

@s5[Kínai (és egyéb) támogatás]

@lad[Azért volt összetett leírni, mert ez valójában sokkal többet tud, egy egész komplex rendszer, amit szerintem nem annyira bonyolult megvalósítani, mint amennyit nyernénk vele. Kétségkívül nem két perc létrehozni. Meg hát úgy akartam leírni, hogy legyen némi háttérinfó, példák, ez-az, kinézzen valahogy. Azt mindenképpen szeretném, ha elolvasnád, most úgyis jönnek az ünnepek, egyéb gondod se lesz a töméntelen gyerek és a nagy ivászatok után kórházba kerülő rengeteg ember mellett, mint az én ötletrohamaimat olvasgatni…]
[[kínai_támogatás]]
@thon[Nyitott kapukat döngetsz, ezen már gondolkodtam. No, nem kínaira. De pl. rövidítések/javítások stb. ugyanígy történnének. Egyébként most, ahogy használom is a programot, egyre több hibába/kétértelmű megoldásba futok bele. Úgyhogy most egy kicsit megállnék, és először ezeket tenném rendbe. Ez persze nem jelenti azt, hogy nem születhet közben akár nagymérvű változás is.]
@lad[Vau. Akkor csak annyi kell a kínai támogatáshoz, hogy ezt a rendszert a kínai igényeinek megfelelően alakítsuk ki; itt a legfontosabb szempont az, hogy jó nagy memóriaterületet kell rezerválni. Hogy mekkorát, az majd kiderül, beszerzek egy-két ilyen listát.]
@lad[Egyáltalán nem baj egyébként, ha kicsit lassul a fejlesztés, akkor hátha jut időm utolérni Téged a dokumentációval…]

@s5[Tök más - CHAT]

@thon[Eszembe jutott két dolog is, amíg irigáltam. Ez a CHAT igen jó, bár egy idő után igen méretes lesz. DE sokáig írogattunk levélben a billentyűzetről, azokat is be kéne valahogy tenni a végére, mert sok jó ötlet van benne, ami így már akár kereshető/visszakereshető is. A másik ami ennek kapcsán eszembe jutott. Nekem semmi feljegyzésem sincs az időpontokról. Legalább a címbe érdemes lenne valami időbélyegzőt tenni, mert akkor látnánk, hogy egy-egy téma mikor merült fel. Minden hozzászólásban felesleges betenni, mert néhány nap alatt úgyis kitárgyaljuk, de nekem pl. fogalmam sincs, hogy mióta létezik a ColorBoard vagy mióta a BestBoard... Nem mintha lényeges lenne, no de mégis.]
@lad[Ezt meg lehet próbálni, csak persze jó sok szöveg. Első körben összeszedem majd a leveleinket és elkezdem kimásolni, ami a programra vonatkozik; visszafelé haladólag, mert a legrégebbi levelezések már biztos rég fönt vannak itt, meg alighanem túlhaladott problémákat tárgyaltunk.]
@lad[Az idő nehezebb ügy, nem igazán tudjuk rekonstruálni, hogy mi mikor volt. Itt a Vickyben ha egy-egy oldalba belejavítunk, akkor persze fölírja, hogy mikor tettük, de valahányszor kimentettük a szöveget, az egy bejegyzés, rengeteg van belőlük. És ezen a csetoldalon csak nyárig visszamenőleg.]

@app[151217]
Az opciók között megjelent 3 új elem (editing control):
  - text retrieval
Kiolvashatja a kurzor körüli szöveget. (Ez nem működik jól AIDE-ben)
Automata: akkor olvashatja ki, ha az editor épeszű info-kat ad át. (AIDE-ben a kurzorpozíció mindig -1)
  - text store
A szöveg (ha a kurzor csak a beírás miatt mozdul) tárolódik. Nem végez költséges kiolvasásokat (annyit)
Az automata ezt csak sima text esetén engedi meg.
  - elongation period
A leütés után néha még tartanak a nem kontrollált kurzormozgások. A billentyű leütésnél mindenképp ellenőriz. Felengedés után viszont még ennyi ideig nem. Ha az idő letelte után megérintjük a képernyőt (mielőtt más gombot nyomnánk), és a kurzor arrébb megy, akkor észleli, hogy kurzormozgás történt. 100 körül jó volt, főleg a modify szenved, ha túl lassú (de előtte a retrieval-t ki kell kapcsolni, hogy ezt lássuk is).

@thon[A gond az, hogy ezek nagyon finom beállítások, többnyire csak a log mutatja, hogy mi történik. Egyébként ezzel el is értünk arra a szintre, amikor ketten már kevesen leszünk a teszteléshez... Azért Te csak teszteld! :)]
@lad[Tesztelném, de hogyan? Mit kell tenni hozzá? Az opciók megjelennek, ki-be kapcsolgathatók, de különbséget nem látok. Igen, kurzormozgatásra kikapcsol az autocaps; sajnos akkor is, ha törlöm a pont utáni szóközt, pedig még mindig pont után vagyok. Erről nem beszéltünk, azt hiszem, de tényleg fontos: az autocapseknek két válfaja van. Az egyszerűbb az eddigi, én is ezt csináltam különböző billentyűzeteken: ha mondatvégi írásjelet nyomtál, akkor autocaps, és ha elmozdítod a kurzort, akkor is érvényben marad. A másik változat van egyes profi szövegszerkesztőkben: ha a kurzor mondatvégi írásjel után áll, akkor autocaps, mindegy, hogy azt a jelet most ütötted le vagy úgy sétáltál oda. Mármost ha kurzormozgatásra kikapcsol az autocaps, akkor szerintem illendő lenne, ha kurzormozgatásra //be// is kapcsolna. Vagyis ha mondatvégi jel mögé sétálok a kurzorral, akkor autocaps. Ez viszont teljes ellentétben áll az eddigi koncepcicóval, hogy az autocaps bekapcsolása nem karakterhez, hanem gombhoz kötődik, ugyanazt a jelet lenyomhatjuk autocapsszal és anélkül is, és ez nagyon hasznos. Javaslatom a dilemma feloldására: a) ne kapcsoljon ki az autocaps kurzormozgatásra, b) legyen opció, hogy ki-e kapcsoljon-e, de háromállású, tartalmazza azt is, hogy teljesen ki lehessen kapcsolni az autocapst. Mert ha valaki a rendes irodalmi szöveghez való, autocapsos billezettel webcímeket, programszöveget ír, akkor csak útjában lesz.]
@thon[Teszt: óriási különbség van, de nem fogod látni, ha minden jól működik. Ezért kellene sok-sok használó, mert akkor kijönnének azok a hibák, amik csak egy-egy programmal való speciális kommunikáció során jönnek ki. Ld. pl. AIDE, ami a legalja, mert nem csak nem kommunikál, de hülyeségeket is küld. De gond van a numerikus mező/store kombinációnál is, próbáld ki a settingsben a körözéssel az undo-t! Kitörli a számot, mert úgy érz, hogy ő beírta a szöveget, pedig nem. Na de száz szónak is egy a vége: az eddigi editorok és edit-text mezők alapján mindkét beállításra szükség van, de az automata az általunk használt editorokat és mezőket (legalább) beállítja. De egy csomó mindenről nincs info-nk pl. a különböző passwd mezők, egyedi beállítású (pl. hexa) mezők stb. A hibák csak akkor fognak kijönni, ha ezt sokan és sokféleképp használják... ]
AUTOCAPS: ezt nagyon át kell rágni, pontosabban a koncepciót. Ehhez megint definiálni kell(ene), mi az editor és mi a billentyűzet feladata.
A "gond": mi billentyűket definiálunk és nem egy tulajdonságokkal felruházott karakterkészletet. Emiatt nem azt mondjuk meg, hogy a pont után autocaps van, hanem a pontot küldő billentyű után van autocaps. Ez az autocaps a következő billentyű működését befolyásolja, tehát fogalma sincs arról, hogy egy mondat, egy sorszám vagy egy rövidítés után áll, csak azt tudja hogy az utoljára elküldött billentyű után következő szöveges billentyűnek nagynak kell lennie. De ez kizárólag a tőle jobbra álló szövegre vonatkozik, vagyis, ha a kurzor arrébb megy, akkor ott már nem érvényes a nagybetű. A BackSpace meg pláne fontos, mert pl. pont egy webcímnél az space-t és a nagybetűt együtt töröljük. Ha elmentünk, és mégis nagybetűt akarunk, akkor meg kell érinteni a caps betűt. Ez szerintem a logikus működés, a kérdés, hogy tudjuk-e javítani.
A kurzormozgás is billentyű. Eltekintve attól, hogy nem textuális, tehát nincs autocaps tulajdonsága; nem is lehetne beállítani, mert akkor minden mozgásra egyaránt kiváltaná az autocaps-t.
Ezen túlmenően a keyboard - ha együttműködik vele az editor - képes bizonyos editálási funkciók ellátására (a kurzor közeli szövegrészeken). A gond kettős: az editorok még legalább API 21-ig nem fognak együttműködni, tehát a kurzormozgásról csak néha tudunk, nem mindig. (API 21-ben már le lehet kérdezni a kurzorpozíciót. Nem biztos, hogy válaszolnak.) A másik gond viszont, hogy nem tudjuk, milyen pont mögött állunk. Amikor a felhasználó azt írja, hogy "Mr.", akkor az ABR jelű, minden beállítástól mentes billentyűt használja, ha meg azt hogy "Hello világ. Sz...", akkor a rendes irodalmi pontot. De az utólagos visszaálláskor nem fogjuk tudni, hogy melyik ponton állunk is pontosan.
A megoldást csak egy külön szövegszerkesztő jelentheti, amelyik együttműködik a billentyűzettel. Pl. megjegyzi, hogy melyik pont mire szolgál. Vagy akár külön karakterrel is jelöli ezeket.
A következő kérdés az, hogy miért nem lehet minden úgy, mint eddig? (Egyébként lehet.) Most a szöveges írás és törlés (tehát, ami nem hard-key vagy külső mozgás) egy session-nek számít. Legkésőbb minden egyes új billentyűlenyomás ELEJÉN ellenőrzi, hogy hogyan állunk. Ezen túlmenően, ha a keyboard tudomására jut, hogy kurzormozgás történt, akkor is ellenőriz. Ez kikapcsolható, csak az értelmét nem látom.

Az auto-funkciók kikapcsolása már nekem is szükségesnek tűnt, épp azon kísérletezek, hogy a space fölé tegyem körözésre. A gondot az jelenti (és emiatt lehet, hogy nagyobb átalakítás kell egy független billentyűhöz), hogy vissza is kéne jelezni a kikapcsolt állapotot, pl. egy off felirattal (ami hasonlóan változhat, mint az enter feliratai.) 

@lad[Jelentem, valami baj van a zárójelekkel. Szögletes is, gömbölyű is. Ha lenyomok egyet, akkor unfortunately a program stopped. Először az erasespacesre gyanakodtam, de nem az, a vesszőnél is van erasespaces és ott nem történik. Hopp, megvan. A Symbol Shift boardommal van a baj. Ezek ott vannak. Más jelekre is csinálja, amik azon vannak, ® jel például, a board jellemzője, hogy nincs rajta lock, és alighanem az automatikus visszaváltásnál lesz valami galiba. Összecsomagoltam a logokat, amikor először leomlott a program, de innen nem tudom föltölteni, majd PC-ről.]
@e[Erről nagyon kellene info. Pontosan mit kell nyomni, hogy összeomoljon?]
@thon[Hopp, megvan. Az autocaps-et a linkváltás után próbálta beállítani, amikor már nem volt billentyű. ]
@app[151219]
@thon[A hibán kívül - átmenetileg! - kikapcsoltam a kurzormozgás figyelését. De szerintem ez egyáltalán nem logikus.]

@lad[Tudom már, mi kell, hogy publikálhassuk a programot – a beépíthető billezeten kívül –: meg kell szüntetni ezeket az irdatlan logokat, mert a felhasználók frászt fognak kapni, hogy teletöltjük a gépüket és kémkedünk utánuk. Abból induljunk ki, hogy aki letölti a programot, az használni akarja, de tesztelőnek egyáltalán nem biztos, hogy szándékában áll lenni. Majd ha igen, kapcsolhassa be a logokat.]
@thon[Hát ez szerencsére rég meg van oldva. A debug mennyisége a programon belül beállítható; most sok, mert pont a session-t nézem. De van egy debug kapcsoló, amivel az egészet ki lehet kapcsolni teljesen, ez benne van az opciókban. Plusz: talán 8 file mélységben, egyenként 1 mega terjedelmben tárol; de ez is beállítható. A gond a következő: ha hiba van, akkor a TELJES debug anyagra szükségem lenne, vagyis mindent be kéne kapcsolni; ilyenkor lassul v. akad is a program ÉS nagy file-mennyiség is kellhet. Fogalmam sincs, hogyan lehet ezt jól megoldani. Mindenesetre nincs irdatlan log. Töröld az összeset, kapcsold ki az opciót. Csak a coat.log keletkezhet, ami viszont mindig törlődik. Ha nem így van, akkor baj van.]

@s5[Gond - következő változatban megoldva]

@thon[Súlyos logikai problémába ütköztem: ha valami történik a szöveggel, amit nem mi csináltunk, azt csak onnan tudjuk, hogy a kurzor pozíciója változik. De amit mi csinálunk, az is változtatja a kurzor pozícióját. A gond az, hogy az editorok a létező legkülönfélébb módon közlik, hogy a kurzor arrébb vándorolt. AIDE: sehogy. EditText mező: egy hosszabb procedúra után az utolsó pozíciót jelzi. Jota: ha a hosszabb procedúra befejeződött, akkor minden lépésről küld értesítést. Én ugyan számolom, hogy hol kellene tartania a kurzornak, de ezt a sokféleséget vajon hogyan fogom tudni feloldani?]
@lad[Erre kérhetek valami gyakorlati példát, amikor ez gond? Hátha akkor megértem.]
@thon[Legyen egy 'A', ami AUTOCAPS ON-t is csinál. 1. 'A' - beírja: A. 'b' - beírja B. 2. 'A' -beírja: A. Arrébb tappintok, ezt onnan kell látni, hogy a kurzor pozíció nem úgy változik, ahogy számoltuk. Ez kikapcsolja az AUTOCAPS ON-t, tehát 'b' beírja: b. Jelenleg ez 'B'-t ír, próbáld ki! 3. 'A' - beírja 'A' - köröz - törli, és beírja "Aha". Ez némelyik editorban olyan, mintha csak azt írtam volna: "Aha". Másokban (Jota) olyan, mintha írtam volna egy 'A'-t, tappintok (ami elmozdulás! tehát mindenféléket ki-be kapcsolgat), majd mintha írtam volna egy "Aha"-t. De én is töröm a fejem rajta. Valahogy tudnom kell, hogy tapintás miatt, vagy a beírás miatt változott a pozíció.]

@thon[Hm. Hm. Van ötletem, de egyre nehezebben kijátszható a rendszer.]
  - A kurzor pozícióját minden gombérintés (ez a bow) elején ellenőrizni kell.
  - (ez az új) tudjuk, ha a gombunk kurzormozgást okoz (mert beír vagy töröl), ebben az esetben az ellenőrzést felfüggesztjük.
  - ha ilyet nem csinál a gomb, akkor minden kurzormozgást kurzor pozíció érvénytelenítésnek fogunk tekinteni (mert más, pl. egy szimulált hard-key okozta a mozgást)

A nyitva maradt kérdés: lenyomunk egy 'A'-t, ami felfüggeszti az ellenőrzést. Az ellenőrzés biztosan vissza lesz kapcsolva (vagyis újra lesz értékelve) a következő billentyű elején. De a kettő között vajon mikor kapcsoljuk vissza? A billentyű végén még biztosan nem lehet, utána meg nem tudok eseményt, amikor lehetne. Időkapcsoló? De mennyi? És ezt nem is nagyon látja a felhasználó, max. abból, hogy túl rövid időnél eltűnik az autocaps, mert kurzormozgásnak észleli a saját változtatását. Valószínűleg akkor is a halasztott értékelés lesz a nyerő.

(Csak saját gondolkodás végett: 
long checkEnabledAfter;
  * 0L (ALWAYS) - beállítva minden gomb elején
  * Long.MAX_VALUE (NEVER) - ha delete vagy beírás történt, ellenőrzés felfüggesztve (undu nem számít, mert akkor is volt változás!)
  * System.nanoTime() + THRESHOLD (long) - ha a stroke legvégén (vagyis, ha a gombról felemeléssel távozunk); és akkor ha a checkEnabledAfter == NEVER - vagyis, ha korábban beírás/törlés történt, akkor halasztottan kapcsoljuk vissza.

Ellenőrzés (onUpdateSelection) - Ha System.nanoTime() > checkAtTime
  * ALWAYS - mindig nagyobb, vagyis folyamatosan ellenőriz
  * Beírás/törlés után - NEVER - vagyis soha nem ellenőriz; ez legfeljebb a következő gombig lesz így VAGY
  * Konkrét időpontig marad kikapcsolva - a THRESHOLDON belüli változásokat figyelmen kívül hagyja, CSAK akkor, ha felemeltük az ujjunk.)

@app[151215]
@thon[Ezt az elgondolást megcsináltam, működőképesnek tűnik. Nem írtam be a névbe, de ez TESZT-változat, nem biztos, hogy minden körülmény között jól teljesít (bár ami eddig ment, az eztán is kéne menjen). Aminek működnie kell (kéne): az autocaps kikapcsol minden kurzormozgáskor. ]
@thon[Kérdés: lehet, hogy a meta-nak is ki kéne kapcsolnia kurzormozgáskor? Ill. milyen visszaállítások lennének illendőek beviteli mező váltásakor? Autocaps gondolom. De meta is? Meta-lock? És board? Vissza 0-ra?]


@lad[Megigazítottam az] [[uniboard]] @lad[programot, nem tud többet, de a jelenlegi szintaxissal generál és megint használható.]
@thon[Príma.]

@s5[Beépíthető kiosztás]

@lad[Jelentem, munkához láttam a beépítettbillentyűzetjelölt-fejlesztéssel. Némileg változtattam a koncepcicón. Arra gondoltam, hogy az első felhasználók legnagyobbrészt az ismerőseink közül kerülnek ki, akik részint magyarok, részint nem, ezért legyen benne Kinesa //és// QUONG. Ezért a saját gombozatomat kezdtem átgyúrni. Már kivettem a cseh bővítést, a helyére fixen fölkerültek a számok. A színes karaktereket kivettem, egyrészt mert egyes gépeken esetleg fekete-fehérben se jelennek meg, csak kockát kapnak, másrészt mert ezeknek felirat kell, hogy lássák, mit csinál a gombjuk. Minden funkciógombnak felirata lesz. A cirill és a görög megmarad, úgyszintén a rengeteg módosító, hogy lássák, mi mindent tudhat egy ilyen kiosztás, de a TESZ-karaktereket persze kivettem, azok csak az én fontommal látszanak, és ne igényeljen saját fontot.]
@lad[További teendők (ez magamnak szól):]
  * üres helyeket kitölteni főleg a QUONG-on, hisz jóval kisebb a Kinesánál
  * QUONG színezését megcsinálni ✔
  * Symbol Shift legyen teljes kiosztás
  * Dia kiosztás töltse ki a területet ✔
  * QUONG-ra angol írásjelek ✔
  * @thon[Sztem. a bestboardmaker kiosztást is bele kellene rejteni. És ne feledkezz meg a dupla billentyűkről - ha kellenek.] @lad[Bestboardmaker, csakugyan. Dupla billentyűket egyelőre nem tettem bele, vagyis a nagybetűsítő funkció jön rá.]

@s5[Szövegszerkesztők tesztje]

Funkcióteszt: autocaps, autospace/erasespaces, módosítók, kijelölt szöveg törlése, körözés…
  * Jota ✔
  * Jota+ ✔
  * Chrome, Vicky ✔
  * K–9 Mail ✔
  * Facebook ✔
  * Messenger ✔
  * Fiinote ✔
  * Wikipedia, keresődoboz ✔
  * Google Play, keresődoboz ✔
  * Text Editor by Byte Mobile ✔
  * Text Editor by JellyBeanUser ✔
  * QuickEdit ✔
  * DroidEdit Free ✔
  * AIDE 😱😭😈😡 A kijelölt szöveg törlése jó, a szóközök és a módosítók viszont az egész szöveget széttépik, hatalmas darabokat szaggatnak ki belőle, a törlés rosszul működik. Írni fogok egy inkompatibilitási oldalt a dokumentációba, addig ezt a listát kérem itt hagyni. A körözés szimplán csak nem működik.
  * Microsoft Word✔
  * Docs To Go✔

TeamViewer?? - ezt nehéz megmondani.

@thon[Ez nagyon jó és nagyon fontos!! Egyébként AIDE nem tiltja le ezeket a funkciókat? Elvileg kellene neki az utolsó verzióban...]
@lad[Hát azt én nem tudhatom, de elég volt pár simogatás a mondatvégi írásjeleken és egykettőre eltüntetett több sornyi szöveget.]
@thon[Oké. Ez maradjon együtt a fenti listával, mert a későbbi verzióban - ha tiltható lesz a funkció- visszatérünk rá.]

@s5[Wincsi]

@lad[Egyébként Sweetie tárkapacicása valahogy megnőtt egy terával. Hüpp-hüpp-hüpp, Attila-trükk.]
@thon[Ilyet én is szeretnék! Én is! Én is! Én is! De nekem valahogy mindig ezt írja ki: az alkalmazás számára kevés a memória :) De legalább működik.]
@lad[Milyen alkalmazás?]
@thon[No, azt én is szeretném tudni... De csak ezt írja ki, aláírás nincs. Az alkalmazások meg futnak.]
@lad[Elvesztöttem a fonalat…]

@s5[A program neve]

@thon[Van egy olyan ötletem, hogy a nagyképűség elkerülésére a fejlesztés alatt álló változatot nevezzük el BetaBoard-nak, míg a végleges maradjon nyugodtan Best's Board.]
@lad[Ellene szavazok: szokjon csak meg a nagyközönség egyetlen nevet. Ha lesz. Mármint nagyközönség.]
@thon[Ok. Vétó elfogadva. Viszont a "név"-nek illik tartalmaznia a weboldal címét. Tehát kéne valami olyan: bestboard.android.lattilad.org, vagy amit csak akarunk; de a megállapodás az volt, hogy a program teljes neve (pontosabban a csomag neve) maga a webhely címe, csak fordítva: pl. org.lattilad.android.bestboard. De lehet bestboard.lattilad.org is, ahogy csak szeretnéd. Csak döntsünk egyet, felkészülve arra, hogy akár lesz még más program is. Ez mindenképp kell ahhoz, ha be akarjuk rakni a gugli-játékba.]
@lad[Nem vétó, csak szavazat, viszont az, hogy .lattilad.org legyen a vége, az nem az én óhajom, hanem így hívják a szerverünket. Elébe írhatunk bármit, de ne tartalmazzon pontot, mert akkor azt külön bele kell írni a programba, és elég sok mindennel összeveszhet, inkább nem tenném. Tehát valami.lattilad.org – én amondó vagyok, hogy bestboard. Ha később lesz más program, az hasonlóképpen, valami.lattilad.org elnevezéssel.]
@thon[Az, hogy bestboard az egyik vége, és lattilad.org a másik az világos. A kérdés inkább az, hogy mi legyen közte - ha egyáltalán. Lehet: bestboard.lattilad.org is. Csak az a kérdés, hogy akkor lesz-e ujprogram.lattilad.org is, vagy legyen kapásból közéiktatva pl. egy android szó is. vagy prog. Vagy nem tudom mi. Ez inkább a weboldal miatt kérdés, hogy egyszerű és jobb megcsinálni, mert akkor ott kéne legyen a leírás eleje. Vagyis úgy lenne logikus. A pont sajnos kell, ezt írja elő a namespace. ]
@lad[Szeretném, ha nem lenne közte semmi, csak ujprogram.lattilad.org, mert az aldomainek kezelőrendszere nem igazán van felkészülve dupla aldomainekre. Történetesen egyébként az ujprogram.lattilad.org csak rövidítés, ahogy a] [[http://thon.lattilad.org]] @lad[is csak egy rövidített link ahelyett, hogy http://lattilad.org/vicky/doku.php/thon.]
@thon[Az ún. "namespace" teljesen virtuális web-cím, csupán arra szolgál, hogy megkülönböztesse a programokat. Ld. a mostani "webcím" nem is értelmezhető, de a rövidsége miatt könnyű volt dolgozni vele (min. két tagra az IDE kötelez). Csak az emberi megállapodás (meg a logika) javasolja, hogy a virtuális (java/andriod által soha fel nem keresett) oldalon legyen is valami, hiszen akkor a program (csomag) neve megmondja, hol van hozzá info. Az org.lattilad.bestboard csomagnév tökéletesen megfelel. Erre egyébként akkor lesz igazán szükség, ha betesszük a google-play-ba, mert attól kezdve ez nem változhat. (Vagy ha változik, akkor már új programnak számít.)]
@lad[De hisz a csomagnevet a felhasználók nem is ismerik. Én egyetlen itthon levő programét sem tudom; néha látom, de nincs rá szükség, hogy megjegyezzem. Akkor nem mindegy, hogy hasonlít-e a webcímre? Én azt hittem, a dancingmoon vagy a digitalgarden lesz a csomagnév. Felőlem lehet bármi, benne lehet a lattilad.org vagy sem, ahogy Neked szimpatikus, de a csomag nevéből senki nem találja meg az infót, mert azt nem is látják. Ki kell írni a webcímet a Playre.]
@thon[Ez igaz; bár én már kerestem csomagnév alapján. De a megegyezés mégis ez.]http://developer.android.com/guide/topics/manifest/manifest-element.html és http://stackoverflow.com/questions/6273892/android-package-name-convention

@s5[December nyolcadikai változat]

@app[151208] @e[Ez a verzió elvileg már nem tartalmazhat olyan problémát, ami a felhasználót látványosan zavarja. Szerintem ezen a ponton, vagy kis tesztelés után a program - ha először szűk körben is - de közzétehető.]
@lad[Aj, ölég baj az. Én még sehol se tartok a magam részivel, dokumentáció, beépíthető Coat…]
@thon[Elvileg a "heavy check", vagyis az első módszer tévedhetetlen - már ha kap infot az editortól. MINDEN beírás előtt újra ellenőrzi, hogy mi a szöveg. Leginkább ez egy numerikus mezőben próbálható ki, ott ugyanis betűket nem fogad, csak számot. De ellenőrzés nélkül nem tudja, hogy az elküldött szöveget az editor kidobta.]
@lad[Vannak más nyalánkságok is. Nemrég Teamvieweren át üzemeltettem a PC-t, és a röndös Kinesát használtam, hisz mi mást. Total Commanderben megnyomom a szóközt, kijelöl egy könyvtárat, annak rendje-módja szerint. Jelölném ki a következő könyvtárat, megint megnyomom a szóközt. Erre fölugor a szülőkönyvtárba és kijelöli azt. Nem értettem, mit ugrál, mint az Orbán lölke, aztán rájöttem. Az ERASESPACES AROUND azt okozza, hogy amikor egy szóközt megnyomtunk és korábban szóköz volt, akkor töröljük az előző szóközt és úgy küldjük ki az újat, vagyis Backspace, szóköz. Csak hát Commanderben a szóköz visszaugrik egy könyvtárral följebb.]
@thon[Bizonyos editorok (pl. AIDE) NEM kommunikálnak, csak fogadják a küldött adatot. Ezt nem tudom, honnan kéne tudnom, mindenesetre most: Amíg az editor nem küld konkrét kurzorpozíciót, addig a szövegkörnyezettel kapcsolatos funkciók tiltva vannak (pl. modify, vagy körzés, igazából a delete is. A delete, mint szimulált hard-key működik; érdekes, hogy a FORWARD_DEL AIDE alatt így se (pedig ehhez már tényleg semmi közöm). A módszerrel az a gond, hogy az editor KÉT csatornán üzen: 1. kurzorpozíciót küld (ezt ellenőrizzük), 2. kurzor körüli szöveget küld (ezt használnánk, ha az első ellenőrzés engedné.). Azért nem lehet a 2. pontot ellenőrizni, mert pl. az AIDE - ha van, ha nincs - csupa space-t küld vissza. Emiatt az autospace úgy látja, hogy törölnie kell az összeset és az egész előző szöveget törli. Szóval 1. pont ellenőrzés -> 2. pont tiltás. Ez nem logikus, de mást nem tudok kitalálni, még levelezhetünk AIDE-vel; akik egyébként egy hozzászólásban azt mondták, hogy performance miatt tojnak mindenki fejére.]
@lad[Akkor tojnak. Ez van. Nem tudunk varázslani, adatokat beszerezni onnan, ahol nincs, a felhasználó jár pórul, mint mindig. Amennyire együttműködik a két program, annyira tudja használni.]
@e[De ami mégiscsak fontos: ki kell próbáljuk a lehető legtöbb szövegszerkesztőben. ]@thon[Egyébként igazad van, a rövid mezők biztos, hogy gyáriak lesznek, abból egyet elég megnézni. De a "nagyok" tartalmazhatnak saját kódot; csinálhatnánk egy listát, hogy mivel működik. Meg mivel korlátozottan. AIDE-t nagyon sajnálom, mert sokat használtam, de hát ez van. Majd másban dolgozok, aztán lesz egy olyan gomb, ami az egész szöveget képes lesz átmásolni. :)]
@thon[De ez akkor is nagy fegyvertény, hogy legalább, ami benne van, az működés képét mutatja (ha nem is mindig működik). A lényeg: Ha kipróbálod ezt AIDE-ben, működni fog. Ugyanis AIDE nem ad infot, és emiatt a BestBoard letiltja az összes editor-kommunikációt. Mivel ez máshol is gond lehet (pl. TC), ezért arra gondoltam, hogy a kommunikáció engedélyezésének szintjei (ami egyébként már most benne van két változóban) kikerülnek a settingsbe, sőt akár egy button is válthat rajta. Ez azt jelenti, hogyha egy idióta editorral találkozunk, akkor egy billentyűnyomásra letiltunk minden "belső" editorfunkciót, és úgy fog működni a billentyűzet, mint egy "hardveres". CSAK billentyűküldés lesz. A hátulütője ennek, hogy ilyenkor minden editálás (modify, körzés stb.) kényszerűen nem működik. Beállítani (még) nem lehet ezt, de az AIDE már így csinálja.]
@thon[Az nem baj, ha nem tartasz sehol, mert majd fogsz.]
@lad[Eegen… majd fogsz, csak jelenleg alsz, mint a mormon, fényes nappal. A rövidke ébrenléti szakaszokban találtam két pdf-et, föltöltöttem ide, nédd meg, fogalmam sincs, mi van bennük, és ha kinyitottam volna se érteném.]
@thon[Azért csak írtam az AIDE communitybe. Majd meglátjuk. A PDF-ek nagyon jók, megint lényegre tapintottál. Én speciel mindkét témát aránylag ismerem (az egyik onkológia, a másik működéstan {rendszeresen csak Pécsett és Pesten elérhető vizsgálat, utóbbi jórészt hm. nem feltétlenül OEP támogatott forrásból}); de csodálkoznék, ha nem tudnám megszámolni két kezem kis ujjain, akik kicsiny hazánkban ugyanígy vannak...]
@lad[Én ugyan nem tapintottam sehova. Tapintani, az a Te feladatod. Halvány fogalmam sincs, mi van a könyvekben, és ha kiolvasnám őket, se lenne is halvány fogalmam továbbra se. Csak szembejöttek és elkaptam őket.]

@s5[December hetedikei változat]

@app[151207] 
@thon[Give it a try! Miku késett egy kicsit, de elvileg működik az unicode törlés és a selected törlés is. Az egészet az "első" módszerrel, de az még nincs kellőképpen belőve.]
@lad[Vauuu, ez hiányzott belőle, de jó!]
@thon[Kérés: rengeteg editoron ki kéne próbálni. Pl. egy szörnyedelmes (pedig fontos lenne): AIDE. Semmi visszajelzés nincs, csak a bemenő szöveget fogadja. Azért nézd meg, miket csinál! A gond, hogy nem tudom, mikor (vagy melyik) editor nem hajlandó együttműködni a keyboard-dal.]
@lad[Az a gond, hogy nem is létezik olyan rengeteg editor. Jotából kétféle, AIDE, Fiinote, Chrome-ban szövegdoboz, Facebook, Messenger, K-Mail, keresődobozok különféle programokban, bár az szerintem rendszerből jön és ha egyiket kipróbáltam, mindet kipróbáltam… van még egypár editor, amik mint szoftverek nem használhatók, de persze egy próbát egér… más egyéb nemigen. Végig fogok mönni rajtuk és jelentek.]

@s5[Fontos kérdés: kurzor-ellenőrzés]

@thon[A helyzet a következő: beírsz/törölsz valamit, akkor a kurzor elmozdul. Ezt kissé véletlenszerűen az editor néha visszajelzi. Gond a következő: nem tudom, hogy a beírás ténylegesen megtörtént-e, mert nem tudom (nem tudhatom) biztosan, hogy a kurzor hol van. Viszont valahol mégiscsak ellenőriznem kellene, mert az érintéssel történő mozgást meg nem tudom meg máshonnan, csak a kurzormozgásból. Márpedig az minden tárolt adatot érvénytelenít.  Megoldási ötletek:
1. Mindig ellenőrzöm a kurzor körüli szöveget (pl. akkor is, amikor épp beírtam valamit és a körzés rögtön azt változtatja). Ez biztonságos, de nagyon energia- és időigényes, a lekérdezés lehet nagyon lassú is.
2. Tárolom a beírt szöveget, és feltételezem, hogy az beírásra is került. Itt lesz egy "időkapcsoló". Vagyis: elkezdek egy bonyolult műveletet: pl. törlöm az előzőt, beírom az újat - ezen idő alatt nincs ellenőrzés. Ha a művelet befejeződött, akkor viszont van ellenőrzés, így tudom azonosítani az érintéseket. Ez a módszer gyors, egyszerű, de könnyen hibázhat pl. ha csak numerikus elemek megengedettek a mezőben.
Vélemény? Én nem tartanék nagyon a hibáktól egyébként.]
@lad[Ha az első módszer annyira időigényes, hogy lassúbb gépeken már a jószág használhatóságát veszélyezteti, akkor a másodikra szavazok. Ha nem, akkor az elsőre, mert biztonságosabb.]

@s5[November harmincadikai változat]

@app[151130] 
@thon[Jól van, na. Elfelejtettem átírni a számot. Most viszont töltsd le újból, javítottam a hibákat. Kékcsíktalanítható (ezt is elfelejtettem). És tudja ezt: 
BUTTON ( TEXT 'v' SECOND ( TEXT "vakond" ) COLOR blue ) 
No nem mindenben valamiért, de a sárga jotában működőképesnek tűnik. Amúgy ez egy elég komoly feladat volt, kár hogy nem annyira látványos, mint amennyit dolgozni kellett vele... Az üres gombok: azok azért kellenek, hogy kipróbáld, hogy a körzés a gombon változtatja a feliratot. Ha viszont lemész róla az üres területre (üres, nem space!), akkor nem váltogat, viszont - még - nem ereszti el a gombot. Ez azért jó, mert amíg a másik gomb közepét nem éred el, addig nem vált át. Viszont: a gombok között anélkül tudsz utazni, hogy közben az eredeti gomb szövegét változtatná. De kipróbálni könnyebb, mint elmagyarázni. Ez így jó lesz, hidd el:)]
@lad[Ez nagyon baba! Rátettem betűgombokra, hogy Vanessa, Françoise, Beaulieu meg D’Aubisson (nini, itt krómban is mögy), és isteni szépen csinálja. Javaslat: a DEFAULT utasításban egy SECOND paraméter, aki megmondja, hogy mi legyen az alapértelmezés. CAPS: android→Android→ANDROID. ALLCAPS: android→ANDROID. FIRSTCAPS: android→Android →android. Egybetűs gomboknál a három ugyanaz. DOUBLE: kkeettőőzzii a betűt. BOARD //id:// másik boardról veszi az adott gomb jelentését (írásjeles gombokon másik írásjel). OFF: nincs második funkció.]
@thon[Ja, én is ilyesmin töröm a fejem, csak ez megint nem teljesen egyszerű. De tegyük be az óhajok közé.]

@s5[November 18-ai változat]

@app[151118] 
@thon[A hétvége terméke: működik a körzés, próbáld ki egy-karakteres és több-karakteres billentyűn is! Pl. "android"! Nem nagyon fejlett, pl. az "(a)"-t is több karakternek veszi, emiatt először az első, aztán az összes betűt változtatja. Ebből a második lépés persze értelmetlen. A körözés nem marad abba, amíg más betű nem lesz aktív, de az "utazásnál" nem számol. Nézd meg, ha üres billentyűkkel veszed körül (és azokon is körzőzöl), akkor mi történik!]
@lad[Szerintem nagyon klassz, lehet rajzolni sok-sok karikákat a gombra vagy a gomb köré és minden tele lösz lila pöttyökkel, de mi kell ahhoz, hogy történjen is valami? Mert csak a gomb sima, eredeti funkcicóját kapom tökéletes minőségben.]
@thon[KIZÁRÓLAG STRINGEN BELÜL!! (Mert ugye string) létezik a "$unicode" szekvencia. Vagyis $ és egy max hatjegyű hexa szám. Az első nem-hexa karakterig számol, de ha írni akarsz mögé pl. egy számot, akkor ki kell írd mind a hat számjegyet! Azért indul a tokenizer, hogy próbálgathasd. Cserébe a szerkesztés viszont még mindig nem az igazi; különösen a kurzor mögötti részen. Ja, az escape szekvenciák persze ismerik a blackslash$ -t is, ami dollár lesz. Ez viszont karakterben is működik. Amúgy a $ bármire módosítható, de egyszerűbb, ha egyetlen karakter.]
@lad[Öööö… én csinálok valamit rosszul? ''button (text "$1f608")'' – eredmény egy gomb, amire rá van írva, hogy $1f608. Ha kiírom a nyitó nullát, akkor azt is ráírja.]
@thon[ÉS még játszottam, lett DO SETTINGS, ami - elvileg - meghívja a beállításokat. Gyakorlatilag is meghívja, csak mintha nem mindig menne jól vissza...]
@lad[Izé… ööö…]
@lad[Puff. Te átvertél engömet, főorvos úr. Ez nem az. Belinkölted a tizennyolcadikai programot, a beteg nem figyeli a számot, gyanútlanul letölti, fölraki ugyanannak a helyére ugyanazt, aztán nem érti, hogy miért nem törpénik semmi. Most már érti… Szóval körözésre kapok nagybötűt, további körözésre megint kisbötűt. Egy android feliratú gombon előbb Android, aztán ANDROID lesz belőle, üres billentyűkkel körülvéve nem történik semmi… illetve szóközök legyenek? Pillanat. Körberaktam szóközökkel, nem történik semmi különös, ha a szóközökön körözök (szókörözök), akkor szóközök jönnek, ha a gombon, akkor váltogati a különféle betűs Android feliratokat. A dolláros dolog szépen működik, a settings gomb is, nekem nem jajgat, hogy nem talál vissza vagy bármi, a settingset becsukva visszakapom a szövegszerkesztőmet a billezettel, ahogy köll.]
@thon[ÉS még az is módosult, hogy amikor visszatöltjük az asset-et a settingsben, akkor be is állítja az eredeti file-t meg az erdeti directory-t.]
@lad[Ez nagyszerű, bárcsak érteném.]
@e[És kérek visszajelzést!!! Elragadtatott hurrá pl, vagy ilyesmi...]
@lad[Elragadtatott hurrá. A körözés jelentését át lehet majd definiálni? Például a gomb simán azt írja ki, hogy „tejfölös túró”, de ha körözök, akkor „körözött”. Vagy mit tudom én. A dollárjeles bütyköt mindjárt beírom a dokumentációba, nehogy kimaradjon, jut eszömbe, valahol nem volt nekünk egy lista a \ funkciókról, \n, \r, \t… ezeket is bele kéne írnom.]
@lad[Ja, és kérem szépen kékcsíktalanítani, mert jelenleg egy elpusztult Windows 95-re emlékeztető színű csík van az alján és takari a gombok felét. Ha bekapcsolom a monitor row-t, akkor legalább nem takari.]

@s5[Editor visszajelzési probléma]

@thon[Őrlődök itt egy ideje körbe-körbe. A nagy gond az, hogy a teljes billentyűzet úgy működik, mint egy hardver bill.: elküldi a szöveget, aztán nem tudja, hogy a rendszer felhasználta-e. Nem igazán tudom így megoldani az összes változtatós részt, bár igyekszem. Jelenleg csak annyit lehet tenni, hogy feltételezzük, hogy a rendszer megkapta ÉS felhasználta az elküldött anyagot. API21 felett (5.0) lesz egy metódus, ami legalább a kurzorpozíciót visszajelzi. Igaz, azt nem mondja meg, hogy mit írtunk, csak azt, hogy mennyit. Maradunk a feltételezéseknél, ami sokszor (pl. szám mező) nem jó.]
@lad[Ha sokáig őrlődsz, még bekerülsz a bejglibe. Kár volna. Hozott anyagból dolgozol, egy lökött oprendszerben, ahol mindenfelé falakba ütközöl. Ezzel nem lehet mit tenni, tudomásul kell venni.]
@thon[Nem leszek sem bejgli, sem palacsinta! Megoldottam a keleti kérdést! Persze nem tökéletes, no de mi lenne az? Feltételezzük, hogy minden beírt szöveg eljut az editorig. Minden beírásnál számolja, hogy hol kéne legyen a kurzor. Ha ez nem stimmel a kurzor pozíciójával, amikor az változik (erről ugyanis értesít a rendszer), akkor érvényteleníti a tárolt szöveget. Hibalehetőség: csak szám engedélyezett a mezőben. A mező most "1234". Elküldjük "abc", de nem történik semmi, mert ez nem szám. MIvel kurzor nem mozdul, nem kapunk értesítést. Majd átváltoztatjuk "abc"-t "987"-re. Ekkor - mivel a program úgy tudja, hogy be lett írva a négy betű -, törli az utolsó 3 karaktert, marad "1" és hozzáteszi: "987", vagyis az eredmény: "1234987" helyett "1987". Ezzel a hibával jelenleg együtt kell élnünk.]
@lad[No látod, már se leszöl része az ünnepi menünek.]

@app[151118] @thon[Nekiláttam a gombok másodlagos funkciójának. Ez még nem tökéletes, de a preferences bővült, pl. a repeat ideje már beállítható. Ezért gondoltam, addig ezt is felteszem.]
@lad[Vau, ez megint klassz dolog, kipróbáltam nullától ezerig többféle értéket, végül a százötvennél maradtam. Hasznos lesz azoknak, akiknek túl gyors vagy túl lassú a gyári beállítás.]

@s5[Javított board-váltás]

@app[151116]
@thon[Ezt töltsd le még egyszer!! Módosítottam egy kicsit, amit nem veszel ugyan észre, de most jó. Mivel a Te szempontból ugyanaz, nem csináltam a-b-c stb. változatot, rátöltöttem az előzőre. FONTOS!! A debug-ot kapcsold ki a preferencesben, mert ez iszonyatosan termeli, minden érintésre ír tíz sort. Ez fontos, és lehet, hogy be is kell kapcsolni majd; de az éles használatban be fog lassulni.!!!! Úgyhogy, most kapcsold ki.]
@lad[Jaj, ezt már tegnap letöltöttem, csak elfelejtettem törölni a pöttyöket. Tényleg nem látok semmi változást.]
@thon[Nézd meg a kompleton.txt 3. (mini) boardját PORTRAIT nézetben! A szimbólum-váltó mellett van egy pont (ABR) felirattal. Húzd a váltóról az ujjad nyugatra: vált és írja a pontot, majd ha felemeled az ujjad, akkor visszatér az alap-board-ra. Jó mi? Mert a "sima" pont rögtön ír egy space-t is maga után, és így nehéz beírni a webcímet. A változás annyi, hogy eddig megmaradt ilyenkor a lila vonal, most meg eltűnik. Kicsit szebb. Bár nem feltűnő változás :)]

@thon[Kéretik próbálgatni. A type utáni automata visszaváltás is megy, ill. a META billentyű is addig ragaszkodik, amíg el nem mozdulsz az "alatta" lévő billentyűről. És egy időzítési hibát is kijavítottam, ami a néha előforduló felborulás oka lehetett. A többit majd később tudom végignézni.]
@lad[Ez jóóó! Jelenleg a mindennapokban a legzavaróbb hiba talán az, hogy kijelölt szöveget a törlőgomb nem töröl, hanem az előtte levő karaktert törli.]
@thon[Tudom. Ez csak időhiány miatt van még így. Egyáltalán nem figyeli a kijelölést, ez még hiányzik.]

@s5[BMP feletti karakterek]

@lad[De nem értem, mi a gond a BMP feletti karakterekkel. Nemrég rátettem néhányat a gombozatomra, a szkennelés alatt levő könyvek listájában jelölgetek velük, nagyon praktikusak – hibátlanul megjelennek a Jotában, az előző verzióval is, ezzel is. Ha úgy érted, hogy ezeket a karaktereket törölni két gombnyomás, az stimmel, eddig is így volt, engem nem zavar.]
@lad[Első megfigyelés: mint nemrég konstatáltuk, ha direkte beírok egy BMP fölötti Unicode karaktert, az remekül megjelenik, csak stringnek kell tekinteni és macskakörmök közé tenni. Ha viszont escape segítségével teszem, akkor biza nem: az U+1F0CF karakter egy ilyen 🃏 dzsóker kártyalap, viszont ''text "\1f0cf"'' eredménye Ἄf, vagyis egy verzál alfa pszili oxia, azaz az U+1F0C kódú karakter, és egy f betű. Ez így inkontinencia! Jó lenne mindkét típusú karaktert mindkét módon elérni.]
Két észrevétel:
@thon[Android alatt a BMP feletti rész KÉT karakter. Mivel az escape szekvencia egy karaktert azonosít, ezért pontosan 4 számjegyű. (Megkerülni két módon lehet: az escape szekvencia egy stringet ad vissza, és nem karaktert. Vagy: lesz egy speciális escape-szerű szekvencia unicode jelölésre 8 számjeggyel.) Amíg ez elkészül - igazából az elvét sem látom át -, addig KÉT karaktert kell megadni, akár KÉT négyszámjegyű escape szekvenciával. Nem lehet köztük space!]
@lad[Világos. Valószínűleg a speciális escape-szerű szekvencia lesz a megoldás, mondjuk \(1f0cf) formában, ahol a zárójel mutatja, hogy egészen a következő zárójelig hexakód lesz.]
@thon[Mivel nem tudom, hogy karakter, vagy két karakterből álló unicode jön, ezért sem a számolás, sem a törlés nem precíz. A beírás biztos, hogy megy, de utána megkeveredhet. Ez könnyen orvosolható: egy másik pozíciót kell megérinteni, aztán visszamenni, akkor ugyanis törlődnek a tárolt adatok.]
@lad[Szerintem nem zavaró.]

@e[Kérdés: Meg tudod mondani, hogyan van a pontos konverzió? Ezt nem tudom, miként hívják. De két 16 bites érték tárolja a 4 byte-os unicode-ot. Az a kérdés, hogy honnan lehet megtudni, hogy ez egy db 4 byte-os  unicode karakter, vagy két db, különálló karakter. Ill. az is, hogy a nyolc byte-ot miként alakítom kétszer négy byte-ra (na jó, ez talán megy), de miként ellenőrzöm, hogy ez vajon valid-e.]
@lad[Utánanézek.]
@lad[Azt hiszem, erre lehet szükséged, én még csak próbálom megérteni…]

Q: What’s the algorithm to convert from UTF-16 to character codes?

A: The Unicode Standard used to contain a short algorithm, now there is just a bit distribution table. Here are three short code snippets that translate the information from the bit distribution table into C code that will convert to and from UTF-16.

Using the following type definitions

  typedef unsigned int16 UTF16;
  typedef unsigned int32 UTF32;
the first snippet calculates the high (or leading) surrogate from a character code C.

  const UTF16 HI_SURROGATE_START = 0xD800
  UTF16 X = (UTF16) C;
  UTF32 U = (C >> 16) & ((1 << 5) - 1);
  UTF16 W = (UTF16) U - 1;
  UTF16 HiSurrogate = HI_SURROGATE_START | (W << 6) | X >> 10;
where X, U and W correspond to the labels used in Table 3-5 UTF-16 Bit Distribution. The next snippet does the same for the low surrogate.

  const UTF16 LO_SURROGATE_START = 0xDC00
  UTF16 X = (UTF16) C;
  UTF16 LoSurrogate = (UTF16) (LO_SURROGATE_START | X & ((1 << 10) - 1));
Finally, the reverse, where hi and lo are the high and low surrogate, and C the resulting character

  UTF32 X = (hi & ((1 << 6) -1)) << 10 | lo & ((1 << 10) -1);
  UTF32 W = (hi >> 6) & ((1 << 5) - 1);
  UTF32 U = W + 1;
  UTF32 C = U << 16 | X;
A caller would need to ensure that C, hi, and lo are in the appropriate ranges. [AF]

Q: Isn’t there a simpler way to do this?

A: There is a much simpler computation that does not try to follow the bit distribution table.

  // constants
  const UTF32 LEAD_OFFSET = 0xD800 - (0x10000 >> 10);
  const UTF32 SURROGATE_OFFSET = 0x10000 - (0xD800 << 10) - 0xDC00;

  // computations
  UTF16 lead = LEAD_OFFSET + (codepoint >> 10);
  UTF16 trail = 0xDC00 + (codepoint & 0x3FF);

  UTF32 codepoint = (lead << 10) + trail + SURROGATE_OFFSET;

A szöveg forrása: http://www.unicode.org/faq/utf_bom.html

@thon[Csak hogy jól értem-e:]

Az UTF-16 (UCS-2) 16 biten, 0-FFFF-ig ábrázol. A D800-DFFF-ig terület fenntartott a 32 bites ábrázoláshoz.
Ha UTF-16 alatt akarunk 32 bites ábrázolást végezni, akkor D800-hoz, ill DC00-hoz adjuk hozzá a 2x10 bitet, így kapunk még egyszer FFFF-nyi területet.
Binárisan még nem számoltam ezt teljesen át, de a lényeg:

Ha egy byte D800-DBFF közé esik, akkor a két-byte-os ábrázolás HIGH byte-ja, ha DC00-DFFF közé esik, akkor a LOW byte-ja, minden más esetben 16 bites unicode karakter. @thon[Ez igaz?]

@lad[Bár tudnám, de én és a matek… Mi lenne, ha kipróbálnád a gyakorlatban? Vegyél egypár karaktert mondjuk pont U+10000-tól, az a lineáris B szótagírás, konvertáld be a karaktereket UTF szöveggé, add oda a szövegszerkesztőnek és nézd meg a Code2000 fonttal. Ha kapol lineáris B jeleket, nyertünk.]

@thon[Átszámoltam. Papíron. Miután rájöttem, hogy FFFF+1 az nem 10FFFF, hanem 1FFFF, akkor rájöttem arra is, hogy ez tényleg igaz. Van egy 16 bites terület (0-FFFF) és van egy 20 bites terület (1 0000-10 FFFF - merthogy ez az egész 10000-val el van tolva. Amúgy 0-F FFFF-et fedne le, ami 20 bit.) Na, ezt a 20 bitet tesszük be a D800-DFFF területre - vagyis a bináris 11011... ........ kezdetűre. Következő bit jelentése: ALSÓ/FÖLSŐ, aztán van még pont 10 bit, ami a fenti 20 fele. Na ez így tök jó. Egy nagy bajom van: a doksi azt írja, hogy hiába tiltott a D800-DFFF terület, azért azt mindenki használja. Ez nagyon jó. De én vagy kitiltom, vagy nem tudom igazán jól megcsinálni...]
@lad[Hát búgócsiga legyek, ha ebből egy árva kukkot is értek. Kezdve ott, hogy FFFF+1 az nem 1FFFF, de nem is 10FFFF, hanem 10000.]
@thon[Na igen, annál inkább :) Szóval, arra gondoltam. 10000. A lényeg: más az az int, ami a BMP-t, és más az a kettő, ami a felette levőt kódolja. Olyannyira, hogyha mutatsz egy word-ot, akkor megmondom, hogy melyiket kódolja.]
@lad[Ez idáig nagyszerű, mármost mi következik mindebből a mi szövegkezelési problémánkra nézvéstileg?]
@thon[Hát az, hogy meg tudom írni a teljes unicode-ra az elküldött betűk számontartását. Pl a modify is működhet így unicode-val :)]

@s5[Dokumentáció]

@lad[Végre rávetődtem a dokumentáci
óra megint.]
@lad[Kérdés. ] [[http://lattilad.org/vicky/doku.php/bestboard/optimized_layouts|Ezen]] @lad[az oldalon fogjuk összegyűjteni az egyes nyelvekhez kifejlesztett optimalizált kiosztásokat. Egyelőre csak négy darab van, és annak a fele is copyrightos. Szerinted kitehetjük-e őket Palmról vett képként?]
@thon[Sztem. ha egy volt programból származó képet hivatkozással kiteszünk, az nem copyright törés. Az más kérdés, hogy erre a program képes. Szerintem akkor lenne copyright konfliktus, ha a program beépítetten tudná (program részéről), vagy ha Te megosztanád a programhoz tartozó coat file-t (a megosztó részéről). A kérdés, hogy a hatszög billentyű nem áll-e védelem alatt. De szerintem levédeni csak egy konkrét dolgot lehet, tehát pl. egy teljes kiosztást. Ezt valahogy meg kéne tudakolni vagy olvasni.]
@lad[Megpróbálok utánajárni.]
@lad[Hát végül is képet akarunk csak kitenni.]
@lad[Ugye jól tudom, hogy a stringmódosítók még nem vannak beépítve?]
@thon[A mik?]
@lad[Alias rövidítéskezelők, vagyis az olyan módosítógomb, ami mondjuk a „csskd” szöveg után megnyomva előállítja azt a szöveget, hogy Csámcsogi Abaújné született Spacc Kisztihand Delikátesz.]
@thon[Gondolkodtam a dolgon, ezeket külön file-ból kéne venni. Nem nehéz, de relatíve sok munka, addig a MODIFY használható hasonlóan; pl. a "csskd" után a "Csámcsogi..." szöveget megadva. Azon amúgy is gondolkodni kellene, hogy a rövidítéseket automatikusan, vagy egy zárógomb (pl. pont) leütésekor helyettesítse be.]
@lad[Lehet külön file-ból is, bár én igazából nem látom a jelentőségét; amit a külön file-ba írsz, a Coatba is írhatod. De lehet akárhogy. A rövidítéseket ne csináljuk automatikusan, mert akkor nem lehetnek például egybetűs rövidítések, sőt a két-három betűseknél is vigyázni kell, hogy ne fordulhassanak elő a szövegben. (Mondjuk a nevemet nem rövidíthetem úgy, hogy lad, mert szerepel a halad, szalad igében; ha viszont előírjuk, hogy teljes szónak kell lennie, akkor a //természet// rövidítése nem alkalmazható az //anyatermészet// leírásához.) De ne pont legyen a zárógomb, hanem a módosító. Szintén azért, mert ha a rövidítés mondat végén szerepel a szövegben, nem tudod leírni. Szerintem a módosítógomb használata tiszta helyzetet teremt, leírod a rövidítést (akármilyen karakterekkel), megnyomod a módosítót, világos, hogy ki akarod bontani a módosítót. Célszerű, ha a rövidítésgomb egyúttal a jelenlegi módosító feladatait is ellátja, vagyis igazából a jelenlegi módosítót bővítjük ki rövidítéskezeléssel, mert így nem kell külön gombot rakni a billezetre.\\ Valahogy így képzelem a működését:]
  - definiálsz egy módosítót, mondjuk ''addmodify (id grave ignorespace rolls ("AÀ" "EÈ" "IÌ" "NǸ" "OÒ" "UÙ" "WẀ" "YỲ"…) abbr (sep ":" "lad:Láng Attila D." "中:中華人民共和國"))''
  - tehát ''ROLLS'' a régifajta módosító, ''ABBR'' az új. Minden egyes ''ABBR''-ban van egy ''SEP'', ami megmondja, hogy abban a csomagban mi az elválasztójel; ez választja el a rövidítést és a kibontott szöveget, ami egyazon idézőjelben áll, mert ha nem, akkor nincs meg a kapcsolat közöttük
  - beírod a rövidítést, megnyomod a kérdéses módosítót, és jön a kibontott szöveg. Kész a kocsi.

@lad[Nos, elég nagy darabot megcsináltam a nyelven kívüli részéből.] [[http://lattilad.org/vicky/doku.php/bestboard/start|Itt van.]]
@thon[Csak azt tudom mondani: beautiful! Viszont: ]http://www.shuminzhai.com/ATOMIK.htm[ A. Pruss csak ezt valósította meg; mindkét nevet bele kéne írni. Pl. Shumin Zhai ötlete nyomán, vagy ilyesmi.]
@lad[Ja igen. Tudtam, hogy valaminek utána akarok nézni. Köszönöm, beleírom.]

Hoztam egy linket, ezeket a kiosztásokat majd megnézem alaposan. http://fiveforks.com/ted/2006/11/graffiti_alternative/

@s5[Új board-mérés, critical error]

@app[151113]@thon[Board mérések optimalizálása kész ÉS van critical error visszajelzés is. Megjegyzem, a kinesa-ban is van nyolc hiba, csak nem néztem meg, hogy mi. A coat.log-ot érdemes átböngészni "ERROR"-ra keresve. Valószínű apróbb elütés. Ja, igen! CRITICAL ERROR alig-alig van: 1. Nincs meg a file, 2. IO-hiba, praktikusan nincs sd kártya (ez a másolásnál már kiderül - elvileg), 3. nem coat-file, vagy legalábbis a verzió nem stimmel, 4. egyáltalán nincs board definiálva (ez akkor igen el van rontva, mert ha nem választasz boardot, akkor választ maga. Szóval, itt tényleg nincs. 5. CANCEL: megszakítottuk a feldolgozást, mert pl. másikat indítottunk. Ez igazából nem hiba, de board ilyenkor se lesz. Próbáld ki, hogy törlöd a filet/nem azt adod meg stb.]
@lad[Azok valójában nem errorok, hanem warningok (kellene hogy legyenek). Amikor újradefiniálsz egy gombot vagy változónevet, azt errornak veszi.]
@thon[Ez definíció kérdése. A nyelv NEM engedi meg egy konstans újradefiniálását, mert félreértésekhez vezethet. Viszont kétségtelen, egyszerűbb a konstans megváltoztatása, mint mindenütt kicserélni. Javaslatom: Ide is be kéne írni, hogy tényleg meg akarom változtatni, és akkor nem ad hibát, különben meg hibát ad. Vagy ilyesmi. Ezt vegyük fel a TODOS-ba, mint megvitatandó témát.]
@lad[Akár egyből meg is vitathatjuk, nem szalad el. Egy programban a fejlesztő dönti el, hogy melyik azonosító konstans és melyik változó. Ez esetben Te. A konstans nem arról ismerszik meg, hogy a dokumentációba „konstansok” címen van bejegyözve, hanem hogy nem lehet megváltoztatni. Ezöket meg lehet. Tehát változók. Akkor meg minek sipákol?]
@thon[Hát pont ezért sipálol. Mert ezek a véleménye szerint konstansok. Az más kérdés, hogy emiatt a működése nem áll le, hanem megpróbál alkalmazkodni. Lényeg: szerintem ha ALMA egyszer "kerek, pirosat" jelöl, akkor többé nem írhatjuk azt, hogy "zöld és szögletes". Vagy legalábbis nem szerencsés, mert később a program egyes helyein nem tudjuk, hogy kerek és piros, vagy zöld és szögletes jön. A VÁLTOZÓ abban különbözik, hogy ott tudjuk, hogy változhat. De - mivel ez egy leírónyelv, ami konstansokkal tölti fel az adatokat -, a logika azt diktálja, hogy NE engedjük meg egy felhasználónak össze-vissza változtatni a konstansokat. Vagyis, ha egyszer ALMA kerek és piros, akkor után alegyen például a DOBOZ zöld és szögletes. És akkor nincs keveredés. Értem én, hogy másolásnál persze könnyebb ALMA definícióját megváltoztatni (bár nem szerencsés), de akkor írjuk oda pl. hogy FORCE vagy REDEFINE vagy ilyesmi, amire nem fog sipákolni. De a véletlen ismétlésnél szerintem igenis sipákoljon.]

@app[151112]@thon[Megjelenítés új alapokon: megoldódott a szélső gombócok problémája; működik a hide upper; és van monitor row is, ha ki akarunk valamit írni. Pl. sebességet. Persze, írni még nem tudunk. A teszt, sajnos, megint a Tied maradt, arra sosincs idő. Úgyhogy lehet, hogy nem működik :)]
@lad[Múkodik! Föltettem Klárika gépére, aztán újraindítottam az egész gépet. Eredmény: kék képernyő, kabátgomb, critical error. Nekiláttam összecsomagolni a _bestboard tartalmát, hogy elküldjem Neked, de miközben ezen ügyködtem, föléledt a program és megjelent a tyűzet. Szóval régi gépeken kicsit lassú, de mögy.]
@lad[Viszont a monitor row nem működik. Bekapcsoltam próbaképpen és vártam, hogy megjelenik a gép mellett egy monitor, az bármire jó löhetött volna, főleg ha modern. A régieket a világnak nem tudjuk eladni, csak a helyöt foglalják. De csak egy fekete csík jelent meg a képernyő alján, amit ha megböktem, elküldött egy Entert. Pedig fekete csíknak igazából a képernyő alsó és felső szélén kell megjelennie, mert a film szélesvásznú.]
@thon[Azért, ha critical error van, akkor még is jó lenne egy küldés, mert csak abból derül ki, hogy mi az. Ez is egy fontos dolog, a critical error (kevés van!) típusát ki kell írni. Másrészt a monitor nem küldhet entert, mert ott nincs gomb!]
@lad[Rendicsek, összeszödöm hamarosan a file-okat.]

@s5[5let megosztásra]

@thon[Mivel ez a változat már saját magától működik, megfontolandó lenne - noha rengeteg sebből vérzik - szűk körben megosztani. Az itteni megosztás adta az ötletet: mindent bemutatsz a blogban. Szigorúan, mint bemutatást - vagyis ilyesmin dolgozunk, vannak benne hibák, stb. - ezt is csatolni lehetne egy blogcikkhez, ugyanúgy, mint egy képet. Ha ott esetleg letölti valaki, hát annál jobb, ha érdeklődik is, akkor meg ide is elhívhatjuk. No, ezt csak azért gondoltam, mert ez a program már "megáll a lábán", de megvárhatjuk, amíg legalább a hide upper is javításra kerül.]
@lad[Még nem töltöttem le; mi az a hide upper?]
@thon[Ha letöltöd, kiderül :) A legfelső és legalsó "csúcs" levágható, ha helyszűkében vagyunk: pl. telefonon. De a legfelső levágásnál rossz rajzot csinál; újra kell törlteni, hogy jó legyen.]
@lad[Ja, ezt ismertem, már megvan egy ideje, de korábban ez remekül mönt.]
@thon[Megy is, ha újratöltöd. De enélkül is kéne.]
@lad[Egyébként részemről bármikor, Te mondod meg, hogy mikor érett mög a helyzet. Írok cikket és hadd mönjön.]
@thon[Igazából - mivel nem végleges a helyzet - bármikor. Amúgy talán frissíteni is lehet egy új változattal. Inkább olyanféleképp gondoltam, mint ahogy a kiosztást is megosztod, de ezt meg próbálgatni is lehet. Soha nem lesz tökéletes, már túl nagy ahhoz. Egyszer csak meg kell osztani; igazából a legfontosabb rész: Klárika gépén megy-e magától. Mert arra nem lesz idő, hogy passzintgatjuk mindenki gépéhez. Ha viszont magától megy, kipróbálják, letörlik. Visszadobom a kérdést: Szerintem egyikünk billentyűzete sem olyan, amit elsőre használni lehet: kéne egy sample billezet, meg legalább egy rövid leírás, amit odamásol.]
@lad[Hamarosan megnézem a gépén. Akkor alkossuk meg a coat_sample-t és mehet a nyalvánosság elé. Megírni a billezet az én feladatom lesz, csak a képességeiben állapodjunk meg. Javaslataim:]
    * szerepeljenek benne a program fontosabb funkciói: boardváltogatás, módosítók, autocaps, autospace
    * legyen két-három különböző méretű boardja, több ne nagyon, nem kell nagyon bonyolultnak lennie
    * legyen valódi használatra alkalmas, vagyis tartalmazzon minden fontosabb írásjelet, ami kellhet átlagos szöveg- és programíráshoz – de többet nemigen, illetve lásd lejjebb
    * legyen az alapnyelve az //angol,// hisz már az is csoda, ha worldwide találunk számottevő mennyiségű érdeklődőt, magyar alapokról indulva végképp nagyon nehéz – tehát nem Kinesa, hanem Alex Pruss valamelyik angol kiosztása (vagy esetleg többféle kiosztása, demonstrálandó, hogy ha nem tetszik, amit a felhasználó lát, láthat másfélét)
    * legyenek módosítói, tehát érje el a felhasználó a latin ékezetes betűket, demonstrálandó a módosítókat és erősítendő a nemzetköziséget
    * legyen rajta egy alternatív írásrendszer, ugyanezen okokból; például az ógörög, az kevés gomb, de sok módosító
    * legyenek rajta itt-ott magyarázó feliratok, például ;;r:← board switching;; vagy ;;g:diacritics →;;
    * ne legyen túl sok gombja boardonként, legyen esély, hogy nagyobbacska telefonokon is használható

@thon[Mindennel egyetértek, kivéve az angol kiosztással. Azok ugyanis jogvédettek. Vagy kell keresni olyat, ami nem az. Ehhez elég már egy billentyűt felcserélni talán, vagy ilyesmi. Amíg egyébként a saját oldalon van, talán ez se probléma, de minek másszunk bele bármibe előre. Pl.: QUONG] http://www.strout.net/info/ideas/hexinput.html
@lad[Nem tudtam, hogy jogvédettek. Az mondjuk mindegy, hogy milyen oldalon van, ami fönt van a neten, az fönt van a neten. Jó. De csinálhatunk saját angol kiosztást is.]
@thon[Az ATOMIK biztos, ezt egyébként maga Pruss írta valamelyik postban. Szóval javasolta, hogy csináljon valaki ilyet, csak fizetnie kell. Viszont a QUONG nem védett, sőt azt írja, hogy használják minnél többen - az oldalra való hivatkozással betehetjük. Sztem. egy jó angolt csinálni - elsősorban - túl sok idő.]
@lad[Hát az lehet. Jó, legyen QUONG.]

@thon[A KINESA a miénk! Vagyis a Tied. Az mindenképp legyen benne! Több file is lehet, legyen a KINESA az alternatívák között. Azt nem nehéz megoldani, hogy egy rövid help megjelenjen az első indításnál. Abban meg lehetnének a címek.]
@lad[Jó. Egyelőre összehozok egy komplett angolt, azt még csiszolgatni is kell meg minden, a Kinesával is lenne munka, mert a jelenlegi gombozat túl komplex.]
@thon[Faragd a kinesát! És ugyanabba tegyük be a QUONG elrendezést egy másik sample filebe, ami az elsőként induló lesz. Aki ezt használni akarja, az sokat fogja használni. (Ne felejtsd el, hogy a Palm használótábor egy válogatott csapat volt!) Ők pedig szívesebben használnak egy jobban optimalizáltat, mint egy tanulás nélküli, de kevésbé hatékony változatot. Szerintem.]
@lad[Faragni fogom. Mindazonáltal fölmeredt egy gondolat. Az Omnigloton már volt némi-mi-mi-mi-minimális érdeklődés. Esetleg meginterjúvolnám őket, hogy szerintük mit tegyek az indulócsomagba.]

@s5[November 10. Klárika gépére]

@app[151110]@thon[Már a módosított board kezelést használja, ezért a preferences azonnal érvényesül, nem kell újratölteni. Egy kivétel van: hide upper - ez konkrétan nem működik, nem szabad használni. Nem vettem ki, mert működni fog, csak addig is ezt el akartam küldeni. A preferences MINDENBEN a per mille/ezrelék értéket használja, vagyis 0-1000 közötti értékben gondolkodunk (még ha a határok kisebbek is). A debug is jelentősen módosult, de ez csak kódból állítható - minden rész külön debuggolható. Ez a működés követéséhez nagyon fontos. A assets mappa tartalmazza a hunglintesz.ttf, kinesa.txt és kompleton.txt file-okat, automatikusan a kinesa.txt-re áll. Kivettem a névből a verziószámot, ez lehet, hogy hülyeség volt. Persze akármikor vissza lehet tenni. Más módosításra nem emlékszem; persze köztes állapot, és nincs is rendesen (sehogy) tesztelve. De minden nem lehet tökéletes...]

@s5[Sokfeliratos gombok]

  - A boardok jellemzően két csoportba oszthatók. a) Írásrendszerek (görög, cirill stb.), amelyeket jellemzően hosszabb szövegekhez kapcsolnak be, és többnyire elég, ha az egyes gombokhoz rendelt betűk csak akkor válnak láthatóvá, amikor az adott boardot bekapcsoljuk. (Nem kell látnunk a latin betűs board valamely pontján az omegát kiírva, akkor is tudjuk, hogy a görög boardon kell keresni.) b) Jelcsoportok (matematikai jelek, tipográfiai jelek, emojik, előregyártott szövegek stb.), amelyek ha külön boardokon vannak, azokat jellemzően csak egy-két jel erejéig vesszük elő, és – ez a fontos része – ha egynél több ilyen board van a coatban, akkor nem adekvát, hogy melyik boardon kell keresni. Ez nyilván csomagfüggő, például ha egy coatban van külön matematikai board, akkor a matematikai jelek nyilván ott keresendők. Minket most ez a b) csoport érdekel, abból is a nem egyértelműen elkülönített, „vegyes” boardok, amik ha egynél többen vannak, akkor egy adott karakterről nem adekvát, hogy melyiken található.
  - Ha a felhasználónak szüksége van egy ritkán használt jelre, akkor tudnia kell, hogy melyik boardra kapcsoljon. Az adott gombot már megkeresi azután, de ha rossz boardot választott, az bosszúság. De mivel feliratozni csak gombokat lehet, nem boardokat, logikusan az egyes gombokon tüntetjük fel, hogy mely karakterek laknak rajta az egyes boardokon, oly módon (gombon belüli pozíció, betűszín), hogy az összefüggés az adott coat használójának világos legyen. 
  - Ez azonban bizonyos számú boardon felül elég sok többletmunka a tervezőnek. Minden egyes gombnál, amely a Speciális Írásjelek boardon szerepel, vissza kell mennie a rendes ábécés (például Kinesa) boardra, és elhelyezni egy ADDTITLE-t a megfelelő slottal és felirattal. Ráadásul ilyen boardból is lehet jó néhány. Ha ráadásul ezt később meg is kell változtatni, az egy őrület. 
  - Ezért elképzeltem egy funkciót a helyzet megoldására. Először is vezessük be a //boardcsoport// fogalmát, amely egyszerűen egy olyan azonosító, ami több boardra hivatkozik egyidejűleg. Ez voltaképpen a CURSOR utasítás továbbfejlesztése. Ahelyett, hogy CURSOR (ALSO egyikboard ROW 0 COLUMN 0), CURSOR (ALSO másikboard ROW 2 COLUMN 3), írjuk ezt: BOARDGROUP (csoportnév ADD (egyikboard ROW 0 COLUMN 0) ADD (másikboard ROW 2 COLUMN 3)), s ezután a CURSOR is használható úgy, hogy CURSOR (ALSO csoportnév). Persze egyazon board, illetve különböző koordinátákkal megjelölt részei több csoportban is szerepelhetnek, és a CURSOR aktiválhat csoportokat és egyes boardokat is. A csoportokkal máris elértünk egy könnyítést: ha vannak olyan gombseregek, amiket több boardhoz is hozzá kell adnunk, csak definiálunk egy csoportot és az egyes gombseregeknél csak erre hivatkozunk, így a későbbi változtatás sokkal egyszerűbb. 
  - Most jöhet a multifeliratozás. Vegyünk egy gombot, nevezzük Józsinak. Mi, akik a programot és a Coat file-t készítettük, tudjuk, hogy Józsi valójában nem létezik, mert ha hét különböző board van, amiken Józsi koordinátáira gomb van definiálva, akkor az hét különböző BUTTON utasítás, hét külön objektum – de a végfelhasználót ez nem érdekli, főleg amikor több azonos méretű boardon ugyanabban a színben, ugyanazzal vagy alig változó felirattal jelenik meg a gomb, ő ugyanazt az egy Józsit érzékeli. Tehát van a felhasználó által egyetlen Józsiként érzékelt hét gomb, amiknek a coatban semmi közük egymáshoz, hét teljesen különböző helyen vannak definiálva. Definiáljuk a hét boardot csoportként, legyen a neve Józsiék. Definiáljunk hét slotot, amelyek mindegyike más koordinátákra (középre, illetve a hat sarokba) pozicionálja a feliratot. 
  - Adjunk jelentést Józsinak, azaz a koordinátáira kerülő gombnak az egyik boardon, mondjuk azon, amelyiknek a tartalma a többi boardon a //felső// nevű slottal jelenik meg. Legyen az itteni tartalma egy kérdőjel. Írjuk ezt: BUTTON (TEXT '?' COLOR szín GROUPTITLE (Józsiék TEXT '?' SLOT felső)). 
  - Ekkor a program, igazolva nevét, miután létrehozta a jelenlegi boardon a gombot, végigmegy a Józsiék csoprt többi boardján; kihagyva minden olyan boardot, amik az érvényes CURSOR utasítások szerint aktívak. Az aktív boardok ugyebár kapnak egy kérdőjelet a default slot szerint, ami mondjuk középre helyezi és feketével írja. Ami viszont nem aktív, de szerepel a Józsiék csoportban, azokon a boardokon megkeresi az azonos koordinátákra eső gombot (hiszen mindegyiket koordinátákkal definiáltuk a csoportban, és tudjuk, hogy most hol vagyunk a kiindulóponthoz képest), és hozzáadja a GROUPTITLE-ben megadott paramétereket egy új ADDTITLE formájában. Így a //felső// slotot kapják, ami a felső sarokba teszi a jelet és mondjuk pirossal írja. 
  - A többi sarokba kerülő karaktereket hasonlóképpen definiáljuk a coat más-más részein, más-más slottal.
  - Eredmény: gombok sok-sok, a példabeli esetben hétféle felirattal, és a felhasználó tudni fogja, hogy egy adott jel vagy funkció eléréséhez melyik boardra kapcsoljon és ott mit nyomjon meg. 

@thon[Más megközelítésben már gondolkodtam ezen. A cél az lenne, hogy egy gombnév csak egy gombon szerepeljen. Az összes többi gombóc, amin még kiegészítésként rajta van, ugyanarra a gombra hivatkozzon. Hm. Egyébként azt nem tudom elképzelni, hogy ezt rajtad, na jó, kettőnkön kívül valaki valaha is megtanulná és használná...]
@lad[Azért vannak ám a BestBoardnál bonyolultabb szerkezetű programok is, amiket egy-két ember még használ a szerzőn kívül, sőt több. Például hogy billezeteknél maradjunk, az őrületesen bonyolult, kínkeserves Tavultesoft Keyman, amit utálok, soha nem voltam hajlandó használni – meglehetős felhasználótábort vonz, sok év óta több tízezres vagy ki tudja, mekkora tömeg használja, és a sokadik verziónál tart. Pedig ráadásul még fizetős is. Vagy például sok játéknak nemcsak játékosai vannak, hanem magánlelkesedésű továbbfejlesztői is, mint a Minecraft meg az openTTD, komplett csomagokat írnak a játékokhoz mindenféle célra. Az openTTD fejlesztői dokumentációjába egyszer belenéztem. Ha rajzolni akarsz egy képet, ami megjelenik a játékban, az egy dolog, hogy megrajzolod, de egymillió paramétert kell hozzá beállítani meg mindenféle jegyzékekbe bejegyezni meg a jóistenke jobban tudja, hogy még mi mindent, szóval kell hozzá elszántság és türelem – és a végeredmény az, hogy a meglevő kisvasút helyett mondjuk a pesti HÉV szaladgál icipiciben a képernyődön. Ezzel viszont írni lehet. Ez sokaknak probléma.]

@s5[Klárika gépén 2.]

@app[151104]@thon[ - ezt a változást már régen terveztük, de csak Klárika indított arra, hogy most ezzel foglalkozzak. A billentyűzet - még - nem változott. Viszont! Telepítéskor ellenőrzi, és létre is hozza a könyvtárat, valamint belemásol egy coat_sample.txt file-t, amit alapértelmezésben használ is. A preferencesben van egy gomb (a 4.), amivel ezt forszírozni is lehet. MIVEL EZ EGY TESZTVÁLTOZAT, A PREFERENCEST MINDEN INDÍTÁSNÁL TÖRLI!!]
@lad[Hamarosan meglesz, ő most pihen és nála van a gép; addig még megnézem a sajátomon. Közben írtam egy makrót, mert eluntam, hogy be kelljen mászni a feltöltött file-ok közé. Ha a programot úgy nevezed el, hogy ''app''//akármi//''.apk'', akkor írhatod, hogy ''`@app`[''//akármi//''`]'', és ad egy közvetlen linket a letöltéshez.]
@thon[Kérés: 1. nézd meg Klárika gépén mi történik, mit ír ki! Ha nem talál sd kártyát sem, akkor a toastban is ki fogja írni a hibát! 2. Bármilyen file betehető ugyanígy, akár sample, akár leírás. Nyilván egyet fogunk tudni alapértelmezetten megnyitni. Mindenesetre kérek fileokat v. ötleteket! 3. Küldd el, kérlek, mi a baj Klárika gépével! 4.1 felett mennie kell.]
@lad[Jelentem, semmi különöset. Panaszkodik hibákra, de azok énnálam is megvannak, nem hibátlan a programom, viszont lefut. Klárikánál is. Mögy! Nagy vagy! Viszont lesz egy problémája. Miután ezt a kiosztást valamennyire megismerte, lesz egy újraindítás és a másik kiosztást kapja helyette, és összezavarodik.]
@thon[És akkor miért nem lelte meg a Te könyvtáradat?]
@lad[Persze!]@thon[Hogy mi?]@lad[:D Szokásom kérdésekre igennel válaszolni, csak úgy maupassant, miközben az a válasz oda nem adekvát. Egyszer próbáld ki, csak ne beteggel. Egyébként] ;;pwm:halvány lilám sincs,;; @lad[miért nem lelte meg.]
@thon[Na mindegy. Ez csak egy tesztváltozat volt, küldd el azt a kiosztást, amit Klárika szeretne használni, és akkor azt teszem bele. Pl. ehhez kell az android studio, uis. becsomagolja a file-t (automatikusan) a telepítőcsomagba és kész.]
@lad[Bocsánat, erre teljesen rábambultam (javarészt külföldön voltam az utóbbi időben), föltettem kinesa21.txt néven.]
@coat[kinesa21.txt]

@s5[Andika]

@thon[Más: a régi géppel továbbra sem jutottak dűlőre, most engedélyt adtam arra, hogy fix áramforrásra kössék. Ehhez uis. szét kell szedni. Akksi ha nem is halott, de csak perceket bír... Jelen állapotában papírnehezéknek még jó.]
@lad[Döbbenet. A világ leghosszabb szerelése, ha azóta dolgoznak rajta, amióta náluk van, ezt ember nem fogja tudni már megfizetni. Amúgy azt hittem, hogy rég szétszedték.]
@thon[Sztem. nem dolgoznak rajta, csak nem akarják dolguk végezetlen visszaadni. Amikor rákérdezek, akkor mindig jön egy újabb ötlet...]

@s5[Symbol Shift]

@lad[Megint alakítottam a billezetemen, kiiktattam a //Shift, leírom a tulajdonnév kezdőbetűjét, föl kell emelni a ceruzát, különben nem jön több betű// problémát: szétválasztottam a másik boardra vezető Shiftet és a nagybetűs Shiftet, olyannyira, hogy a másik board most már direkt kisbetűket ad. Ezt a Shiftet elneveztem SYMBOL SHIFT-nek, a nagybetűset pedig CAPS SHIFT-nek, à la ZX Spectrum, szerintem gyorsulni fog ezzel a tulajdonnevek írása. A betvekre pedig lehet szimbólumokat tenni.]

@s5[Klárika gépén]

@lad[Mit csinálok rosszul, tisztelettel? Föl akartam tenni Klárika gépére az új programváltozatot, merthogy a régi nem találja a billezetet reset után, és ha lemerül a gép, akkor reset van. Szóval föltettem háromféle buildet is, a legutóbbi sivákol, hogy ő sajnos leállt, az előző kettő pedig kabátgombot mutat és kiírja a logba, hogy nem találja a Coat file-t. Pedig ''sdcard/_bestboard/coat.txt'', istók zicsi, ötször ellenőriztem.]
@thon[Nincs neki egy "belső" sd-kártyája? Az ES Explorer hány kártyát lát? Nálam pl. emulated ill. 0 és ilyen neveken szerepel, igaz, a "külső" sem sdcard, hanem extSdCard. A program bekéri azt, amit a gép sd-kártyának tekint, de az nem biztos, hogy ugyanaz, mint amit pl. a pc lát rajta. Viszont a logot oda menti el, úgyhogy meg kell keresni a log fileokat. Azok benne vannak ebben a könyvtárban? Ja, és lehet, hogy azok még coat.descriptor-t kerestek, nem?]
@lad[De lehet, minden lehet, de azzal se megy. Leáll. 4.1.1-es Android, lehet, hogy nem kompatibilis?]
@thon[app151030.apk Teljes mértékben nem volt időm ellenőrizni, de a DRAFT és a preferences résznek is működnie kell. Ebben a preferencesből látod, hogy megtalálja-e a file-t. Ha nyavajog, akkor kérem a teljes _bestboard mappát zip-ben, valamint - ha vannak - akkor az alatta lévő mappaából a bestboard szerű logokat.]
@thon[Módosítok. app151031.apk. A preferencesben a file név alatt kiírja a teljes útvonalat, ahol keresi. Ha nincs meg, akkor a logban kiírja, hogy mit keresett volna. Mondjuk a log, az kell hozzá.]
@lad[Hamarosan kipróbálom, de Sweetie-n, Klárikáén nincs értelme. Mondjuk ő ellenne a tavalyival is, ha nem veszne el minden egyes reset után, és gyakran vannak resetek. Ő pedig nem tudja, hogy kell visszaállítani.]

@s5[Törölt projekt]

@thon[Puff neki. Véletlenül töröltem az egész projektet. Visszaállítani nem tudtam; még szerencse, hogy már githubon van az előző... Sok minden elveszett, de majd újraírom. Végső soron itt van a fejembe'. Azért nem hiányzott.]
@lad[Jézusmária! Mekkora változtatás veszett oda?]
@thon[Nyugi, nem vészes. Igazából rengeteget írtam, de egyik megoldás sem volt igazán jó, emiatt ugyanazt próbáltam többféle módon megközelíteni. Így végül nem jelentős a veszteség, mert csak az utolsó megoldást kell elkészítenem. ]
@lad[Huh.]
@thon[Ezek a beállítások nagyon nem egyszerűek. De már megvan a sablon, ennek mentén már bármilyen beállítást be fogunk tudni illeszteni. Sajnos, megint bele kell nyúljak a program szerkezetébe, de remélem, nem lesz radikális a változtatás... Szóval, csak írom, hogy ezen dolgozom. Nem lényegi dolgok talán, de hosszútávon nagyon fontosak. Nem. ALAPVETŐEK, hogy ezek egyértelműen működjenek.]

@s5[Október 22-i app]

@thon[Újabb apk app151022.apk néven. Vigyázat! tele van hibákkal, ez egy ideiglenes feltöltés. Viszont a coat descriptor, debug dolgok működnek (nincs teljesen ellenőrizve) a settingsben. És nem lesz nagy a log. (Kéretik ellenőrizni a sokat használóknak!) A képi dolgok egy része is működik, csak azok még újraindítást kívánnak (Pl. Force reload). Screen height ratio még nincs bekötve. Vertical offset ezres nagyságrendű, Outer rim százas!! Bármit mond!! Szóval azt óvatosan változtasd, sztem 20 és 80 között. Minden hibáról részletes beszámolót kérek, ha tudok róla, akkor is!]
@lad[Innen a hibalogokat kivágtam, mert szerkesztésnél akkor is hosszú és útban van; letettem őket legalulra.]
@lad[Nokéremszépen. Alsó-felső trim remekül működik. Outer rim százhoz közeli értékeinél a húzási funkció megszűnik, bepöttyözhetem az egész tyűzetet, akkor se fungál második gomb, csak az az egy, amire letettem a ceruzát. Ötvennél tök vígan át lehet húzni két gomb között a folyosón, nem lépnek életbe (srsrsrsr anélkül, hogy a vagy l megjelenne). Nullánál ez lehetetlen, az a vagy az l mindenképpen megnyomódik. A gombok pirosítása és a pöttyözés ki-be kapcsolható remekül. A vertical offset is nagyon jól működik, nullánál a gombozat kimegy bal szélre, ezernél jobb szélre, egy gond van. Akárhogy nézem, ez itten egy horizontal offset. Mivelhogy egy vízszintes vonal mentén mozgatod őtet…]
@thon[Azt amúgy is meg akartam kérni, hogy lektoráld :) A bal és jobb között se tudok különbséget tenni. Operálni "máj felőli" és "máj elleni" oldal szerint operálok, vezetni meg "kis ablak", "nagy ablak" szerint, márminthogy a kormánytól nézve mekkora. Ehhez képest a vertikális meg horizontális - bagatel.]
@lad[Le fogom ktorálni, persze, egyébként amelyik oldalon vezetsz, viszont nem kaphatsz appendicitiszt, az a bal.]

@thon[Na, hazértem. Ezért kellene az android studio meg a github, ugyanis nem tudom, melyik az "előző". Az apk persze megvan, de a kód már nincs.]
@lad[Szerintem nálam se lenne meg, úgyhogy…]
@thon[Szóval: 1. kérdés: az új apk működik-e, ill. mi nem működik benne.]
@lad[Egyszerűen critical errort kapok, kék képernyő, kabátgomb. De megpróbálom újra.]
@thon[2. kérdés: amit átküldtél, annak alapján valamelyik label hibás; nincs értéke. Ez elvileg lehetetlen, ezért kéne erről minden adat, coat, log stb. de az új apk-val. Másrészt ehhez a részhez nem nyúltam ezer éve, tehát a hiba régi, nem az újban van.]
@lad[Itt a coat is.]
@coat[kinesa20.txt]
@lad[Hoppá, most mögy! De hát nem változtattam semmit a világon!]
@thon[Ezt igen könnyű lesz megtalálni. Grrr. Ugyanis nálam is tökéletesen megy, csak nem olyan szép színes...]
@thon[Kérésem a következő: amint hiba van, az EGÉSZ _bestboard mappát másold ki valahová. Rögtön, újabb indítás nélkül. Három dolog kell ugyanis: maga a coat descriptor file, a bestboard log, ami a debug üzeneteket tartalmazza (többé nem lesz ilyen nagy), és a coat log, ami viszont a felhasználónak szól, abban van a parsing eredménye. Viszont az új tök jól működik, tudok váltani az enyém meg a Tiéd között!]
@lad[Jaj, a kiosztásváltást még ki se is próbáltam, pedig az a legfontosabb. Rendicsek, le fogok másolni mindenkit, a méret nem érdekes, mindenhol rengeteg hely van.]
@lad[Ez tündéri. Most már tényleg csak az van hátra ezön a térön, hogy a szövegszerkesztőből kilépéstelenül, listából választva lehessen coatot váltani, és az már harmadfokú tündéresedés.]

@s5[Notepad]

{{ notepad.jpg?500}}@lad[Hoztam egy képet. Így néz ki a billezetem forráskódja most,] [[https://notepad-plus-plus.org|Notepad++]]@lad[-ban. A nyelvi definícióba bevettem, hogy ''; begin'' jelentse behajtható szakasz (fold) elejét, ''; end'' pedig a végét. Innentől gombnyomásra kinyílnak és becsukódnak az ilyen sorok közé tett szakaszok, a címeket áttettem a nyitó sorokba, így azok is rögtön olvashatók. Az így letömörített listának ez nagyjából a fele. <del>Kérdés: lehet-e úgy írni a szabályt, hogy a ''COAT (2)'' fejlécnek nem az első sornak, hanem az első //nem '';''-vel kezdődő sornak// kelljen lennie? Akkor azt is betehetnénk egy ilyen foldba.</del> Miután megírtam a kérdést, rájöttem, hogy ki kellene próbálni úgy is. Úgy is megy!]
@thon[Persze, mert első utasításnak kell lennie, nem a legelejének. Egyébként most a Coat 0002-nél tartunk, lesz Coat 0003 is. A tényleges megvalósítás itt is az ezres nagyságrendet fogja használni: 1000 lesz, amit először elfogadunk véglegesnek. Ha az ezres változik, akkor nem is használható a másikkal, az alszámjegyek az alváltozatot jelölik, aminek a tudása növekedhetett, de kompatibilis.]
@lad[Jesszus.]
@thon[Nem, 3 után 1000 jön :) Amúgy nem mondtam a lényeget: én is akarok ilyet! Ez nagyon jó! De jedit-et kellene rávenni erre, mert az van linux alatt is. Avagy valami androidos szerkesztőt. De addig megelégszem ezzel is...]
@lad[Fölraktam, kinyomoztam. Ha a buffer optionsban a foldingot indentre állítod, és a becsukni való szakaszokat több-kevesebb szóközzel kezded, akkor működik ott is. Van egy kapcsos zárójeles megoldása is, ahhoz explicitre kell állítani, és működik akkor is, ha a kapcsos zárójeleket pontosvessző előzi meg, vagyis a Coat szintaxisával sem vész össze.]

@s5[Vándorló szegmensek]

{{ szegmens.png?500}}@lad[Beleestem a gondolkodóba. A mellékelt kép a félkész cirill kiosztásomról készült, a Coat program hetekkel ezelőtti átalakítása óta nincsen cirill, és már nélkülöztem. Hát nekiláttam rátenni. Mindent, ami közös a többi boarddal, ide is be''CURSOR''oztam, de hát egy teljes cirill kiosztáshoz a Kinesa ugye kevés, orosz, szerb, ukrán, macedón, belorusz minimum kellene, hát elmozdítottam az írásjeles szegmenst eggyel balra; ekkor készült a kép.]
@lad[Azért vagyok most benne a gondolkodóban, mert az ugyan látszik, hogy így se lesz elég gomb a hiányzó (љњџћђєѓґіїќў = 12) betűhöz, viszont az is látszik, hogy az írásjeles szegmenst föl kellene szeletelni. Merthogy a bal oldali négy sárga plusz egy világoskék gombnak el kell mozdulnia, az oké; a felső sor kérdőjeltől pontig terjedő gombjainak viszont nem lenne szabad mozdulni, eltakarták a felkiáltójelet és nincs is értelme elmozdítani őket; a jobb alsó sarokban a <>/ gomboknak pedig alighanem el kell tűnniük, hogy helyet csináljunk. Ők is takarnak amúgy két gombot. Mármost az világos, hogy akkor az egy szegmenst szétvágom háromfelé, Írásjelek Első, Második, Harmadik Csoport, shiftes változatokkal ez hat. De ezek már hivatkozva vannak mindenfelé. Azon töröm a fejemöt, nem lehetne-e ezt egyszerűbben.]
@lad[A másik gond a világoskék gomb a bal szélen. A többi boardon ez eggyel jobbra van, tehát teljes gomb. Itt elmozdítottam, félgomb lett belőle, a felirat olvashatótlanításával. De nem írhatok bele ''XOFFSET''-et, mert a többi boardon hülyén nézne ki. A megoldást az fogja jelenteni, hogy ez megint különálló, egygombos csoport lesz, de ez megint növeli a komplikációkat. Vajon lehet-e olyat, hogy ''XOFFSET 500'' legyen az alapértelmezés, ha a gomb bal oldali félgomb, illetve ''XOFFSET -500'', ha jobb oldali?]
@thon[Én emiatt az írásjeleket külön-külön állítom be. A tervben már benne van, hogy a button utólagosan is módosítható legyen (pl. a színe). Az addtitle nehezebb dió, mert arra nem tudunk hivatkozni. A program meg nem tudja, hogy ez egy fél gomb. Sőt nem is az, ld. elfordított képernyő. Hm-hm-hm. Ez nehéz dió, nem tudom.]
@lad[Kemény dió! A nehéz dió angolul van.]

@s5[CURSOR]

@lad[Javaslat: ''CURSOR (ROW y CURSOR x)'' utasítás, amelynek hatására a kurzor az összes éppen aktív boardon elvándorol a kívánt helyre. A ''NEXT'', ''NEXTROW'', ''SKIP'' és ''SKIPROW'' utasítások ugyanis csak jobbra és lefelé tudják mozgatni a kurzort, és ha egy nagy gombcsoport kiindulópontjához képest balra szeretnénk elhelyezni egy gombot (mert a későbbi szerkesztések során ott lett üres hely), akkor a) átmásoljuk az illetékes boardokat aktivizélő ''CURSOR'' utasításokat a plusz gombot elhelyező utasítás elé, ami azt okozza, hogy ha változik az érintett boardok jegyzéke, akkor két helyen kell már átírni, vagy b) az egész gombcsoport kiindulópontját helyezzük át, ami minden sorban igazítást fog kívánni, hogy továbbra is intakt maradjon a csoport. További javaslat: ''PREV'', ''PREVROW'', ''SKIPLEFT'' és ''SKIPUP'' utasítások az előző négy mintájára, ellenkező irányú mozgással. Sokszor célszerűbb lehet így relatívan mozogni, mint az abszolút mozgást jelentő ''CURSOR''.]
@thon[Erre már én is gondoltam. Sajnos, az egész megoldásunk fara-muci. A szó szoros értelmében, mert fordítva van, mint ahogy szoktuk meg. Egyetlen előnye, hogy így is minden leírható. Nomármostan. Azt találtam ki, hogy két menetben lesz az értelmezés. 1. létrehoz egy "adatbázist", ami igazából csak az utasításokat tartalmazza egyfajta belső assemblyben, majd 2. végrehajtja ezt az adatbázist. Ebben az esetben csinálhatunk komplett ágakat, amiket utóbb egyben fel lehet használni. Addig: vízzel fogunk főzni.]
@lad[Ez már átvezet egy elágazásokkal, ciklusokkal, szubrutinokkal dúsított hiperszupercsodanyelvhez, ami szerintem őrült nagy munka…]

@s5[Cirill]

@lad[No, elkészült a cirill kiosztás; megmutatom az omniglotosoknak.]
@png[cirill]

@s5[GitHub]

@thon[Ideiglenesen (próbaként) a teljes project megtalálható a https://github.com/Palmodroid/BestBoard oldalon! Érdemes lenne ugyanitt egy "lattilad.org" elnevezésű tároló létrehozása, ami kötődik ehhez az oldalhoz. Milyen e-mail lenne jó hozzá? Pl. android`@lattilad.org? ]
@lad[Vagy bestboard`@lattilad.org.]
@thon[Príma. A terv az, hogy már a tényleges name-space-szel csinálok egy harmadik BestBoard projektet, amibe az átnézett, dokumentált részek kerülnek. Azt fogom ide feltenni. Ha minden belekerült a mostani - fejlesztői - verzióból, akkor azt akár nyilvánosan is publikálhatjuk.]
@lad[Én meg még a felhasználói doksival se tartok sehol…]
@thon[Ami fontos lenne: egy működő Android Studio. Az ugyanis le tudná nyalni a github projektet, és a gépen tudná fordítani. Az .apk-t nem teszi be automatikusan a github-ba, persze kézzel még mindig betehetjük.]
@lad[Mármint nálam, gondolom. De végeredményben miért nem jó a jelenlegi felállás? Te vagy a program szerzője, Te fordítod a saját gépeden, aztán közzétesszük az apk-t.]
@thon[Igen és nem. A github jelenleg minden módosítás után frissül, azonnal lenne apk. Meg egy-egy részletet meg is tudnék mutatni. Egyébként viszont eddig is működött, eztán is fog :)]

@s5[HIBA!]

@thon[A 'DEL' (és nem backspace), tehát a DO DELETE beteg. valamiért a -2. karaktert szeretné kiszedni a string-ből, ami elég nehéz. Majd ügyködünk, de addig is tudjatok róla!]
@thon[Van gond. Ezt a hibát sem tudtam előidézni többet - a DO DRAFT-ra gyanakodok, de úgy se. Ha valaki lát ilyet, azonnal dokumentálja, legyen kedves. Konkrétan: PONTOSAN mi volt a szöveg, ahol előjött, mi volt a leütött bill., meg egy másolat a log file-okból. Köszi!]
@lad[Nekem jelenleg nincs is Delete gombom, de majd csinálok egyet.]
@lad[Csináltam. Jotában is, krómban is hibátlanul működik, azt töröl, amit kell. Viszont amíg ezt írtam, „unfortunately, BestBoard has stopped”. Érdekes fejlemény, eddig nem fordult elő, ezért most beírtam néhány fölös karaktert és Delete-tel töröltem őket. Aztán folytattam az írást, és csakhamar leállt megint.]
@lad[Viszont Jotában nem sikerült összeomlasztanom, pedig próbáltam.]
@thon[Majd én is próbálkozom. Szerintem a hiba a programon kívül van; valamit nem figyelek... jó lenne tudni, hogy mit.]

@lad[Én a shiftes dologgal szenvedek nagyon, valahogy folyton sikerül duplán megnyomnom, attól bezár, de nem lehet megint duplán megnyomni, hogy kinyisson, előbb meg kell nyomni valami egyebet…]
@thon[Egy hibát: amikor automatikusan visszatér a lapról, akkor megszakad a fonal; én is észleltem. Emellett is jó lenne, ha nem törölné az érintéseket. De a Te hibád mi is pontosan?]
@lad[Az én hibám a linkgombokkal van. A Shift link, hiszen metával nem tudom a vesszőt pluszjellé változtatni. Lock nélküli link. Ha véletlenül kétszer nyomom meg, a következők történnek. A billezet képe rendesen átvált nagyra, majd vissza kicsire. Ekkor megnyomok egy betűt, kisbetűvel kapom, de utána azonnal visszavált nagyra, és úgy marad. Megint meg kell nyomni a Shiftet kétszer, hogy visszakapjam a rendes működést. De ezt hiába próbálom a logban keresni, erről nem lesz hibaüzi, csak helytelen a program logikája.]
@thon[Oké, ez úgyis változni fog, akkor ilyen szempontból is letesztelem.]
@thon[Csinálj, kérlek, Te is egy "teszt" billentyűzetet, ahol csak ezeket nézzük! A teljes billezet ugyanis (mint láttad) iszonyatos debug anyagot generál, amiben jóval nehezebb megtalálni a hibás részt. Vagy egy nagyon pontos leírást, hogy én is elő tudjam idézni a hibát. Nekem uis. minden meta-billentyű a vártnak megfelelően reagál.]

@s5[Békák és egyéb színességek]

@matyi[nekem is szinesek a békák >) ]
@lad[👍]
@thon[...és én csak irigykedek...]
@lad[Szoftverfrissítés?]
@thon[Nem tartozik szorosan ide, de ez egy rootolt masina. A rootolás elengedhetetlen a fejlesztéshez, de onnét nincs több automatikus frissítés (mármint a samsung nem engedi). Kézi van, de sok vele a vesződség; eddig nem éreztem szükségét. Néhány színes mentőautót meg könnyen elnélkülözök. Ez egyébként filozófiai probléma: milyen gépen kell fejleszteni: a legalacsonyabb vagy a legmagasabb verziót célzó gépen. A legalacsonyabb: akkor azon (és utána) elvileg működni fog, a legmagasabb: a legújabb fejlesztésekkel is tesztelhető a program.]
@lad[Értelek. Persze Neked jön a színes mentőautó amúgy is, az hozza a munkát. Neköm anyám hordta haza vastag dossziékban.]

@s5[Felhasználók]

@thon[Még egy gondolatom támadott: tudsz olyat csinálni, hogy valaki "lássa", de ne módosíthassa ezt az oldalt? Mert akkor egy utolsó cikket el lehetne helyezni odafenn az android blogon. Nem gondoltam letörölni, mert hasznos dolgok vannak benne, de ha valaki annyira beleássa magát, hogy nem csak egy-egy témára keres rá, az akár el is vetődhetne ide. Mondjuk ehhez eléggé hiányzik, hogy végre feltegyem a githubra - de ugye: idő. Mindig volt más, ami ennél fontosabb volt.]
@lad[Persze, mindent lehet, az egész Thon névtérre vagy egyes oldalakra (chat, todos), pár kattintás az egész.]
@thon[Oké. Ötlet a következő: TAGOK: látják/szerkesztik az egészet. LÁTOGATÓK: legyen egy PUBLIC link (ugyanott, ahol a chat/construction zone/todos van felsorolva) békákkal védve. Ami PUBLIC alatt van azt látják. Megoldható? Pl. képek, file-ok, amikre a PUBLIC alatti rész hivatkozik, elérhetőek így? Nem mintha bármi titkos lenne, sőt. Aki látogatóból elő akar lépni taggá - ám jöjjön. De a kostolót a PUBLIC alá tudjuk tenni. Amin meg törjük a fejünket, az marad a többiben.] 
@lad[Persze hogy megoldható, jelenleg is így működik: az egész világ láthatja a //blog,// a //konyvtar// és egy-két további névteret, de nem szerkeszthetik; mi négyen láthatjuk és szerkeszthetjük ezt a //thon// névteret meg a //bestboard//ot; és van még vagy tíz névtér, amiket csak én látok egyedül. Javaslatom: legyen a publikus rész egy külön névtér, például a //bestboard,// mert akkor könnyebb eldifferenciálni. Aminek az eleje] [[http://lattilad.org/vicky/doku.php/bestboard/start|http://lattilad.org/vicky/doku.php/bestboard]]@lad[, az oda tartozik, tehát publikus. Lesz, ha így Szerinted jó. Meg ha lesz majd ott elég anyag, hogy publikálhassuk.]
@thon[Príma. Egyébként anyag van, csak - ugye - még mindig nem tettem be a githubba. Talán 18-án lesz időm.]
@thon[A korábbi android tér esetleg nem bővíthető egy bestboard aloldallal?]
@lad[Nem, az ugyanis egy blog Flatpressben, ami nem tud efféléket, és nálunk már túlhaladott technika is. Gondoltam már rá, hogy át kellene hozni a blog anyagát Vickybe, de eddig még nem láttam neki, sok vele a pepecselés. Végeredményben édesmindegy, hogy a korlátlan tárhelyünkből elfoglal-e pár plusz megát.]
@thon[Ez egy érdekes dolog az androiddal. Azok a kódok - ugyan elfutnak - de ma már nem (nem minden szempontból) jók. Ráadásul kicserélték az egész fejlesztőrendszert. Szerintem maradjon minden ott, aztán inkább az érdekes részeket áttesszük ide, ha egyszer lesz rá idő. Átkonvertálni egy az egyben nincs sok értelme. Majd teszek egy nyilat a végére, hogy itt keressenek tovább. Az egyetlen ötlet akkor, hogy bestboard alatt legyen a cucc (vicky-n belül), mert mást is szeretnék készíteni/feltenni, akkor annak is lesz neve. No meg a "namespace" android alatt elvileg a honlap neve kell legyen, esetünkben org.lattilad.bestboard vagy ilyesmi.]

@s5[Kompleton]

@thon[Apróság: coat_komleton_2.txt, még fejlesztés alatt. Ötleteket szívesen fogadok.]
@lad[Mi célt szolgálnak az ábécé betvei a számjegygombokon?]
@thon[Semmit. De jól mutat! :) Ez egyébként nem igaz, mert a régi telókon vannak ezek a betűk, néhány szám meg kód a segítségükkel van megadva. Először a kocka alakú elrendezésre tettem, de rájöttem, hogy ott is segít. Mnemonik végül is.]
@lad[Értelek. Ötlet: ↑↓→← karakterek az angol feliratok helyett a nyílgombokon.]
@thon[Ennek nincs akadálya, fel is teszem rá. Viszont az eredeti elképzelés az, hogy a key gombok a lehető legegyszerűbb karakterkészlettel is kijelezhetőek legyenek, ezért automatikusan a szöveget használja.]
@thon[3. verzió, átrendeztem a gombócokat. Elvileg most minden ugyanolyan csoportban van a kicsin és nagyon. Minden tervezett karakter elérhető, legalább modify segítségével. Színek/auto tulajdonságok még belövés/egységesítés alatt.]

@s5[LET Complex - kész, default kérdés TODOS között ]

Van egy új **app-debug.apk**.
Nyomorítás kikapcsolva, de tudja (csak nagyobbra van állítva)
Az újdonság:
LET ( key COMMAND ( parameters ) )
Amit később így használhatunk:
COMMAND ( key... - további paraméterek, amik az előzőeket helyettesítik - )
Megengedett COMMAND-ok: ADDBOARD, CURSOR, SEND,  BUTTON, ADDTITLE

Az ADTTITLE - mint paraméter - problémás. Ugyanis nem _hozzáadja_ az eddigi paraméterekhez, hanem _helyettesíti_. Vagyis, ha a COMMAND paraméterei között szerepel a **key**,
de ugyanitt a **key** előtt szerepel az ADDTITLE,
ÉS a **key** hivatkozott paraméterei között IS szerepel az ADDTITLE,
Akkor a **key** az előző ADDTITLE-t TÖRLI, és csak a sajátja(i) fog(nak) szerepelni.

DE!

Ha a **key** van legelöl, akkor a további, nem-labelként megadott ADDTITLE is hozzáadódik, vagyis a label-ben megadott ill. a parancs kiadásakor megadott ADDTITLE egyaránt látszik. EZ a helyes viselkedés.

EZ gyógyulni fog a multiple paraméter bevezetésével. Addig kéretik a **key** hivatkozást első paraméternek tenni.
@thon[Ezt próbáltad? Kéretik a slot helyett ezt kipróbálni, mert ezzel slot feleslegessé válik. Amúgy sztem. arra is jó, hogy pl. az írásjelek attribútumait megadjuk.]
@lad[Még azóta kicsit sok minden gyűlt össze, de most már rámozdulok.]
@lad[Rámozdultam – úgy látom, működik. ''addslot (id loft yoffset -500 size 1200 color shift)'' helyett azt írtam, hogy ''let (loft addtitle (yoffset -500 size 1200 color shift))'', aztán az ''addtitle (slot loft text '='))'' típusú parancsokból kidobtam azt a szót, hogy slot, és remekül megjelennek a feliratok. Csak ott akadtam meg, hogy a ''DEFAULT'' utasításba akkor mit írjak, mert jelenleg az áll ott, hogy ''SLOT center'', és ha slotként nincsen definiálva, akkor az nem működik.]
@thon[Hát, erre nem gondoltam. Ehhez vmi. újat kell kigondolni. Pl. DEFAULT ( ADDTITLE ( akarmi) BUTTON (masikakarmi) - és akkor ezeket az értékeket beírja. Hm-hm. Egy commandnak uis. NINCS default értéke, az mindig üres. Paramétereit feltölthetjük az előre meghatározott "label" értékkel, vagy "kézzel". A fenti hibán kívül mindig az utolsó paraméter érvényes. De miért ne lehetne default értéke akár minden egyes complex parancsnak? Egyébként minden simplex parancsnak van is - csak hard-coded, benne van a kódban. A kérdés az, hogy miként adjuk meg a "default" paramétereket. Erre is egy label-szerű elgondolást kellene használni, pl. lehetne a label neve a parancs neve. Csak miként teszem bele a be nem írt label-t a paraméter-sorba? Ha meg bele tudom tenni, akkor miért kell label? - Na, ezt alaposan végig kell gondolnom. Addig maradjon mégis a slot, ne kelljen mindenhová beírni a defaultot. Azt hiszem, elérkezett az idő a coat 3-ra...]
@lad[Szent merevlemez, remélem, nem mondod komolyan, még a kettes sincs kész. A hármasban már lennének vezérlési szerkezetek, elágazások, ciklusok, szubrutinok és kifejezés-kiértékelés is, az óriási munka.]
@thon[Igaz, csak annyit változtatunk. Pl. ha slotot kivennénk, akkor már nem lehetne 2. Az az ötletem, hogy lenne egy sub-version is. Ha az változik (régi), attól még az újabb feldolgozza. De ha a fő verzió változik, akkor azt már nem lehet más kóddal feldolgozni, csak a saját programjával. Nem akarok régi dolgokat is megtartani benne, ha gyorsabb és biztosabb nélküle.]

@s5[Né csak!]

@lad[Né csak!]
@png[ikonok]
@thon[Sezek hogyan lettek színesek?]
@lad[☢ U+2000 és 27ff között a karakterek egy része Androidon színesben, emodzsiként jelenik meg. ⛄ Sajnos nem sok. U+1F300 után sokkal több van, de hát azokat nem érjük el… pedig béka is van köztük… hüpp… ☔]
@thon[Pedig lehet, hogy elérjük. Merthogy a BMP feletti rész az simán két karakter, vagyis egy string. Márpedig ez a program stringekkel dolgozik... Szóval megpróbálhatod megadni, csak tedd macskakörömbe.]
@lad[Múkodik🐸 Múkodik🐸 A felkiáltójel gombomra tettem bééékááát és megjelenik a béééka🐸🐸🐸]
@thon[Elvileg stringet jelenít meg, elvileg stringet küld el - elvileg működnie kéne. Azt nem látom át, hogy HOGYAN lehetne megadni. Apropó, a ttf-ek továbbra sem letölthetőek, talán a nagybetvek nem tetszenek neki. Márpedig ilyen karaktert tartalmazó ttf nélkül én nehezen tudom megjeleníteni...]
@e[HELP! Se fontom, se fontválasztó programom, se editorom, amiben megjelenik. Letöltöttem egy unicode char map programot, ami kezeli a full unicode-ot, de üres. Noto fontot bexelem, akkor megjelennek a karakterek, de hol a noto font? Jota-ba bemásolva megzavarodik. Szóval Főnök Úr! Nincs csavarhúzom! Hogy csinájjam meg az autójját?]
@lad[No, itt vagyok, Gabik el. Első lépés gyanánt átneveztem a fontokat kisbetűsre, ha az derül ki, hogy evvót a baja, akkor megpróbálok intézkedni kisbetű iránt.]
@thon[Hopilí! Megjöttek a fontok. Milyen nyelven beszél ez, hogy nem ismeri a nagybetvet?]
@lad[Sejtelmem sincs, de majd kérdőre vonom.]
@thon[Még áruld el, hogy miként tetted rá az egeret a sajtra! Vagyis a békát a gombra? Én ugyanis nem tudok se béka- se egérbillentyűt leütni, ami betenné a coatba az egeret, ami kitenné a képre, ami beírná az editorba. Ami meg amúgy felkészületlen a békával szemben...]
@lad[A UnicodePad programban megkeresem a karakteremet, copy-paste a Coat programba, és megy pöpecül. A korábbi billezetképhez képest már kicseréltem az összes ikont U+1Fxxx karakterekre, a Backspace például egy mentőautó. Baba. Egy dolgot nem tudok elérni: hogy az Enteren is ikon legyen, hiába rakogatom be ugyanazt az iknot az összes enterfelirati parancsba, nem színes.]
@lad[Ui. Persze továbbra is Jotában szerkesztek, a régiben, a sárgában.]
@thon[No majd próbálkozom. Megnéztem, az enter épp ugyanazt a metódust használja; épp ugyanúgy stringet tárol. Ezt még nem tudom kitalálni, hogy mitől lehet. Próbáld addig rátenni ugyanazt a stringet, ami egy másikon működik.]
@lad[Jé, most mögy! Lett mentőautó az Enteremen, aztán béééka! Nem tudom, mit szűrtem el a korábbi kísérletnél.]
@thon[Akkor kérünk képet :) Van ötletem, csak nem bírtam megcsinálni. Kell egy COAT dokument. Ebben minden billezet, amit alkotunk,  egy link-sor. Név, verziószám, dátum, készítő. A vég dokumentum pedig tartalmazza a képeit, meg a file-t, ahol le lehet tölteni. No, meg a megjegyzést, ha kell. Én ugyanis elvesztem a saját, meg a Te billezeteidban is, pedig csak kb. 5 van. Így egyébként a verziók is egymás után megmaradhatnának. ]
@lad[Képet föltettem ikonok2.png néven. Katalógus a Coat file-jainkról? Persze, már tavaly is akartam-tuk, aztán elmaradt. Kell bizony.]
@thon[Hát ez csudijó! Egyébként felhasználóként is nagyon élvezem a billezetet... Ezt jó volt megcsinálni! Ma már nem bírok tovább hasadni, jó éjt!]
@lad[Neköd is. Igen, isteni jó dolgozni vele, alakítgatni a kiosztásokat, újakat tervezni, az egész nagyon jó. Ha visszagondolok, mit kínlódtam az összes többi andis billezettel…]
@lad[Hirtelen az jutott eszömbe, hogy azoknál a karaktereknél, amiket (a tervezés adott fázisában) csak Unicode-táblából lehet elérni, mennyire jól jönne egy olyan utasítás, amit valamikor taglaltunk, ami stringeket kap, mondjuk BUTTONLIST ("🐀🐁🐂🐃🐄🐅🐆🐇🐈🐉🐊🐋" "🐌🐍🐎🐏🐐🐑🐒🐓🐔🐕" "🐖🐗🐘🐙🐚🐛🐜🐝🐞🐟🐠🐡🐢" "🐣🐤🐥🐦🐧🐨🐩🐪🐫🐬" "🐭🐮🐯🐰🐱🐲🐳🐴🐵🐶🐷🐸🐹🐺🐻🐼"), és mindegyik karakterből csinál egy gombot.]
@thon[Elvi akadálya nincs. Egyébként mitől lesznek színesek? A ttf-et kell úgy megadni?]
@lad[Nem, a ttf formátum nem tartalmazhat se színinformációt, se pixeles grafikát, minden Bézier-görbékkel van leírva. Ezeket a karaktereket nem a ttf-ből veszi, rendszerből színesek, akármely programban nézem, azok. Lehet, hogy géptípusfüggő?]
@thon[Küldj valamit és kipróbálom, nekem hogy néz ki!]
@lad[Hát itt van pár sorral följebb ez a sok-sok állatka. PC-n a szokásos egyszínűek, némelyik hiányzik is, nem definiált karakterek. Andis Chrome-ban tarkabarka.]
@thon[Na, agyonkerestem a webet, de alig valamit találtam. Ez szép: http://apps.timwhitlock.info/emoji/tables/unicode , csak nem mondja el, hogy miért van benne KÉT Android. Úgy tűnik, (Ennek alapján: https://play.google.com/store/apps/details?id=com.quinny898.app.emojiinstaller), hogy a színes képek csak 4.4 felett vannak, nekem 4.2.2 mellett meg kell elégedni a kétszínűvel :( Azért az nem rossz, hogy a felső részt is használja minden változtatás nélkül... Őszintén: nem gondoltam volna.]
@lad[Elvileg rendszerfrissíteni is lehet a gépeden. Igen, a program elérte azt a fejlettségi szintet, amikor már a saját szerzőjének is meglepetést szerez. Iszonyúan sokoldalú, már tényleg csak kapkodom a fejemöt, és folyton azon törpölök, hogy lehetne jobban kihasználni ezt a sokoldalúságát.]
@thon[Mert megtaláltam a nénós autót, de nekem nem színes. Még egy ötlet: pl. beírsz egy számot, amit egy gombnyomás átalakít unicode karakterre. Persze ehhez ismerni kell a kódot. De pl. visszafele sem lenne haszontalan.]
@lad[Nem bizony, mindkettő hasznos lenne.]

@s5[Háttérkép a boardra]

@lad[Persze van ennél jobb is a tarsolyunkban, azaz a] [[TODOS]] @lad[között: háttérkép a boardra. Azzal már mindent lehet majd, a tervező rátesz egy képet, amin egyes gombok helyén olyasmi van, ami jelent valamit, és áttetsző háttérszínt ad a gomboknak.]
@lad[Ezzel például el lehet érni olyanokat, hogy a billezet nyelvét megváltoztató linkgombok zászlócskák legyenek.]
@lad[Új gombolat. El lehet-e érni-e vajon-e, hogy egy board összes gombja megjelenjen, még ha nem is léteznek is? Például az ADDBOARD-ba írt GRID //háttérszín// paramétör segítségével kapnánk egy üres boardot, akinek minden gombja a megadott háttérszínű, tartalom és funkcicó nélkül? Ennek akkor lenne jelentősége, ha (amikor) már lehet háttérképet tenni a boardra: az üres hatszögrács, illetve a róla készült screenshot lenne a sablon, amin a tervező megrajzolja, megszerkeszti a háttérképet. Hiszen ha az ikonokat tartalmaz, akkor az adott gombhoz kell őket pozicionálni.]
@thon[Megjegyzem, lehet az addtitle helyett addpicture is, ami egy képet ad hozzá. A másik kérdésre: az hülyeség. Ha lenne egy kis időm, akkor csinálnék egy olyat, ami simán gyárt egy billezetet (üreset) és menti kép-ként. Egyébként a kész billezetet se lenne hülyeség menthetővé tenni, mert eleve képnek készül. Habár, a változó gombócok (pl. enter) nincsenek rajta, azt csak később írja rá.]
@lad[Addpicture, az még jobb. A kész billezet képmentése szintén remek ötlet, de boardonként, hisz némelyiknek több tucat is lehet.]

@s5[Back és Home gombok]

@lad[Jó Back Button programomat újabban nem tudom használni,  amikor a BestBoard (vagy bármely billezet) be van kapcsolva,  olyankor egyszerűen eltűnik, fogalmam sincs, miért. Ezért meredt föl bennem a kérdés: lehet-e gombot csinálni az Android rendszer Home és Back gombjainak reprodukálására? Szörnyű jó lenne, ha nem kellene fölfele nyúlkálnom a gép tetejére, merthogy én ugye fejreállítva használom őtet.]
@thon[Sztem. vannak. Nézd meg a key-ek között. Gondolom KEY KEY_HOME meg KEY_BACK. Egyébként a program nem nyúl egyikhez sem, ha lenyomjuk, továbbmegy a rendszernek. Ez utóbbi kettő meg szimulálja. Ezek azok, amiknek nevet kerestünk, ha emlékszel.]
@lad[Tényleeeg, ó, de jó. A neveik KEYHOME és KEYBACK. Nagyon klassz, ennél már csak akkor lenne klasszabb, ha működnének is. Merho’ nem igazán. A KEYHOME nem csinál semmit, a KEYBACK Jotában Home funkciót gyakorol (a Back az lenne, hogy becsukja a billezetet, de ő visszamegy a homescreenre), Chrome-ban semmit.]
@thon[Ez akkor egy meglehetősen bonyolult problémát sejtet. A BACK billentyűt minden program megkapja: először a BestBoard. Ha feldolgozza, akkor eltünteti a billezetet. DE! Ha mi adjuk ki, akkor mi magunk nem kapjuk meg, utazik az előző programhoz, aminél viszont kilép (Jota). A Home ugyanígy működik, de nem tudom, hogy miért nem kerül felismerésre. Pl. az tudható, hogy ki adta ki, és pl. a program nem reagál CSAK a beépített home billentyűre. Erről sehol nem találtam doksit, csak próbálkozni lehet, és az se fog minden egyes programnál működni...]

@s5[U]

@thon[Más: az 'u' jelet sztem. az törölje, aki megcsinálta/megválaszolta az adott kérdést. Ez - ha valakinek kifejezetten szól a kérdés -, lehet csupán az is, hogy elolvasta. Vagy, ha egy ötletet a CHAT-ból pl. todok közé, avagy a leírásba tesz stb.]
@lad[Rendicsek. Majd úgyis kialakul.]

@s5[Új tagok]

@thon[No, Matyi is használja a BestBoard-ot, akármennyire is nem tökéletes. Balázs (akivel találkoztál) is szeretné az új változatot. Én azt gondoltam, hogy kész lesz a hétvégére, de több olyan dolog derült ki, amin még módosítani kell. Emiatt nem szeretném széles körben terjeszteni, de aki AKARJA használni, az miért ne tegye? A kérdésem az, hogy ki lehet-e/tudjuk-e gyomlálni erről az oldalról a magándolgainkat (ami akár egy ugyanilyen lapon külön is szerepelhetne), és tudunk-é adni hozzáférést ezeknek az emberkéknek? Azt gondolom, hogy: 1. vagy nem fogják használni (akkor mindegy), 2. de ha mégis, akkor el tudják olvasni, hogy mi van a hibák mögött, és hogyan tervezzük a javítást, 3. és talán még írni is fognak ötletet. Szóval lehet, hogy hiába remélem, hogy aktív taggal bővülünk; de ha a lehetőséget sem teremtjük meg, akkor biztosan nem is fogunk. Márpedig csak a hétvégi meeting során egy csomó dolog megvilágosodott (hogy miért hiba), amire előbb nem is gondoltam. Egy bővebb csapat komoly segítséget jelentene. Egyébként erre az oldalra akkor meg is hívhatnánk azt, akit közvetlenül ismerünk. Pontosabban: ha jelen állapotában kitesszük az egész világ elé a bestboardot, akkor a letöltők legyintenek, és többé nem töltik már le. Mert most még nehéz használni, és az alapfunkciók sem tökéletesek. Viszont, ha valaki ismer minket, akkor kipróbálja, lehet, hogy félreteszi, de aztán majd újra előveszi, ha változik valami. Egy maréknyi embernek akár személyre szabott billezet elkészítésében is tudunk segíteni. Mi erről a véleményed?]
@lad[Minden szavaddal egyetértek, csak Balázs címére van szükségem; Matyit elérem. Mindent, ami az eddigiekből nem a programról szólt, áttettem a] [[http://lattilad.org/vicky/doku.php/privat/thon]] @lad[oldalra, ehhez csak Neked adok elérést, innentől ez meg van oldva. Ennek a régi chatoldalnak pedig le fogom söpörni a padlását.]
@thon[Jó lett a rendrakás! Balázst nem szoktam emailen hívni, de ez sztem működik: http://aok.pte.hu/hu/egyseg/munkatars/460/4822]
@lad[Regek megcsinálva, levélkék elküldve, és készítettem egy] [[fogadobizottsag]] @lad[oldalt a belépéskor hasznos tunnivalókhoz.]
@lad[Balázs még nem jelentkez, esetleg ha látod, szólhatol, hogy nézze meg a postáját.]
@lad[Balázs már jelentkez, remélhetőleg be is jutott.]
@thon[Ja, közben beszéltünk is :)]

@s5[Felhasználói dokumentáció]

@lad[Estve nekiláttam és römbetöttem az eddigi felhasználói dokumentációt, egyúttal átraktam a] [[http://lattilad.org/vicky/doku.php/bestboard/start]] @lad[címre, mert valahányszor költöztetjük, újra kell generálni a kulcsszó-adatbázist, ami meglehetős macerativitási faktor. Ezt végleges helyének szánom, egyelőre kettőnknek van hozzá elérése. Átírtam a megváltoztatott kulcsszavakat, töröltem a SEND-et, de új kulcsszót nem adtam hozzá, mert a költöztetés miatt újra kellett generálni a Vicky metarendszerét, ami több óra. Pláne macerativitási faktor.]

@s5[Írásjelek]

@thon[Más: Tudnál egy kicsit segíteni az írásjelekben? a vonalaknál akadtam el, de esetleg le tudnád írni, hogy a nem 127 alattiakból melyik írásjelet használjuk a magyarban? ill.  melyiket ne a 127 alattiak közül. Köszönöm!]
@lad[A vonalakat nem értem, a többit apránként fölfogtam. A 127 alattiak közül csak programozásnál és egyéb számítástechnikai meg matematikai célokra használatos: a Coatban is használt kétféle idézőjel (mert a " macskaköröm helyett a magyar az alsó–felső 99 idézőjeleket „ ” használja, más nyelvek másféléket, macskakörmöt semmilyen nyelv se; a ' ASCII aposztróf helyett is van rendes nyomdai ’ aposztróf), valamint a # $ < > \ ^ ~ ` { } @PIPE jelek. Ezek egyetlen nyelvben sem szerepelnek, elnézést a mekegésért.]
@lad[A magyarban használatos összes írásjel: . , : ; ! ? ( ) - % / » « (belső idézőjelek) és innentől 127 fölött: „ ” (külső idézőjelek) – (félkvirtmínusz, ma gondolatjelnek is ezt használjuk meg angol–magyar típusú szókapcsolatokhoz is) ’ (aposztróf, csak idegen szavakban és nevekben fordul elő, magyar szavakban nem) … (három pont)]
@lad[Ennyi. Nyomdai célokra persze több kell, ° © ¡ ¿ “ • € meg mindenféle. De a programod már tudja a TESZ-billezet teljes latin betűs jelkészletét…]
@thon[Pont ez  NA ITT ESTE ELSZÁLLT A NET, de jó a progi, megmaradt draftban). Lényeg: Pont ezt szerettem volna tudni. A letöltésekkel még van gond, mert a ttf-et nem látja, nálam - emlékeim szerint - csak a Code2000 van. Még a "vonalakról" kérdeznék: a félkvirtminusz az "en dash"? És mikor melyiket kell használni? Három van, ugye? Vagy hol lehet erről olvasni? S más: az idézőjelek közül az angolost hol találom? (Ami 66-99 csak felül van). Köszi!]
@lad[Három van, igen. A sima kötőjel (- U+002d) van olyan szavakban, mint egy-két, dínom-dánom, kettős családnevekben, mint Szűr-Szabó, Ráth-Végh, Joliot-Curie, a hatszótagos szabályon túlnyúló szóösszetételekben, mint rendőr-főkapitányság, és ezt használjuk szóvégi elválasztásra. A félkvirtmínusz vagy en dash (– U+2013) szolgál gondolatjelként – közbevetéshez –, párbeszédekben, olyan szókapcsolatokban, mint angol–magyar (mert ha angol-magyart írnál, az egy darab nép, illetve nyelv lenne, mint judeo-perzsa, panay-hiligaynon, bamileke-bafusszam), típusjelekben, mint TU–154, és hasonlókra. A kvirtmínusz vagy em dash (— U+2014) a magyarból a múlt században kihalt, én nem is tartom a billezetemen (illetve rátettem valamikor, de már nem tudom, hová), ugyanarra szolgált, mint a nem ragadó (szóközzel elválasztott) félkvirtmínusz ma, legalábbis úgy rémlik, hogy a gondolatjel hosszú volt, a TU–154-et viszont röviddel írták. De már csak félkvirtmínuszt használunk, amikor elkezdtem dolgozni, még volt róla szó, hogy kell-e kvirtmínusz a billezetekre, aztán úgy döntöttünk, hogy egységes félkvirtmínuszt fogunk használni. Az angol idézőjel felső 66-99, vagyis “ U+201c ” U+201d.]
@lad[Mindezekről a legjobb információforrás a Mogyoró, becsületes nevén //Idegen nyelvű szövegek kézirat-előkészítése, szedése és korrektúrája,// fölteszem a szerverre, ''ratz-timko.djvu''nak hívják, mert a digitalizáló így nevezte el, de azt Mogyorónak hívta mindenki, a borító színe után. Igazi kincs volt, én apámtól kaptam egyet azzal, hogy igenis visszakéri. Sose kapta vissza, ő meghalt, a könyv elveszett, sok évvel később kaptam egy digitalizált példányt. Ne nagyon terjeszd.]
@thon[Hopp. Ezt: http://unicode.org/charts/ meg ezt: https://hu.wikipedia.org/wiki/Wikip%C3%A9dia:K%C3%BCl%C3%B6nleges_%C3%ADr%C3%A1sjelek meg ezt: https://hu.wikipedia.org/wiki/Id%C3%A9z%C5%91jel találtam. Viszont rájöttem: vagy programot feljlesztek, vagy billezetet... a kettőre együtt végképp nincs idő.]

@s5[Lépkedés boardok között]

@lad[Hát majd fejlesztek billezetet én, apropó, gomba vagyok. A Shiftem jelenleg linkgomb, ami két kiosztás között ide-oda kapcsolgat:]
  cursor (only board cseh row 1 column 8)
  button (link l_shcseh color shift addtitle (text '⇧'))
  cursor (only board shcseh row 1 column 8)
  button (link l_cseh color shift addtitle (text '⇩'))
@lad[de ebből az jön ki, hogy ha véletlenül kétszer nyomom meg, akkor visszakapom ugyan a kisbetűs kiosztást, de ha megnyomok egy betűt, az kisbetűként jelenik meg, ugyanakkor azt okozza, hogy visszavált nagybetűre és úgy marad. Megint meg kell nyomni kétszer a Shiftet, hogy visszakapcsoljon. Erre nem megoldás, hogy tegyem őtet metabillentyűvé, mert így semmiképp se szabad egy billezetnek viselkednie, ez bug.]@gif[bug]

@thon[Nem bug, korlátozás. Már én is gondolkodtam a feloldásán. A miként - az viszont kérdés. Szóval: jelenleg olyan boardra átváltani, amelyikről van tovább út, CSAK a LINK LOCK paranccsal szabad. Az "alap"-boardokon (nevezzük így) van egyetlen szintnyi lehetőség, hogy "fel"-válts egy shift-szerű billentyűzetre, ahonnét leütés után visszatérsz, vagy esetleg lock-ra váltasz (ehhez a LINK nem-létező utasítás a legjobb pl. LINK -1, mert az mindig oda megy vissza, ahonnét jött. Tehát: ha több fix kiosztás van, akkor közöttük a LINK...LOCK paranccsal tudsz váltani. Ennek hátránya, hogy csak akkor tudsz visszajönni, ha megnyomod a visszavezető, szintén LINK...LOCK parancsot. Ha van valami egyetlen gombért átváltandó kiosztás (pl. nagyon ritka jelek), akkor az elérhető egy egyszerű LINK... utasítással. Ugyanezen a "ponton a nagyon ritka jelek" egy LINK -1 -et tartalmaz. Ha átváltás után megnyomod az egyik nagyon ritka jelet, akkor visszavisz az előzőre, miután leütötted. Ha viszont a LINK -1-t nyomod meg, akkor gépelhetsz nyugodtan, mert maradsz a nagyon ritka jelek között - egészen addig, amíg újra le nem ütöd a LINK -1-et, ami visszavisz.\\ 
A korlátozás oka, hogy nagyon könnyen lehetne körkörös hívásokat csinálni. Az én gondom a következő: van egy ALAP billezet, amiről hívok egy NUM-ot és egy SIGN-et. De NUM is hívhatja SIGN-et és SIGN is hívhatja NUM-ot. No és persze mindkettő ALAP-ot is. Ez egy elég egyszerű felállás. De ha nem LOCK-kal vannak megoldva a váltások, akkor ki hova visz vissza? Pl. ALAP "Költség" SIGN ":" (rögtön) ALAP, NUM-LOCK "12" SIGN "-" rögtön NUM "1" (és most mi lesz? Nincs LOCK, tehát megyek vissza. De hová? SIGN-re vagy ALAP-ra? Vagy: ALAP "abc" NUM LOCK "123" SIGN LOCK "+-!" NUM LOCK "456" ALAP LOCK "def". Most viszont mit csinál a BACK, körbe-körbe visszavisz? Szóval ezek a logikai hibák nincsenek körüljárva.
Valami olyan kéne, hogy ALAP-ról mehetek NUM-ra vagy SIGN-ra. NUM-ról mehetek VISSZA vagy SIGN-ra. SIGN-ról mehetek NUM-ra vagy VISSZA. A végtelenségig mehetek NUM és SIGN használatával. De ALAP-ra ne csak akkor térhessek vissza, ha végigmegyek a teljes soron. Pl. (de csak ötletelek), ha valamelyik LOCK-olva van, akkor arra tér vissza, de ami nincs LOCK-olva, azokon egy karakter után visszaugrik. Viszont, ha akármikor eljutok "ALAP"-ra, akkor törli az egész sort, és ott marad. Csak akkor nagyon sok ilyen button kellene egy-egy boardra. ALAP-ra kell SIGN és NUM. SIGN-ra kell LOCK (ugye ez a vissza is) ALAP és NUM. NUM-ra kell LOCK és ALAP. Akárhogyis ezt nem egyszerű se elkészíteni, se leprogramozni. Mert az egész algoritmust még nem látom át.]
@lad[Well. Szerintem valami logikát vigyünk a dölögbe. Ha egy gomb arra van definiálva, hogy vigyen vissza a legutóbb használt boardra, akkor igenis tegye azt. Ez kétfélét jelenthet. Mondjuk, hogy az //a, b, c, d, e// nevű boardok voltak legutóbb használva, most az //e//-n állunk és megnyomjuk a visszalépő gombot. Logikusan a //d//-re kerülünk. Most jön a kétféle: a) a további nyomkodás visszavisz a //c, b, a// sorban, b) a //d//-ről megint az //e//-re kerülünk, hiszen mielőtt a //d//-re léptünk, az //e//-n voltunk; újabb megnyomása megint a //d//-re visz, és így tovább, vagyis ez a gomb a két utolsó boardot cserélgeti és semmi többet. Mindkét megoldásnak megvan a maga logikája.]
@thon[Javallat: nézzük meg, mi lenne a logikus, és úgy csinálom meg. Egyébként nem egyszerű, de nem is lehetetlen. Van egy harmadik módszer is: a(lock) b c d(lock) e(lock) - ahol lock jelenti, hogy a LOCK jelzővel mentünk rá - vagyis a board marad, ha gombokat nyomogatunk, egészen addig, amíg nem ugrunk más boardra (esetünkben vissza). Ilyenkor a visszatérési sor: e BACK d(lock) BACK (c és b kimarad, mivel itt már nyomtunk gombot) a(lock) Ez logikusabb, de jóval nehezebb. Továbbra is fennáll a kérdés: honnan ne lehessen visszatérni? Azaz: mi akadályozza meg, hogy a felhasználó a lépkedések során elvesszen? Talán lehetne olyan board (ADDLINK-ben jeleznénk), ami törli az egész ugrálási sort. Pl. a jelenlegi 0. Vagy: akin nincs "BACK" az töröl, mert onnan soha többé nem lehet visszatérni - nincs hozzá gombóc. Meg a 0., ahová viszont NEM lehet (nem érdemes) BACK gombot tenni. No, ezt rágjuk át.]
@lad[Igazából bármelyik teljesen logikusnak tűnik. Honnan ne lehessen visszatérni? Egyrészt ha lesz egy opciómenü, amiben egy lista fölsorolja az adott Coat összes boardját, akkor ez a gond már se gond többé, másrészt… nem látom a jelentőségét az ugrálási sor törlésének.]

@s5[CURSOR és SECTION]

@thon[Van egy távlati gondolkodnivaló. Megértettem, hogy mit nem értesz a cursor-on. A gond az, hogy most: először megnevezzük a billentyűzeteket, majd utána rádefiniálunk egy billezet-darabot. Igazából persze, hogy nem így kellene. Definiálni kellene billezet darabokat, amikből össze lehetne állítani egy billezetet. Csak éppen nem tudom, hogyan kellene ezt csinálni. Most ugyanis nagyon hatékony a dolog: minden egyes sor csak egyszer kerül feldolgozásra, aztán több billentyűzetbe is bekerül. Ehhez az egész coat dolgon egyszer futunk végig. És nem ugrálunk benne. Ki fogok ötleni egy billezet-darab gyártó részt, amit lehet tárolni, és lehet hatékonyan feldolgozni utána.]
@lad[Jó. Igazából már értem a CURSOR-t, de ha ilyet tudol kiötleni, az is jó lehet, és attól nem kell eldobni a CURSOR-t, a kettő más-más célokra lehet jó.]
@lad[A következőt például el tudnám képzelni. Van egy utasítás, mondjuk SECTION, ami bármely szöveget körbe tud fogni és adni neki egy nevet. Például]
  SECTION (lila
    (
    LET (gombsor vilagoslila)
    LET (masikgombsor kozeplila)
    LET (harmadiksor sotetlila)
    )
  )
@lad[Ha ez mögvan, akkor másutt kiadunk egy ''CALL (lila)'' utasítást, és az adott helyre bemásolódik a tárolt szöveg – egyszerű szövegművelettel. Így lehet aránylag egyszerűen átszínezni egy billezetet, és ha ezt lehet, mindent lehet, gombcsapatokat varázsolhatunk elő, akármit. A legszebb ez akkor lenne, ha gombra lehetne definiálni a CALL utasítást, de akkor már dinamikus posztprocesszálás van, ahhoz kell posztprocessz őrző, posztprocessz nővérke…]
@lad[…ulánbátor jelentem, én biza nyomkorászom a DRAFT gombot, és a világon semmi különös nem történt még, nem omlott össze a program, nem dobálta széjjel a gombokat, nem mászott elő godzilla a menü mögül, mindön mögy, mint a parancsolat.]
@thon[De: pl. az enter neve nem a megfelelőre változik.]

@s5[Beépített kiosztás]

@thon[FONTOS! Mint kiderült, van még mit csiszolni a billentyűzeten, de ki kellene találni egy olyan egyszerű billentyűzetet, amit minden körülmények között egyszerű használni (vagyis nagy, mint a tied), mindent tud (vagyis az ékezetek mellett a szabvány ascii írásjeleket meg a fentieket is), mindent bemutat a coatból - ÉS ami a beépített billentyűzet lehetne. Sztem. egyébként lehet 3 különböző is, de kellene legalább egy alap. A véleményem az, hogy jelenleg CSAK a kineasa elrendezést használjuk (alfára), akkor nem futunk bele jogi kérdésekbe.]
@lad[Rendicsek, majd töpörögjünk, hogy mi legyen benne. A legfontosabbnak azt tartom, hogy a beépített billezet 1. átírható legyen, vagyis adjon egy alapot ahhoz, hogy a felhasználó elkezdje a saját kiosztását kilegózni, 2. viszont legyen egy tárolt példány, amire vissza lehet térni, ha elrontotta.]
@thon[No, ez biztos. Szerintem úgy 3-5 db belefér egyébként.]

@s5[Kinesa 16]

@lad[Kinesa16.txt néven föltettem a legfrissebb alkotást. Ez már használja a CURSOR utasítást, végre értem! Érdemes megnézni a módosítókat, de a kódban, hogy látsszon, mi minden van ott, és HungLingTESZ fonttal, mert a karakterek egy része csak azzal látszik. Áthoztam a gyűjteményt a TESZ-billezetből. A billezeten a ⊗ gombot nyomd, ő a billezetválasztó menü, így nem kell egy halom gombot lefoglalni linkeknek. Növeltem a soronkénti gombszámot, még van egy csomó üres helyem.]

@s5[AUTOSPACE AFTER]

@thon[Terv: mire megyek, meg tudjuk osztani az alkotást. Szerintem már nem sok hiányzik hozzá. Persze szigorúan prebeta, csak cimbiknak. Cimbi mondjuk akárki lehet :) ]
@lad[Vau. Jaj, mióta akarom mondani. Az már benne van, hogy az autospace after adjon space-t akkor is, ha Enter jön? Mert itt Chrome-ban nem ad, Jotában sem ad… de nekem szentül úgy rémlik, hogy ezt már megcsináltad.]
@thon[Oppsz. Csak kitanulmányoztam, hogy pontosan hol kell, de nincs kijavítva. Akkor viszont már tárgyaljuk meg, hogy pont hogyan legyen. ELÉ ne tegyen se enter. se tab (se space) után ugye? Mögé pedig csak akkor ne, ha space van? Jól értem?]
@lad[Igen, teljesen, szerintem így lesz jó.]

@s5[DO DRAFT]

@e[CSAK NEKED! Próbáld ki: DO DRAFT :) újrarajzolja a billezetet. Nagyon sok mindent nem figyel, de működik. Módosítod a coat.txt-t MENTED! Majd: DO DRAFT billentyű, és újrarajzolja a módosításokkal. Többi kevésbé érdekes, ld. modify REVERSE és ADDROLL.]
@lad[Ez úgy gelledd bár, bidd egy valad gegyér. Ibádob. Gözbed balhé ádderjedd gizs gobbzerű orrodzsgábra.]
@lad[Hűűűű, kilátok a kis gombszerű orrocskámon! Infralámpa! infralámpa!]
@thon[Nem véletlen, hogy nem volt. Nagyon durván avatkozik a belügyekbe. De megpróbáltam, és működik. Ha összedőlne valami, akkor azért válts egy másik billezetre, meg vissza, akkor már jó lesz - de talán a tervezést segíti. Ja, és a STEP-et SKIP-re módosítottam, miután 5x rosszul írtam le. Amúgy én is igen gyengéden vagyok, de ez 80%-ban allergia...]
@lad[Nekem ez a STEP nem is volt ismerős, hol lakik ilyen?]
@thon[Már sehol. Úgy hívják: SKIP szám és SKIPROW szám - számnyi billentyűt/sort kihagy]
@lad[Jé, ez dekeb teljesed kibaradt…]

@s5[FUNCTION és DO]

@thon[Kérdés. Ha elolvasod a lentieket, látni fogod, hogy az elküldendő packet lehet TEXT vagy KEY. Az új packet a FUNCTION. Most külön kezel minden egyes funkciót, de ez nem jó így. Mit szólsz ehhez: DO BACKSPACE és DO DELETE.]
@lad[Nincs ellene nyifogásom.]
@thon[Nekem van. Az ENTER és a SPACETRAVEL komplett billentyűt definiál, ezért egyedül áll. A BACKSPACE és a DELETE egy funkciót, ezért DO-val áll. Ez ugyan logikus, de nem várható el, hogy valaki ezt a logikát megjegyezze. Technikailag viszont szét kéne választani a kettőt, amin gondolkozom.]
@thon[A "SEND" viszont eltűnhet, mert az egész hóbelevancot át tudom tenni a BUTTON alá. Ok: eredetileg minden, ami készült egy parancs volt paraméterekkel. Pl. a SEND vagy a BUTTON. De ha a paraméterek nem egyeznek (pl. KEY TEXT ill. DO is majd), akkor azokat össze lehet keverni. A program kiválogatja, hogy neki mire van szüksége belőle. Ezért is kell a DO, mert különben nehéz megkülönböztetni, hogy mi lesz belőle.)]
@lad[Felhasználói szemszögből a SEND nem túl értelmes parancs, mert mi mást tenne egy gomb, mint hogy küld valamit, úgyhogy nem gond, ha kikerül belőle.]
@thon[A backspace hard-key-t cseréld ki DO BACKSPACE-re. Delete-t (vagyis jobbra törlést) meg a DO DELETE csinál. A hard-key-t persze fordítva hívják. Amúgy a BUTTON ( SEND ( valami ) akármi ) is írható így: BUTTON ( valami akármi )], ahol akármi pl. ADDTITLE(ezmegaz) De! Az ezmegaz nem kerülhet button alá, csak send lett kiírtva, addtitle nem!]

@s5[Color hiba]

@lad[Máma kicsit viszontagságos napom volt, az új apk tesztelése is félbeszakadt, viszont rájöttem, hogy miért változnak meg egyes feliratok színei; akartam szólni erről, de elmaradt. A COLOR utasítás, úgy tűnik, csak változót fogad el, literális értéket nem.]@gif[bug]
@thon[Akkor slot. Color-ral példát tudsz küldeni? Egyébként ez nem lehet, mert a labels kiértékelése közös, és előbb van. Inkább a számérték kiértékelésénél lehet valami - a color speciel elég összetett.]
@lad[Föltettem a jelenlegi file-t, kinesa12.txt. Nézd meg például az örményt (balra Թ gomb). Az összes felirat fekete, pedig az örmény betűk a cdark, a latin megfelelők az expl slottal vannak megadva, amiknek a definíciója fehér, illetve zöld: 0cf és 0c0f0.]
@thon[Ez durva. Mennyi idő alatt készíti el? Mert tesztnek nagyon jó lenne. Itthon nem tudom megnézni, mert már nincs meg az előző apk. Ha esetleg átírtad, akkor el tudnád küldeni megint? Mert akkor debuggal is végig tudok menni a coloron.]
@lad[Hát ha jól látom, akkor 3244 ezredmásodperc a különbség a log két vége között. Jó sok error van benne, ahol a szín invalid. Ezenfelül szólt, hogy írjam a CAPS STATE-et két szóba (megtettem), és kivetette a space travelből a TEXT " "-et. Meg talált egypár fogalmam sincs, honnan odakerült zárójelet és egy mövel íratta az ipogegrammenit. Szóval a colorokon kívül minden jó. A keyboard buildernél nyakon döfött malacként sikoltozik, hogy a változók értékét felülírta, nem tudom, miért, az a dóga, írja felül.]
@thon[Nem gondoltam, hogy ilyen gyorsan összerakja, vow! Majd átnézem a maradék hibát lépésről-lépésre. Kéne csináljunk egy tesztboardot egyébként, ahol minden egyes parancsot lepróbázunk magára, meg a fő hibákra - márminthogy kiadja a hibaüzeneteket is. Még nem tudom, ezt hogy kéne csinálni.]
@lad[Hát ezt én se…]

@e[Hibákok]
@thon[Persze megint rohadt banális hibák okozták a kavart, sima figyelmetlenségből.]
@lad[Én soronként kettőt szoktam csinálni. ]
@thon[1. a token-feldolgozó visszaadja, hogy milyen típusú tokent talált. Pl. a color az integer. De az agyában még color-t tárolt. Amikor visszadobtad a nem felhasznált tokent (merthogy zárójelet keresett, de nem talált), akkor a következő elkérésnél már nem az integer tokent adta vissza, hanem a tárolt (szigorúan belső) color típust. Ezzel a feldolgozó rész meg nem tudott mit kezdeni, mert a belső ábrázolást már ő nem ismeri, neki integer kell (ami belsőleg lehat akár color eredetű is). A módosítás: (tokenType == TYPE_COLOR) résznél: return TYPE_INTEGER; helyett: tokenType=TYPE_INTEGER; return tokenType; mindent megoldott - lévén az elkészítés után már nem lényeges, hogy eredetileg egy color szintaxisú részből készült az integer. 2. font: Én idióta dobtam egy kivételt, ha nem találta meg a fontot. Csakhogy azt még a paraméterfeldolgozás során kereste, és a kivételt figyelő rész már a kész paramétert kapta volna meg - hacsak sokkal előbb a kivétel le nem állítja a feldolgozást. Feltűnhetett volna, hogy ez az egy kivétel van az egész részben. Módosítás még egyszerűbb: result = null; egy bonyolult kivétel helyett. Vagyis hiányzó file esetén nincs is kiértékelt paraméter.]
@e[Hibák persze lesznek, kéretik erősen figyelni! (coat.log, rendes log sok infot tartalmaz, de nem mindent. Körülmények is kellenek)]
@lad[Igyekszök.]
@thon[szeptember18mod feltöltve, font file nevét módosítani kell. Egyébként most hiba nélkül fordul.]
@e[Ismert hibákok]
@thon[Pl. a spacetraveles nyivákolás azért van, mert nem törli a feldolgozott paramétereket. Ha adsz mellette egy TEXT paramétert (lehet!), akkor készül egy sima billentyű meg egy spacetravel is a TEXT-tel. A simát eldobja, de nyivákol. Szóval ez hiba, de ismert, tudom is a gyógyírt, csak az komolyabb meló, mint a fentiek. Addig meg hadd nyivákoljon, attól még ez működik. Egyébként minden felülírásnál nyivákol (ez szándékos) mert nem tudja, hogy direkt akartad, vagy tévesztettél. Egyébként meg ne is jelentsen ugyanaz kétszer mást.]
@e[Hibákok nálad]
@thon[Nem jönnek le a ttf-ek, not found üzenettel. Amúgy a feltöltésnél - ha lehet - érdemes lenne a feltöltés után frissíteni, hogy az új file megjelenjen.]
@lad[Ööö… izé…]
@thon[Másrészt megfontolandó az időrendi rendezés, mert akkor jól látjuk a változást. Ha valami régi kell, az ctrl-f-fel úgyis egy pillanat alatt kiválasztható. De ez apróság, nincs jelentősége. Csak egyszerre töltöttem fel, meg sikertelenül le, és rájöttem, hogy így könnyebb átlátni. Úgyis csak mi használjuk.]
@lad[Majd megnézem, momentán fogalmam sincs, hogy azt a listát milyen kütyü csinálja, mennyire látok bele.]

@s5[Enter]

@thon[Új apk, ismeri az entert. A konfigurálás elég összetett ld. leírás.]
Lehetséges akció-értékek (rendszer szolgáltatja):
  * go, search, send,  next, done, previous  
A gomb kiírja az editor által kért akciót (még nem változtatható) ill. leütéskor jelzi az editornak, hogy hajtsa végre, amit kért. Semmilyen billentyűleütés vagy textbeírás nem történik
  * multiline (CR) 
FlagNoEnterAction értéket küld a rendszer, ami azt jelzi, hogy többsoros editor mezőben vagyunk. Itt textuális '\n' kerül elküldésre, ha meta billentyűk nincsenek bekapcsolva. Egyébként meta+enter hard-key.
  * unspecified (???)
Nem ismert, hogy mi az editor szándéka (praktikusan nincs megadva érték)
  * none (---)
Nincs az editornak szándéka (mert pl. nem akarja, hogy leüssék az entert, hanem külön gombot kell megnyomni).
Mind a kettő utóbbiban enter hard-key kerül elküldésre (amit a rendszer kedve szerint használhat).

Ki kell találni, hogy - különösen az utóbbi kettőben - mi legyen a rendszer működése. Pl. NONE esetén lehet, hogy nem szabad semmit tenni. Unspec. esetben meg testuális '\n'-et kell küldeni. Nem tudom. Elvileg ezek a feliratok is a tesztet célozzák, minnél több input-mezőt meg kell nézni és azok alapján dönteni.

Paraméterek: SEND (ENTER) De! CSAK UTOLSÓ HÁROMBAN!
Definiálhatunk egy TEXT részt (TEXT opcionális, ha nincs, akkor "\n"), de az AUTOCAPS, AUTOSPACE stb. paramétereket felismeri és alkalmazza - elvileg. Értelemszerűen CSAK multiline-ban működik (ahol text mezőt küldünk)
Definiálhatunk egy KEY részt (KEY opcionális, ha nincs akkor KEY_ENTER), de a SETCTRL/SETMETA/SETALT paramétereket felismeri. Ha mindet tiltjuk (OFF), akkor multiline-ban minden beállításnál text-et küld. Ha beállítjuk, akkor meg a megfelelő beállítást pl. SHIFT+ENTERt kényszeríthetünk ki vele. Amúgy követi a meta-billentyűket természetesen.
Ezen kívül REPEAT is beállítható.

@lad[Működőképes, most már egy-két napja mögy és tényleg jó. Isteni, hogy nem kell a böngiben átváltani numpadra, hogy a beírt URL-t el is lehessen küldeni. Azt nem tudom követni, hogy milyen elv szerint választ neki feliratot, a Jotában egyszer CR-t látok, máskor ???-et, szóval guzmis. GO látható, amikor shortcutot akarok átnevezni a home screenen, valamint a Chrome címsorában, a Google Play keresőjében viszont ---. De mindegyiknél remekül végrehajtja. Javaslatom: adhasson a tervező fix feliratot, ami mindenféleképpen ugyanúgy jelenik meg, akármilyen funkcicót aktivizél a gomb. Más is lehet úgy vele, hogy fütyül rá, hogy hívja azt a kódot az Android rendszer, csak nyomhassa meg és mönjön.]
@thon[Bocsok állnak, de van még újabb hajnali termés:]
ENTERTITLE text
GOTITLE text
SEARCHTITLE text
SENDTITLE text
NEXTTITLE text
DONETITLE text
PREVTITLE text
NONETITLE text
UNKNOWNTITLE text
Az android rendszerben az első hat megkülönböztetés fontos, mert tényleges szerkesztőkarakterként CSAK az első működik, az összes többi esetben a programnak szóló parancsot ad ki a billentyű. Ezt hozza a  felirat a dolgozó tudomására. 
@e[Fontos! Szerintem, a NONE esetén nem is szabad üzemeltetni ezt a billentyűt (most hard key-t küldünk), UNKNOWN esetén meg nem tudom mit kellene tenni (most itt is hard-key-t küldünk). Nogyon fontos lenne, hogy felírd, amikor ezek a feliratok működnek: melyik program, melyik mezője - de a legfontosabb, hogy ott szerinted mi lenne az enter feladata - NEM KELL / ÚJ SOR / (ÚJ MEZŐRE LÉPÉS v. VMI. GOMBOS INDÍTÁS)]
@lad[Bocsánatot, az mi az, hogy nem szabad üzemeltetni? Robban? Csak mert vótunk bótba (azt nyögve is muszáj), előző vásárló vett egy üveg söröt, Klárika (másik, a pénztáros) rálépett a pedálra, szalag elindult, sör megakadt valamiben és átugrott a korláton, akkorát szólt, mint álgyú, nem mertünk kimenni ott, csak a bejáraton, mert egy szilánk elég és ott maradunk. Szóval van tét. Ha megjelenik a NONE, akkor reszkessek, nehogy meglibbenjen a fülem és hozzáérjen?]
@thon[Egyébként igen, azt írja a dokksi. Mert pl. visszavonhatatlan dolgot tennél, ha megnyomnád (pl. elküldenél egy levelet), és ez nem fér bele az android szellemébe. Többsoros meg ugye elvileg nem lehet, mert akkor azt jelezné. De a doksi rövid és értelmetlen, ezért csak gondolom, hogy ilyenkor nem akarja a program az enterhasználatot megengedni.]
Az utolsó igazából egyben van, mert olyankor hard-key-t kell szimulálni. A parancs csak akkor működik, ha az editor elküldte, hogy parancsot vár.


@s5[Hibagyűjtés]

@thon[Azt hiszem, megleltem a meta-billentyűs hibát. Volt lehetőség arra, hogy meta-beállítás nélkül menjen ki billentyű. Ami fontos: Nagyon sokat segít, ha a furcsa működést PONTOSAN felírod. Melyik program melyik inputmezőjében PONTOSAN mit észleltél. Mi volt ott a teljes szöveg (ehhez egyébként elegendő a kurzor körüli néhány száz byte). És persze mit írtál be, ami a hibát kiváltotta. Ha kétszer ugyanazt el tudod játszani (vagy többször) az még jobb. Meg esetleg melléteszed az utolsó log-ot is. A loggal kapcsolatban: az ellenőrzést akkor hajtja végre, amikor a programot elindítod. Namármost ez egy service, ami mindig fut - vagyis soha nem indul el. (Jó, egyszer az elején, de arra nem számolhatunk.) Szóval arra gondoltam, átteszem az ellenőrzést oda, amikor elrejti a billezetet. Vagy van esetleg jobb ötleted, milyen eseménnyel kéne összekötni?]

@s5[Android Studio installálása]

@thon[Más: fel kéne tenned valami könnyen elérhető helyre az android-studio-t: http://developer.android.com/sdk/index.html. Ehhez előtte szükséges lesz a Java Development Kit (http://www.oracle.com/technetwork/java/javase/downloads/index.html bármelyik JDK odavisz). Valamint szükséges lesz a Samsung driver-csomagja. Attól tartok, ez csak úgy lehetséges, ha a Kies-t feltelepítet, kiszeded belőle a driver-csomagot, aztán törlöd. Ha az egész megvan, akkor egy példaprogramot (automatikusan csinál egyet, csak le kell futtatnod) ki kéne próbálni a emulátoron, de leginkább a gépen. Ezt felrakni kb. két óra, igaz saját maga játszik, nem kell nézegetni. Meg elég komoly helyigénye is van. De nem lenne baj, ha lenne egy munkaállomás mire megyek, és nem akkor töltenébk ezzel a drága időt. Meg amúgy se lenne baj, ha Nálad is lenne lehetőség matatni a kódban, ha csak próbaként is.]
@lad[Majd megpróbálom, még a használati utasítást sem értem, de hátha.]
@thon[Két program: JDK meg AndroidStudio. Mindkettőt beállítások nélkül lehet telepíteni. Meg driver kéne a Samsungokhoz, de az sztem. csak a Kies programban van, külön nincs. Abban viszont egy elég logikus "Drivers" v. hasonló mappában.]
@lad[Próbálkozom és sivalkodni fogok az eredményről.]
@lad[jdk-8u60-windows-x64.exe letöltve, fölrakva; android-studio-bundle-141.2178183-windows.exe letöltve, fölrakva; utánanézek, mi az a Kies. Megtudtam, Kies3Setup.exe letöltve, fölrakva. Ez utóbbiban van egy SAMSUNG_USB_Driver_for_Mobile_Phones.exe file, elindítom. Driver állítólag fölrakva. Most azt kellene tudni, mit tegyek, hogy ennek az egész kutyputynak a működőképességéről infóm legyen.]
@thon[Ez elég egyszerű. New project... és csak követni mindent automatikusan. Létrehoz - elvileg - egy hello-világ programot, amit a Run/Run 'app' vagy az ikonsorból a nagy zöld lejátszónyíllal lefordít és futtat. Az első alkalom hosszú percekig tarthat! Feljön egy oldal, ahol a rádugott androidos készüléket felajánlja, és akkor azon fut a program. Van lehetőség emulátort létrehozni - de le kell "butítani", mert az alapbeállításokkal nekem nem volt elég erős a gépem, ami azért elég nagy szó... Ha ez megy elsőre, akkor megnyugodhatunk; ha nem, akkor sincs baj, mert fényévekkel közelebb vagyunk a működő rendszerhez, mint eddig. A Driver file-t tedd el nagyon, mert más módon szinte lehetetlen megszerezni. Viszont Kies-t (szerintem) törölheted, csak a bajt okozza. (Uis. ez a Samsung felügyelő és áttöltő programja - tök fölösleges, és 70 mega. De nincs máshol driver.)]
@lad[Holnap megpróbálkozom vele, ezért most meghagyom a fenti soraid előtt a jelzőzászlót.]
@lad[Még holnapabb, máma hajnalig cikket írtam, aztán egész nap aludtam.]

@s5[Publikálás]

@lad[Én meg azon tűnődöm, lassan lehetne publikálni mint prebétát, hadd lássák a nípök, hogy nekünk ilyen van. Használni úgyse fogják. Illetve amíg nincs meg a doksi, nem is tudják használni, de nézegethetik.]
@thon[Persze, oda kéne már adni másoknak is használni. Énszerintem ez legyen először a BestBoard csoport felébresztése, ha új meghívottakkal is. Kontroll nélkül sztem. akkor tehetjük fel, ha kész az: opciók (ez nagyon fontos), a kijelöléses dolgok működnek, esetleg az enter.]
@lad[Rendicsek. Kezdem majd csöpögtetni a hírt.]
@thon[A teendőket itt lent meg egy külön fileban tegyük egybe. A sorszámozás mellett kell egy: ezt most meg kell csinálni el ne felejtsem rész (ez van most a constr. zone elején), nagyjából csak memonak. A második: ezt meg kell csinálni a (következő) publikálás előtt A harmadik csokor: Né még milyen jó ötleteink vannak! Ha majd lesz időm, kigyomlálom a chatot is, most már elég nagy egy archiv file létrehozásához, itt meg az legyen ami télleg aktív.]
@lad[Szintén rendicsek, én nem merek gyomlálni, nehogy olyat dobjak ki, ami még megpörgeti a gondolataidat, de ha leviszed a fölösleges szöveget ennek az oldalnak a végére, akkor átpakolom majd egy külön archívumba.]
@thon[Van még egy-két ötletem: Tudom, hogy gyengén látogatott, de mégiscsak két tagja vagyunk: SLP fórumban, mint hírt nyugodtan feldobhatjuk. Ha valahol, ott kell legyen érdeklődő. A másik hely: itt fenn az Android blogban lehetne egy cikk, vagy valami mutató, hogy ezen dolgoztunk, itt tartunk. Na persze, ezt megírhatom én is. De gondolom lesz lattilad cikk is, akkor azt oda is be kék linkelni. A Prebeta oké, de én szívem szerint mindenhol, mint experimental billentyűzet hivatkoznék rá. Ez minden szempontból igaz, kifejezi, hogy fogalmunk sincs arról, amit csinálunk, de egyúttal nem zárja ki, hogy akár tökéletes is legyen. Merthogy ebből alfa nem lesz soha supporttal, az elég valószínű.]
@lad[Sejtelmem sincs, hogy az SLP-n mit szólnának hozzá – ki kell próbálni. De akkor legjobb lesz először is cikket írni és azt beküldeni nekik. Persze, tervezem már, hogy írok róla.]
@thon[kissjoe-t még megkereshetjük. Nem programoz androidot, de mindent kipróbál. Meg nekem is van egy kollégám, aki note-on dolgozik. Mindkettő érdeklődő, és valószínűleg visszajelzést is ad.]

@s5[Nomenclatura fejtörés]

@lad[Ebben a szakaszban a sorok elejéről kivettem a dupla szóközt és dupla ' ASCII aposztróf közé tettem őket, mert így is megmarad a monospace, de word wrappel, nem lógnak ki a hosszú sorok jobbra.]
@thon[Töprenkedjünk ezen a selectbutton kérdésen]

''ADDBOARD ( ID egyes ... )''
''ADDBOARD (ID kettes ... ) - ez a két utasítás egy-egy üres boardot hoz létre''
@lad[Eddig meghagynám a mostani nómenklatúrát.]
  
Mindkét boardra rá szeretnénk tenni a kinesa elrendezésű betűket, ezért kijelöljük, hogy melyik boardon hová kerüljenek:

''ÁLLÍTSD A HOZZÁADÁSI POZÍCIÓT ( BOARD egyes COLUMN 0 ) -ra! (ÉS CSAK EZT A BOARDOT KÉSZÍTSD!)''
- innentől csak ezen a boardhoz lehet hozzáadni
@lad[Lássuk csak. SELECTBUTTON azért nem jó, mert azt az érzést kelti, hogy már meglevő gombokkal akarunk foglalkozni. Ez a hozzáadási pozíció jó kifejezés, induljunk ki ebből. Ennek számítástechnikai neve kurzor. SETCURSOR (ONLY BOARD egyes COLUMN 0)?]
''ÁLLÍTSD A HOZZÁADÁSI POZÍCIÓT ( BOARD kettes COLUMN 3 -ra  ÉS TARTSD MEG AZ ÖSSZES EDDIGI BOARDOT IS A HOZZÁADÁSI LISTÁBAN) ! ''
- megmarad az egyes és beáll a sorba a kettes board is. Csakhogy a hozzáadások az egyesen a 0. oszloptól, míg a kettesen a 3. oszloptól kezdődnek.
@lad[Ez esetben SETCURSOR (ALSO BOARD kettes COLUMN 3)?]
  
''BUTTON ( Kinesa billentyűk hozzáadása ) ... ''
-  Ezek mind a két boardra rákerülnek 0. ill. kettesen 3. oszloptól kezdve. A NEXTROW is a 0. ill. a 3. oszlopra fog visszaállni, nem a legelejére.

''ÁLLÍTSD A HOZZÁADÁSI POZÍCIÓT ( BOARD egyes ROW 5 ) -re! (ÉS CSAK EZT A BOARDOT KÉSZÍTSD!)''
- innentől megint csak ezen a boardhoz lehet hozzáadni

''BUTTON ( Numerikus sor hozzáadása ) ... ''
- Csak az egyes boardra kerülnek, az 5. sorba

''ÁLLÍTSD A HOZZÁADÁSI POZÍCIÓT ( BOARD kettes COLUMN 10 ) -re! (ÉS CSAK EZT A BOARDOT KÉSZÍTSD!)''
- innentől viszont csak a kettes boardhoz lehet billentyűt hozzáadni

''BUTTON ( Numerikus oldalbillentyűzet hozzáadása ) ...''
 csak a kettes boardra kerülnek, a 10. oszloptól kezdve
  
@thon[No, a magyar megfelelőknek kéne valami jó neveket kitalálni. De a logika a fenti. Szóval először beállítjuk, hogy melyik boardokon és hová szeretnénk tenni a következő billentyűket, aztán a megadott billentyűk azokra a helyekre potyognak. Lehetne talán EDIT? Vagy OPEN? Vagy BUILD? Include helyett meg ALSO? TOO? ]
@lad[Igen, az ALSO és a TOO egyaránt jó, én az ALSO-ra voksolok, mert akkor fix helye lehet a BOARD szó előtt, ahol az ONLY is áll, és egy WITHOUT szót is fölvehetünk, amely egy adott boardot kivesz a jegyzékből. (A too azt is jelenti, hogy túlságosan, tehát ezért is jobb az also.)]
@thon[Elfogadva. Apró módosítás: a SET sehol nincs kiírva a COATban, ezér CURSOR a logikus. Szintén ALSO-ra szavazok. ONLY is lesz, de az egyébként alapértelmezett. WITHOUT megoldható, de az keveredést okozhat, szerintem minden billentyűcsoport előtt szerepeljen, hogy melyik boardokra tesszük. (És ne az, hogy melyikre NEM.) Van viszont egy - már az új nomenklatúrával - CURSOR (NONE), ami mindent töröl.]
  
@s5[Boardmásolás - technikai okok miatt bizonytalan ideig elhalasztva]

@lad[Megvan a jó kulcsszó: FROM! ADDBOARD (ID újboard FROM régiboard).]
@thon[Két kérdésem is van, egyik egy ötlet. Kéne egy AS kulcsszó, amivel ugyanolyan boardot lehet csinálni, mint a megjelölt - kivéve, amit átírunk belőle. Ez elvileg nem szabad, hogy megoldhatatlan legyen.]
@lad[Szerintem se, és nagyon jó ötlet, az a jelenlegi izé, ami include helyett van, nekem csak kétoldali idült agyzavarodást okoz. De ne legyen AS, mert nyelvtanilag nem illik ide. Javaslatom: ADDBOARD (ID újboard COPYING régiboard), vagyis a régit másolva hozzunk létre újat. Ezután BUTTON (ROW sor COL oszlop stb.) megadásával felülírhatunk egyes gombokat, illetve van még ötletem.]
@lad[A COPYING régiboard után adhassunk meg további paramétereket, miszerint]
  * EXTENDUP, EXTENDDOWN, EXTENDLEFT, EXTENDRIGHT – kibővíti a boardot további gombokkal valamely oldalon. A kulcsszót egy szám követi, a sorok, illetve félgombok száma. Így létrehozhatsz egy „mag” boardot, ami mondjuk csak a sima ábécét tartalmazza, és különböző boardokon más-más módon toldod meg további elemekkel. Ez esetben az új boardnak megváltozik a HALFCOLUMNS és/vagy ROWS értéke. Azért nem ez utóbbi szavakkal változtatnám meg, mert azt is meg kell mondani, hogy a lemásolt régi hová kerüljön az újon belül.
  * ALIGNODDS, ALIGNEVENS – ha szerepel, felülírja az eredeti board beállítását. Ez akkor fontos, ha oldalról megtoldod félgombokkal.
  * Az ADDBOARD további paraméterei szintén írják felül a régi boardét.
  * Fölmered a kérdés, hogy ha a régi boardon vannak USE gombok, azok hova mutassanak az újon. Lehetséges válaszok: 1. ugyanoda, hiszen azokat is lemásoljuk, 2. BUTTON utasítással felül lehet írni őket és akkor máshová mutatnak, 3. az ADDBOARD kaphat egy USE ("régi" "új" "title") paramétert, ami azt okozi, hogy ha a lemásolt boardon van egy **USE régi** utasítás, azt kicseréli **USE új**ra. Ennek két előnye van: egy helyen lesz az összes USE, ami az adott boardon szerepel, vagyis együtt látod őket, és ha a boardváltó gombokat ugyanott akarod hagyni és ugyanúgy színezni stb., csak másik boardra kell mutatniuk és persze másik feliratot viselniük, akkor nem kell az egész BUTTON utasítást megírni hozzá.
@thon[Itt egy hosszabb fejtegetés következik, amit majd valahol a coat környékére el is rakhatunk. A baj csak az, hogy öt percem van...]
@lad[Jó gyorsan írsz. :)]
@thon[Csak ahogy vezetek. Na jó, volt az tíz perec is...]
@e[EZ A RÉSZ KÉSŐBB MÉG HASZNOS LEHET, CSAK MÉG NINCS MEG A HELYE]
@thon[A legegyszerűbb leírónyelv, ha minden egyes billentyűt külön-külön leírunk. Ilyen pl. az xml (ill ennél azért sokkal többet tud). A COAT elsősorban a gyakorlás és a kipróbálás miatt született; de másrészt pontosan azért, hogy ne kelljen minden adatot többször megismételni. A COAT nyelv rendkívül egyszerű, csak konstansokkal képes - külön metódusok segítségével - egy adatstruktúrát feltölteni. A COAT-ban minden parancs és paraméter is egyúttal. A parser végighalad a paraméterlistán, és minden egyes paraméter-parancsot végrehajt - de előtte ugyanígy kiértékeli a teljes parancs paraméterlistáját. Ebből következik (amúgy logikusan), hogy a paraméterek előbb kerülnek kiértékelésre, mint ahogy a parancsuk végrehajtásra kerülne. Másrészt a paraméterek csak szépen egymás után kerülhetnek kiértékelésre.\\ 
Amikor egy board-ot létrehozunk, akkor az egy fix és üres gombrendszerrel születik meg. Ennek mérete többé nem változtatható. Amikor egy gombot létrehozunk, akkor megszületik a gomb. Maga a gomb tárolja a saját értékeit, ezért minden egyes lyukban csücsülő gomb egy külön entitás lesz, ám a rajta lévő adatok (pl. feliratok) az egy alkalommal létrehozott, de több lyukba beültetett (és emiatt sokszorozott) gomboknál közösek. Azt is fontos tudni, hogy gomb csak üres lyukba ültethető, a felülírás hibaüzenetet ad (bár lehetséges).\\ 
A fenti struktúrával kellett megoldani, hogy több board azonos billentyűzetrészeket kapjon. Ez csak úgy oldható meg, ha a board-ok előtte elkészülnek, majd a második lépcsőben kijelöljük azokat a board-okat, amik a következő billentyűzet-részt megkapják (akár más-más részre, de ugyanabban az elrendezésben). Az billentyű definiciók ezután következnek, és a billentyűk minden egyes kijelölt board-ra bemásolásra kerülnek. A board-ok kijelölését a SELECTBUTTON parancs végzi, mely egyetlen BOARD-ot jelöl ki, ill. INCLUDE esetén a korábban már kijelöltekhez hozzáadja. A nomenklatúrán tudunk változtatni, de az elven nem.]
@lad[Értem. Akkor tegyük fel a következőt: legyen régiboard mérete mondjuk 10·5, és mondjuk azt, hogy ADDBOARD (ID újboard FROM régiboard HALFCOLUMNS 13 ROWS 6 ATCOL 1 ATROW 1), vagyis a régit beillesztjük az új board 1. oszlopába és 1. sorába. Mivel három félgombbal szélesebb és eggyel magasabb, a jobb oldalon három félgomb és alul egy gombsor üresen marad. Kérdés most, hogy mi az ATCOL logikus paraméterezése. Ha félgombban számolunk, akkor mi van, ha a felhasználó a meglevőhöz képest félgombnyival eltolva adja meg a számot? Ez felborítaná a hatszögrácsot, tehát nem megengedett. Lehet, hogy jobb egész gombban számolni, vagyis HALFCOLUMNS 13 esetén az ATCOL legnagyobb megengedett értéke hat.]
@thon[Az ATCOL stb. gombkon nem érdemes gondolkodni. A board-másolás az tényleg másolás, nem lehet változtatni rajta.]
@lad[Akkor az egész másolósdinak csak akkor van értelme, ha azt a bizonyos magot úgy tervezi meg az ember, hogy előre tudja, hogy mely irányokból hány gombot akar később mellérakni a többi boardon, és oda előre kirakja az üres gombokat – ez pedig se nem életszerű, se nem rugalmas, úgyhogy a maggal ugyanazt fogják csinálni, amit a köré rakandó panelekkel: copy-paste a szövegszerkesztőben. Szerintem ejtsük ezt a boardmásolósat. Ha valamit nem lehet, akkor nem lehet.]
@thon[Nem oldható meg, hogy egy billentyűzetrészletet definiáljunk, tároljunk és később adjuk különböző boardokhoz. A belső tárolási struktúra nem tükrözi a síkbeli elhelyezkedést, ezért egy ilyen megoldás igen körülményes lenne.\\ 
Nem oldható meg az sem, hogy az "include" egy coat-részt (akár külön file-ból) töltsön be. Két okból: a file-ban nem tudunk ugrálni. Másrészt ez a rész minden alkalommal végrehajtásra kerülne - szemben a fenti megoldással, mely csak egyszer fut le.\\ 
Mi az, amivel könnyíthetünk? Az ADDBOARD (ID newboard AS/LIKE oldboard) egy ugyanolyan, ámde üres board-ot hoz létre. Minden paraméter, amit itt megadunk, az módosul az eredeti board-hoz képest - vagyis annak a paramétereit csak alapul használjuk. Ámde itt gomb vagy boardmásolás nincsen.]
@thon[Készülhet egy ADDBOARD (ID oldboard COPYOF newboard) utasítás is, ami egy-az egyben lemásolja a board-ot, itt azonban semmilyen módosításra nincs lehetőség - a legyártott board már fix adatstruktúrával rendelkezik. Megjegyzendő, hogy ennek a megoldásnak csak akkor van értelme, ha van egy fix része a billentyűzetnek, amit másolunk, míg a többi rész teljesen változó. Ha azonban több különböző egysége van a billentyűzetnek, akkor egyetlen másolás nem lesz elegendő. Pl. van egy fix kinesa centrum, amihez landscape esetén oldalt, míg portrait esetén alul csatlakoznak a számbillentyűk. Ilyenkor ezzel a módszerrel legfeljebb a kinesa centrum másolható, a két - egyenként több boardot érintő - számpanel nem.]
@lad[Ez is nagyon komoly haszon lehet. Az ember megtervezi a billezet magját, a legnagyobb terjedelmű részt, és átmásolja minden szükséges boardra; aztán odateszi köré a szükséges bővítéseket, amik között lehetnek megegyezők, de azokat hagyományos másolással, a szövegszerkesztőben copy-paste-tal kell másolni.]
@thon[Harmadrészt meg kitalálhatunk jobb nevezéktant, ami a fenti logikát tükrözi.]
@lad[Hát könnyen lehet, hogy csak a SELECTBUTTON nevét és paraméterezését kellene megváltoztatni, hogy fölfogjam…]
@thon[Írom mindezt úgy, hogy ez egy program, ami bármire képes, ha átírjuk. Tehát természetesen ami lehetetlen, az lehetséges. De a felállított koncepció és az elkészült program keretei között a felsorolt szabályok szerint tudunk csak módosítani.]

@s5[Probléma az autospace-szel - megoldva, mögötte kizárólag a space-t fogja figyelni]

@lad[Ááá, már megint nem jön az autospace after, pedig még nem választottad szét, vagy igen?\\ Később. Most meg már megy, pedig csak átváltottam Facebookra és vissza.]
@thon[Ezt pontosítani kellene: melyik része nem megy az autospace-nek, melyik programban, milyen stringnek milyen pontján? Egy dolog lehet: Ha whitespace (space újsor tab) már van, akkor nem rakja ki a space-t]
@lad[Még nem tudom, de nincsen whitespace. Az ember lenyom egy vesszőt, ami után autospace van beállítva, és csak vesszőt kap, autospace nélkül. Illetve… pillanat, kipróbálok valamit.]
@lad[Lássuk csak. Most átjöttem Sweetie-re, és nincs autospace. Most leírok egy betűt, aztán kurzor balra: és így, nini, van autospace! Most úgy írok, hogy egy nagy X-et tol maga előtt a kurzor, ami nem mellékesen némileg zavaró, de így lett autospace, a diagnózisod helyes, a beteg menthető: autospace after esetén akkor is ki kell tenni a szóközt, ha Enter áll a kurzor után, mert ez csak annyit jelent, hogy nem a szöveg utolsó bekezdésének állunk a végén. X]
@lad[Azt is kipróbáltam, hogy beírtam egy fölösleges szót és visszaléptem a szó előtti szóköz elé – annyi történt, hogy az első autospace-es írásjelnél kidobta a szóközt és betette az autoszóközt. De az Enter kidobása zavaró lenne.]
@thon[Ez igaz, de nem ennyire egyértelmű. Lehagytad a pontot. Visszamész, és kiteszed. Akkor miért lenne utána space? Viszont, ha enter előtt írsz, akkor meg szükséged van a space-re. De hogyan tehetünk különbséget? Elöl töröljön az enterig és hátul ne? És mi legyen a tabbal? Ugyanez? No, ezen törjük még a kobakunkat; technikailag mind a kettő tök egyszerű.]
@lad[Szerintem első körben jó lenne beletenni, hogy az Enter előtt rakja ki a szóközt, mert ez most nagyon zavaró. Mármost ha lehagytam a pontot Visszamegyek és kiteszem ←←← akkor a Visszamegyek előtti szóköz előtt fog állni a kurzor, és el kell a jószágnak döntenie, hogy tegyen-e szóközt. Ne, mert szóköz előtt még egy szóköz logikusan nem kell, egyébként az ERASESPACES is erre szolgál. Tab előtt viszont kell szóköz, mert ha valaki tabokkal tabolt táblázatban tabog, és hosszabb szöveget ír, akkor ugyanaz az effektus lép föl, mint az Enternél.]

@s5[Panasz]

@lad[Közbevetőleg, Sweetie éppen lefáraszt azzal, hogy a Back Button kis panele mindig eltűnik, amikor bekapcsolom a gombozatot. Kicseréltem egy Navigation Bar nevű programra, azzal is. De nem a Best hibája, a többi billezetprogrammal is ezt csinálja. Eddig nem volt ilyen hisztije, tegnap kezdte.]

@s5[Közeljövő - leginkább tapasztalatszerzés kéne, én is elkezdetm boardot szabni]

@thon[Mégmásabb. Egy kicsit, azt hiszem, most meg fogunk akadni. Egyrészt most elég intenzíven csinálgattam, és egy-két más dologgal utol kell érjem magam. A nagyobbik baj(ok): opciókból az új elég elvarázsolt, kicsit dolgoznom kell rajta. Nagybetűváltás: át kell írni egy kicsit a billentyű-hívásokat; ezt már kitaláltam. ACTION/ENTER nem igazán tudom, hogyan tegyem a feliratot, hogy megváltozzon. Meg még egy-kettő. Ezekkel az a gond, hogyha nem is változtatni, de bővíteni kell a struktúrát; ami nem kis idő, meg össze is dönthetek valamit. Azért persze ügyködök rajta. Mivel viszont hozzá kell nyúlni a szívéhez, érdemes lenne ezt az időt arra használni, hogy a COAT-ot is kifésüljük, ill. rájövünk azokra a problémákra, amikre nem is gondoltam. Ha ugyanis már némi tapasztalattal a hátam mögött kéne hozzányúlni, akkor rögtön úgy igazítanám a belsejét is. Az már eddig is megmutatkozott egyébként, hogy a koncepció, amit kitaláltunk, az elég jó, és jól is bővíthető. (+könnyen és gyorsan)]

@s5[A Coat nyelv leírása]

@lad[Well, doktor uram, hozzákezdtem a Coat nyelv leírásához. Most tartok némi pihenőt. Huszonegynéhány kulcsszó már megvan, egységes formában, és ha belenézel az oldalak kódjába, látni fogod, hogy egy-egy paraméterkulcsszónál csak megmondom, hogy mely utasítás használja (például az ID-t kettő is), magához az utasításhoz nem kell hozzányúlnom (csak annyiban, hogy azt az oldalt újra kell renderelni, mert a cache-ben még a régi képe van), magától megjelenik az összes hozzá tartozó paraméterkulcsszó, illetve a főoldalon az összes kulcsszó. Ezek valójában kicsi tárgymutatók, amire semmiféle használható plugin nincsen, én írtam a hozzá való makrónyelvet. Az adatok kis file-okban vannak, jelenleg négy darabban (egy az összes kulcsszóhoz, egy-egy pedig az ADDBOARD, az ADDTITLESLOT és a DEFAULT paramétereihez). Csak azé’, hogy néha én is programozok, ha rozogán is.]

@s5[Új apk, szeptember 10.]

@thon[Új apk! coat.txt-t kér.]
@lad[Ez nagyon jóóó!]
@thon[SETCAPS ON esetén a title-k uppercaseben vannak.]
@lad[Ezt kellene írni hova?]
@thon[Sehová. Ha a boardnak van ilyen (na jó, akkor az addBoard-ba), akkor nagybetűsít.]
@thon[Nincs az AUTOSPACE visszajelzés hiba, de AUTOCAPS-on nem változtattam.]
@lad[Majd látjuk, hogy mögy.]
@thon[Van: ADDMODIFY( ID keyword ROLLS ("string1" "string2" ...)), ami a SEND (MODIFY keyword) segítségével készített billentyűvel használható. Ez (még) csak karakter-modify-t tud, csak egy irányban, de már ez is valami. Van ADDTAGS is, de azt csak a log-ban lehet látni. Ellenőrzendő: kijelölést egyáltalán nem kezeli a program, ez milyen hibákhoz vezet? 2. MODIFY-ID hibái csak futásidőben derülnek ki, azt coat.log-ba írja. De futás közben.]
@lad[Vauuuu! Muszáj volt ebből először is a modifyt kipróbálni, íme a műved élőben:]{{ :thon:Screenshot_2015-09-10-20-21-21.png }}
@lad[A forráskódot betettem a szövegdobozba ide:] [[kinesa]]@lad[. A görög billezetre kapcsolva (Δ gomb) kipróbálhatod, a sárga gombok adják az újgörög ékezeteket, a türkizkékek az ógörögöket, sorozatosan. Például ω + **ά** = ώ, + **ἁ** = ὥ, + **ᾳ** = ᾥ. De ugyanez a betű a három ékezet bármilyen sorrendű nyomkodásával megkapható, akárcsak a PC-s billezetemen.]

@s5[API-verziószám - API 16, JellyBean-t célzunk]

@thon[Fontos! Megemeltem az API-t 16-ra. Ez azt jelenti, hogy csak Android 4.1 JellyBean fölött fog futni. A Tietek olyan? Későbbiekre: mivel már 6.0 is van, ez a korlátozás ma már nem jelentős. De létezik kompatibilitási könyvtár, amivel le tudunk menni akár Android 2-ig is. Éppen csak jelenleg nem nagyon akarom a kompatibilitási könyvtárat is beletenni...]
@lad[Persze, 5.0.2 megy Sweetie-n… Kisandit nem tudom, az elég régi, de amennyit Klárika ír rajta, a tavaly program is bőven elég rá (az fut rajta). Mikróka rendszere 4.1.2.]

@s5[Hibalogok]

++ nyizsdgi |
(15-10-22 17:28:36.624) @ dancingmoon.bestboard.SoftBoardService.onStartInput (main)
(15-10-22 17:28:36.625) 59 hard button is up!
(15-10-22 17:28:36.627) 113 hard button is up!
(15-10-22 17:28:36.629) 57 hard button is up!
(15-10-22 17:28:36.630) PreText and preTextReader are invalidated!
(15-10-22 17:28:36.631) PostText and PostTextReader are invalidated!
(15-10-22 17:28:36.631) Ime action: UNSPECIFIED, because action is not known.
(15-10-22 17:28:39.180) @ dancingmoon.bestboard.SoftBoardService.onStartInput (main)
(15-10-22 17:28:39.181) 59 hard button is up!
(15-10-22 17:28:39.183) 113 hard button is up!
(15-10-22 17:28:39.184) 57 hard button is up!
(15-10-22 17:28:39.185) PreText and preTextReader are invalidated!
(15-10-22 17:28:39.186) PostText and PostTextReader are invalidated!
(15-10-22 17:28:39.187) Ime action: UNSPECIFIED, because action is not known.
(15-10-22 17:29:15.046) @ dancingmoon.bestboard.SoftBoardService.onStartInput (main)
(15-10-22 17:29:15.047) 59 hard button is up!
(15-10-22 17:29:15.049) 113 hard button is up!
(15-10-22 17:29:15.050) 57 hard button is up!
(15-10-22 17:29:15.052) PreText and preTextReader are invalidated!
(15-10-22 17:29:15.053) PostText and PostTextReader are invalidated!
(15-10-22 17:29:15.053) Ime action: UNSPECIFIED, because action is not known.
(15-10-22 17:29:17.436) @ dancingmoon.bestboard.SoftBoardService.onStartInput (main)
(15-10-22 17:29:17.443) 59 hard button is up!
(15-10-22 17:29:17.447) 113 hard button is up!
(15-10-22 17:29:17.448) 57 hard button is up!
(15-10-22 17:29:17.449) PreText and preTextReader are invalidated!
(15-10-22 17:29:17.450) PostText and PostTextReader are invalidated!
(15-10-22 17:29:17.451) Ime action: UNSPECIFIED, because action is not known.
(15-10-22 17:29:18.895) @ dancingmoon.bestboard.SoftBoardService.onStartInput (main)
(15-10-22 17:29:18.897) 59 hard button is up!
(15-10-22 17:29:18.908) 113 hard button is up!
(15-10-22 17:29:18.909) 57 hard button is up!
(15-10-22 17:29:18.913) PreText and preTextReader are invalidated!
(15-10-22 17:29:18.914) PostText and PostTextReader are invalidated!
(15-10-22 17:29:18.915) Ime action: UNSPECIFIED, because action is not known.
(15-10-22 17:29:27.807) System log cleared.

 *​*​* Best's Board started! *​*​*


 *​*​* SOFT-BOARD-SERVICE HAS STARTED *​*​*

(15-10-22 17:29:27.815) @ dancingmoon.bestboard.SoftBoardService.onCreate (main)
(15-10-22 17:29:27.871) Parsing has started.
(15-10-22 17:29:27.873) @ dancingmoon.bestboard.SoftBoardParser.<init> (main)
(15-10-22 17:29:27.884) @ dancingmoon.bestboard.SoftBoardParser.doInBackground (AsyncTask #1)
(15-10-22 17:29:27.893) @ dancingmoon.bestboard.SoftBoardService.onStartInput (main)
(15-10-22 17:29:27.896) @ dancingmoon.bestboard.SoftBoardParser.parseDescriptorFile (AsyncTask #1)
(15-10-22 17:29:27.910) @ dancingmoon.bestboard.SoftBoardParser.onPostExecute (main)
(15-10-22 17:29:27.912) @ dancingmoon.bestboard.SoftBoardService.softBoardParserCriticalError (main)
(15-10-22 17:29:27.914) Critical error happened!
(15-10-22 17:29:27.915) @ dancingmoon.bestboard.SoftBoardService.noKeyboardView (main)
(15-10-22 17:29:27.953) Warning text has changed: Critical error happened!
(15-10-22 17:29:29.235) @ dancingmoon.bestboard.SoftBoardService.onStartInput (main)
(15-10-22 17:29:33.401) @ dancingmoon.bestboard.SoftBoardService.onStartInput (main)
(15-10-22 17:29:38.103) PreText and preTextReader are invalidated!
(15-10-22 17:29:38.105) PostText and PostTextReader are invalidated!
(15-10-22 17:29:42.794) @ dancingmoon.bestboard.SoftBoardService.onDestroy (main)

 *​*​* SOFT-BOARD-SERVICE HAS FINISHED *​*​*

(15-10-22 17:29:45.951) System log cleared.

 *​*​* Best's Board started! *​*​*


 *​*​* SOFT-BOARD-SERVICE HAS STARTED *​*​*

(15-10-22 17:29:45.964) @ dancingmoon.bestboard.SoftBoardService.onCreate (main)
(15-10-22 17:29:46.001) Parsing has started.
(15-10-22 17:29:46.011) @ dancingmoon.bestboard.SoftBoardParser.<init> (main)
(15-10-22 17:29:46.074) @ dancingmoon.bestboard.SoftBoardService.onStartInput (main)
(15-10-22 17:29:46.082) @ dancingmoon.bestboard.SoftBoardParser.doInBackground (AsyncTask #2)
(15-10-22 17:29:46.089) @ dancingmoon.bestboard.SoftBoardService.onCreateInputView (main)
(15-10-22 17:29:46.090) Soft-board is not ready yet, no-keyboard-view will be displayed.
(15-10-22 17:29:46.091) @ dancingmoon.bestboard.SoftBoardService.noKeyboardView (main)
(15-10-22 17:29:46.086) @ dancingmoon.bestboard.SoftBoardParser.parseDescriptorFile (AsyncTask #2)
(15-10-22 17:29:46.105) Warning text is empty!
(15-10-22 17:29:46.196) @ dancingmoon.bestboard.SoftBoardParser.onPostExecute (main)
(15-10-22 17:29:46.197) @ dancingmoon.bestboard.SoftBoardService.softBoardParserCriticalError (main)
(15-10-22 17:29:46.198) Critical error happened!
(15-10-22 17:29:46.199) @ dancingmoon.bestboard.SoftBoardService.noKeyboardView (main)
(15-10-22 17:29:46.203) Warning text has changed: Critical error happened!
(15-10-22 17:29:53.643) @ dancingmoon.bestboard.SoftBoardService.onStartInput (main)
(15-10-22 17:29:55.653) @ dancingmoon.bestboard.SoftBoardService.onDestroy (main)

 *​*​* SOFT-BOARD-SERVICE HAS FINISHED *​*​*
++
@e[Segítség, segítség! Levettem ezt a változatot, visszatettem a legutóbbit, és öt másodpercenként rám sikolt, hogy unfortunately stopped! Most csak Best’s Keyboardom van!]
@thon[A hiba a coat.log-ban lesz, valami gondja van a coat.descriptorban. Valószínűleg valamiért nem jön létre a board. Töröld le az egész alkalmazást (akkor törli a beállításokat is, de az sd-kártya persze marad), és rakd fel úgy az előzőt. Akkor annak működnie kell. Mellesleg az új ugyanazt tudja, mint a régi; abban nincs változás, nem is hibás (rossz volt a szó) csak még nincs teljesen kész. Viszont több coat-file-t is tud kezelni, noha még be kell írni és nem lehet kiválasztani.]
@lad[De hisz töröltem. Uninstall. Mást mit lehetne még törölni?]
++ nyizsdgi |
 *​*​* START SOFT-BOARD-SERVICE *​*​*

(15-10-22 17:46:01.351) @ dancingmoon.bestboard.SoftBoardParser.<init> (main)
(15-10-22 17:46:01.355) @ dancingmoon.bestboard.SoftBoardParser.doInBackground (AsyncTask #1)
(15-10-22 17:46:01.361) @ dancingmoon.bestboard.SoftBoardService.onStartInput (main)
(15-10-22 17:46:01.361) @ dancingmoon.bestboard.SoftBoardParser.parseDescriptorFile (AsyncTask #1)
(15-10-22 17:46:01.363) @ dancingmoon.bestboard.SoftBoardService.onCreateInputView (main)
(15-10-22 17:46:01.365) @ dancingmoon.bestboard.SoftBoardService.noKeyboardView (main)
(15-10-22 17:46:01.368) @ dancingmoon.bestboard.SoftBoardParser.parseSoftBoard (AsyncTask #1)
(15-10-22 17:46:01.372) @ dancingmoon.bestboard.Commands.createDataMap (AsyncTask #1)
(15-10-22 17:46:01.378) Warning text is empty!

*​*​* Uncaught exception: AsyncTask #1 (15-10-22 17:46:01.487)  *​*​*

*​*​* java.lang.NullPointerException
Attempt to invoke virtual method java.lang.String java.lang.Object.toString() on a null object reference
 @ dancingmoon.bestboard.SoftBoardParser.parseLabelParameter (SoftBoardParser.java/801)
 @ dancingmoon.bestboard.SoftBoardParser.parseComplexParameter (SoftBoardParser.java/513)
 @ dancingmoon.bestboard.SoftBoardParser.parseSoftBoard (SoftBoardParser.java/298)
 @ dancingmoon.bestboard.SoftBoardParser.parseDescriptorFile (SoftBoardParser.java/238)
 @ dancingmoon.bestboard.SoftBoardParser.doInBackground (SoftBoardParser.java/161)
 @ dancingmoon.bestboard.SoftBoardParser.doInBackground (SoftBoardParser.java/24)
 @ android.os.AsyncTask$2.call (AsyncTask.java/288)
 @ java.util.concurrent.FutureTask.run (FutureTask.java/237)
 @ android.os.AsyncTask$SerialExecutor$1.run (AsyncTask.java/231)
 @ java.util.concurrent.ThreadPoolExecutor.runWorker (ThreadPoolExecutor.java/1112)
 @ java.util.concurrent.ThreadPoolExecutor$Worker.run (ThreadPoolExecutor.java/587)
 @ java.lang.Thread.run (Thread.java/818)

*​*​* Caused:
*​*​* java.lang.RuntimeException
>An error occured while executing doInBackground()<
 @ android.os.AsyncTask$3.done (AsyncTask.java/300)
 @ java.util.concurrent.FutureTask.finishCompletion (FutureTask.java/355)
 @ java.util.concurrent.FutureTask.setException (FutureTask.java/222)
 @ java.util.concurrent.FutureTask.run (FutureTask.java/242)
 @ android.os.AsyncTask$SerialExecutor$1.run (AsyncTask.java/231)
 @ java.util.concurrent.ThreadPoolExecutor.runWorker (ThreadPoolExecutor.java/1112)
 @ java.util.concurrent.ThreadPoolExecutor$Worker.run (ThreadPoolExecutor.java/587)
 @ java.lang.Thread.run (Thread.java/818)

*​*​* End of uncaught exception *​*​*
++