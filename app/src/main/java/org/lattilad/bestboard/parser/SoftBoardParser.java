package org.lattilad.bestboard.parser;

import android.content.Context;
import android.content.SharedPreferences;
import android.graphics.Typeface;
import android.os.AsyncTask;
import android.os.Environment;
import android.preference.PreferenceManager;

import org.lattilad.bestboard.Layout;
import org.lattilad.bestboard.R;
import org.lattilad.bestboard.SoftBoardData;
import org.lattilad.bestboard.debug.Debug;
import org.lattilad.bestboard.scribe.Scribe;
import org.lattilad.bestboard.utils.ArrayUtils;
import org.lattilad.bestboard.utils.Bit;
import org.lattilad.bestboard.utils.ExtendedList;
import org.lattilad.bestboard.utils.ExtendedMap;
import org.lattilad.bestboard.utils.ExternalDataException;
import org.lattilad.bestboard.utils.KeyValuePair;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStreamReader;
import java.lang.reflect.InvocationTargetException;
import java.security.InvalidKeyException;
import java.util.List;
import java.util.Map;

//import java.util.ArrayList;


public class SoftBoardParser extends AsyncTask<Void, Void, Integer>
    {
    /**
     ** PRIVATE VARIABLES
     **/

    /** IN: Layout descriptor file source contains layout data in human readable coat format */
    private File directoryFile;

    private String descriptorFileName;


    /** OUT: Softboard's data generated from descriptor file on the background thread */

    // parseDescriptorFile creates tokenizer - temporary and can change because of INCLUDE
    private Tokenizer tokenizer;

    public Tokenizer getTokenizer()
        {
        return tokenizer;
        }

    // parseSoftBoard creates softBoardata
    private SoftBoardData softBoardData;

    // parseSoftBoard creates labels - temporary
    private Labels labels;

    // parseSoftBoard creates default values for complex parameters - temporary
    private ExtendedMap< Long, ExtendedMap< Long, Object>> defaults;

    public ExtendedMap< Long, ExtendedMap< Long, Object>> getDefaults()
        {
        return defaults;
        }

    // (Static) Commands class is needed, too

    // number of errors are collected here
    private int errorSummary = 0;


    /**
     * Methods needed by parsing phase (during data-load).
     * It should be cleared, after data-load is ready.
     */
    public MethodsForCommands methodsForCommands;


    /**
     ** INNER EXCEPTIONS
     **/

    /**
     * Asynctask was cancelled explicitly
     * (It has only the default constructor without parameters.
     *  The needed serialVersionUID was generated by Android Studio)
     */
    private class TaskCancelledException extends Exception
        {
        private static final long serialVersionUID = -6627468069410136263L;
        }

    /**
     * Cannot validate coat file (because COAT is NOT the first token)
     * (It has only the default constructor without parameters.
     *  The needed serialVersionUID was generated by Android Studio)
     */
    private class InvalidCoatFileException extends Exception
        {
        private static final long serialVersionUID = 1165412659034734800L;
        }

    /**
     ** CRITICAL ERRORS ON BACKGROUND THREAD
     ** All values should be negative!!
     **/

    /** Background task was cancelled - this is not a real error, but task was not finished */
    public static final int CANCEL = -1;

    /** Could not find descriptor file */
    public static final int CRITICAL_FILE_NOT_FOUND_ERROR = -2;

    /** IO error reading descriptor file */
    public static final int CRITICAL_IO_ERROR = -3;

    /** Not valid descriptor file */
    public static final int CRITICAL_NOT_VALID_FILE_ERROR = -4;

    /** Critical error during parsing phase: no layout is defined */
    public static final int CRITICAL_PARSING_ERROR = -5;


    /**
     ** ASYNCTASK - CONNECTION TO CALLER PART
     **/

    /** Asynctask's caller - context and callbacks */
    private SoftBoardParserListener caller;

    /** The interface of asynctask's caller */
    public interface SoftBoardParserListener
        {
        /**
         * Get application context.
         * This method is defined by both Service and Activity.
         * @return application context
         */
        Context getApplicationContext();

        // SoftBoardListener getSoftBoardDataListener();

        /**
         * Callback method is called after background task has finished without critical errors.
         * @param softBoardData newly generated class containing all softboard data
         * @param errorCount number of non-critical errors (error messages can be found in the log)
         */
        void softBoardParserFinished(SoftBoardData softBoardData, int errorCount);

        /**
         * Callback method is called after critical error has stopped the background task.
         * @param errorInfo id of the critical error
         */
        void softBoardParserCriticalError(int errorInfo);
        }


    /**
     * Constructor is used instead of standard AsyncTask params,
     * because there are parameters with different types.
     * http://stackoverflow.com/questions/16765415/should-i-give-params-to-the-constructor-or-to-asynctask-executeparams
     * @param caller SoftBoardService implementing SoftBoardParserListener
     * @param directoryFile working directory
     * @param descriptorFileName descriptor (coat) file
     */
    public SoftBoardParser(SoftBoardParserListener caller, File directoryFile, String descriptorFileName)
        {
        super();

        Scribe.locus( Debug.PARSER );

        this.caller = caller;
        this.directoryFile = directoryFile;
        this.descriptorFileName = descriptorFileName;
        }


    /**
     * Background thread will parse information from descriptor file into softBoardData class.
     * Cancellation is signalled as CancellationException through the inner methods.
     * @return 0: ok;
     * negative values: critical error, execution was stopped;
     * positive values: non-critical errors were logged, execution was finished successfully
     */
    @Override
    protected Integer doInBackground(Void... voids)
        {
        Scribe.locus( Debug.PARSER );

        try
            {
            parseMainDescriptorFile( );
            return errorSummary;
            }
        catch (TaskCancelledException tce)
            {
            // onCancelled() is called, but we do not need it, as caller was destroyed
            return CANCEL;
            }
        catch (FileNotFoundException fnfe)
            {
            return CRITICAL_FILE_NOT_FOUND_ERROR;
            }
        catch (IOException ioe)
            {
            return CRITICAL_IO_ERROR;
            }
        catch (InvalidCoatFileException icfe)
            {
            return CRITICAL_NOT_VALID_FILE_ERROR;
            }
        catch (ExternalDataException ede)
            {
            return CRITICAL_PARSING_ERROR;
            }
        }

    /**
     * Background work was finished.
     * (Cancellation calls onCancel(), this method is NOT called!)
     * @param error 0: ok;
     * negative values: critical error, execution was stopped;
     * positive values: non-critical errors were logged, execution was finished successfully
     */
    @Override
    protected void onPostExecute(Integer error)
        {
        Scribe.locus(Debug.PARSER);

        if ( error >= 0 )
            caller.softBoardParserFinished(softBoardData, error);
        else
            caller.softBoardParserCriticalError(error);
        }


    /**********************************************************************************************
     **                                   P A R S E R  P A R T                                   **
     **********************************************************************************************/


    /**
     * Parsing of a coat descriptor file always starts here.
     * All data structures are filled up, and parsing is started.
     * After parsing all data structures are finished.
     * @throws TaskCancelledException
     * @throws IOException
     * @throws InvalidCoatFileException
     * @throws ExternalDataException
     */
    public void parseMainDescriptorFile() throws TaskCancelledException, IOException, InvalidCoatFileException, ExternalDataException
        {
        Scribe.locus( Debug.PARSER );

        Scribe.clear_secondary(); // Secondary config will store data from ONE run
        Scribe.note_secondary(caller.getApplicationContext().getString(R.string.parser_starting));

        File descriptorFile = new File( directoryFile, descriptorFileName );
        // Descriptor file check
        if ( !descriptorFile.exists() || !descriptorFile.isFile())
            {
            Scribe.error_secondary(caller.getApplicationContext().getString(R.string.parser_no_coat_file));
            throw new FileNotFoundException();
            }

        // START PARSING OF MAIN DESCRIPTOR FILE
        long startTime = System.nanoTime();

        // Prepare data classes
        labels = Commands.createLabels();
        defaults = new ExtendedMap<>();
        softBoardData = new SoftBoardData( );

        methodsForCommands = new MethodsForCommands( softBoardData, this );
        methodsForCommands.createDefaults();

        // Parse main file
        parseDescriptorFile( descriptorFile );

        // Finish data classes

        // Starting abbreviatons-collection should be set after loading data
        softBoardData.codeTextProcessor.init( methodsForCommands.abbrevKeySet );

        // Typeface should be set for TitleDescriptor and all layouts
        if ( methodsForCommands.typefaceFile != null )
            {
            try
                {
                Typeface typeface = Typeface.createFromFile(methodsForCommands.typefaceFile);
                note(R.string.data_typeface, typeface.toString());
                //TitleDescriptor.setTypeface(typeface);
                softBoardData.typeface = typeface;

                for (Layout layout : methodsForCommands.layouts.values())
                    {
                    layout.setMonitorTypeface(typeface);
                    }
                }
            catch (Exception e)
                {
                error(R.string.data_typeface_missing, methodsForCommands.typefaceFile.toString());
                }
            }
        // if no file is given, then softBoardData constructor will delete static typeface,
        // so no need to set default null values

        if ( softBoardData.firstLayout == null )
            {
            throw new ExternalDataException("No layout!");
            }

        // if no root board is specified,
        // then a new board is created (id: 1L) using the first non-wide layout.
        // This new board will be used as root.
        if  ( !softBoardData.boardTable.isRootBoardDefined() )
            {
            softBoardData.boardTable.addBoard( 1L, softBoardData.firstLayout, true );
            softBoardData.boardTable.defineRootBoard( 1L );
            error(R.string.data_primary_board_missing, "");
            }

        // FINISH PARSING OF MAIN DESCRIPTOR FILE
        long endTime = System.nanoTime();

        Scribe.note( Debug.TIMER, "Time for parsing: " +
                ((endTime - startTime) / 1000000) + " msec");
        }


    /** error withot tokenizer */
    private void error( int messageResource, String value )
        {
        errorSummary++;
        Scribe.error_secondary( caller.getApplicationContext().getString( messageResource ) +
                " " + value);
        }


    /** note without tokenizer */
    private void note( int messageResource, String value )
        {
        Scribe.note_secondary( caller.getApplicationContext().getString( messageResource ) +
                " " + value);
        }


    /**
     * Tokenizer stream is created from descriptor file.
     * Parser methods work on this tokenizer.
     * @param descriptorFile descriptor (coat) file
     * @throws TaskCancelledException background thread was cancelled by the caller
     * @throws FileNotFoundException descriptor (coat) file missing
     * @throws IOException  descriptor (coat) file reading fails
     * @throws InvalidCoatFileException descriptor file is not valid (COAT should be the first token!)
     */
    public void parseDescriptorFile(File descriptorFile) throws TaskCancelledException, IOException, InvalidCoatFileException, ExternalDataException
        {
        Scribe.locus( Debug.PARSER );

        Scribe.note_secondary(caller.getApplicationContext().getString(R.string.parser_coat_file) + descriptorFileName);

        BufferedReader reader = null;
        Tokenizer tokenizerBackup = tokenizer;

        try
            {
            reader = new BufferedReader( new InputStreamReader( new FileInputStream( descriptorFile ), "UTF-8" ) );
            // "external" tokenizer is needed for MethodsForCommands
            tokenizer = new Tokenizer( caller.getApplicationContext(), reader );
            // included coat files should use softboard's default alfa
            tokenizer.setDefaultAlfa( softBoardData.defaultAlfa );

            parseSoftBoard();

            // Both error types (from the tokenizer and from the parser) shoud be counted
            errorSummary += tokenizer.getErrorCount();

            // tokenizer remains if Expection occurs, but no further tokens are needed then
            tokenizer = tokenizerBackup;
            }

        // TaskCancelledException, IOException, InvalidCoatFileException are not cached,
        // these are thrown back to doInBackground()!

        finally
            {
            if (reader != null)
                {
                try
                    {
                    reader.close();
                    }
                catch (IOException ioe)
                    {
                    Scribe.error("ERROR IN CLOSE (Descriptor file processing) " + ioe.toString());
                    }
                }
            }
        }


    /**
     * Creates a new Labels class, then starts parsing
     * of the parameter list of the virtual ADDSOFTBOARD command.
     * @throws TaskCancelledException background thread was cancelled by the caller
     * @throws IOException descriptor (coat) file reading fails
     * @throws InvalidCoatFileException descriptor file is not valid (COAT should be the first token!)
     */
    private void parseSoftBoard()
            throws TaskCancelledException, IOException, InvalidCoatFileException, ExternalDataException
        {
        Scribe.locus(Debug.PARSER);

        Object temp;
        // COAT 2 - MUST BE the first parameter-command!
        // It is NOT part of the Commands class, it will be checked "manually"
        if ( tokenizer.nextToken() != Tokenizer.TYPE_KEYWORD ||
                tokenizer.getIntegerToken() != Commands.TOKEN_COAT ||
                (temp = parseOneParameter( Commands.PARAMETER_LONG)) == null ||
                (long)temp > Commands.COAT_VERSION )
            {
            tokenizer.error( R.string.parser_coat_file_invalid, String.valueOf(Commands.COAT_VERSION) );
            throw new InvalidCoatFileException();
            }
        else
            {
            tokenizer.note(R.string.parser_coat_file_ok, temp.toString());
            }

        try
            {
            tokenizer.note( R.string.parser_file_parsing_started );
            parseComplexParameter( Commands.ADDSOFTBOARD, Commands.get(Commands.ADDSOFTBOARD), false );
            if ( tokenizer.getTokenType() == Tokenizer.TYPE_EOF )
                tokenizer.note( R.string.parser_file_parsing_finished );
            else
                tokenizer.error( R.string.parser_file_parsing_interrupted );
            }
        catch (InvalidKeyException e)
            {
            tokenizer.error( R.string.parser_addsoftboard_data_missing );
            }

        }


    /**
     * Parses a complex parameter-command list, without parentheses.
     * Each parameter-command in the list is evaluated,
     * and the method of each parameter-command is called
     * with the appropriate parameter list.
     * Returns the return-values of each parameter-command
     * identified by the token-code of its command.
     * @param parsedCommandCode parameters of this command are evaluated
     * @param parsedCommandData data for command, which contains allowed parameters
     * @param useDefaults default parameters can be given, if this is not label/default evaluation
     * Usually code determines allowed parameters (through the data class),
     * but this is not obligatory. Code is used only if a complex label is given.
     * @return return-values of the parameters in the list
     * @throws IOException (coat) file reading fails
     */
    private ExtendedMap<Long, Object> parseComplexParameter( long parsedCommandCode,
                                                             Commands.Data parsedCommandData,
                                                             boolean useDefaults )
            throws IOException, ExternalDataException, InvalidCoatFileException,
            TaskCancelledException
        {
        Scribe.debug(Debug.PARSER, "Parsing of parameters of [" + Tokenizer.regenerateKeyword(parsedCommandCode) + "] complex command has started.");

        int tokenType;
        
        // Parameter-command's (inside cycle) code and data
        long commandCode;
        String commandString; // Just for debugging
        Commands.Data commandData;

        // allowedParameterCommands signs, that this parameter is
        // multiple (-1), single (+1), not allowed (0)
        int commandMultiple;

        // Complex parameter-list forwarded to the method
        ExtendedMap<Long, Object> forwardParameters = null;

        // Result from the method - or the value of the one-parameter 
        Object result;
        Object previousResult;

        // Parameter list (results of the called methods of the parameter-commands) will be returned to the caller
        // Every cycle can give a new item to returnParameters
        ExtendedMap<Long, Object> returnParameters;

        // Before the cycles DEFAULT VALUES populates returnParameters
        if ( useDefaults && defaults.containsKey( parsedCommandCode ) )
            {
            returnParameters = defaults.get(parsedCommandCode).getCopy();
            Scribe.debug(Debug.PARSER, "Default values (label) for [" + Tokenizer.regenerateKeyword(parsedCommandCode) +
                    "] are found: [" + returnParameters + "]");
            }
        else
            {
            returnParameters = new ExtendedMap<>();
            }

        // iterate the parameter-commands of the caller
        while (true)
            {
            // FIRST: token should be an allowed parameter-command keyword
            tokenType = tokenizer.nextToken();

            // Checking valid parameter-commands
            if ( tokenType == Tokenizer.TYPE_KEYWORD )
                {
                commandCode = tokenizer.getIntegerToken();
                commandString = tokenizer.getStringToken();
                // tokenizer.note( commandString, R.string.parser_code, Long.toHexString(commandCode) );

                Scribe.debug( Debug.PARSER, " * Parsing of parameter [" + commandString + "] for [" +
                        Tokenizer.regenerateKeyword( parsedCommandCode ) + "] has started.");

                // Valid keyword, but not allowed parameter-command - this can be a LABEL
                if ( ( commandMultiple = ArrayUtils.containsWithoutSignedBit(parsedCommandData.getAllowedParameters(), commandCode)) == 0 )
                    {
                    try
                        {
                        labels.select( commandCode );

                        if ( parsedCommandData.isLabelTypeAllowed( labels.getTypeOfSelected() ))
                            {

// !!!! THIS SHOULD BE REVIWED !!!! WHAT ABOUT EXTENDED COPY ???? //
// returnParameters.addCopy ( labels.getValueOfSelected - which is a complex list )

                            // label key is given as commandCode, while type is the parsed commandCode !! forwardParameters is used only as a tromporary storage here
                            forwardParameters = (ExtendedMap<Long, Object>) labels.getValueOfSelected(); // .get( commandCode, parsedCommandCode );

                            Scribe.debug( Debug.PARSER, "[" + commandString + "] is identified as a label. Value: [" +
                                    forwardParameters + "]");

                            // All elements are copied into returnedParameters
                            // each entry should be checked if multiple or not
                            for (Map.Entry<Long, Object> entry : forwardParameters.entrySet())
                                {
                                if (entry.getKey() > 0L) // SINGLE
                                    {
                                    returnParameters.put(entry.getKey(), entry.getValue());
                                    }
                                else // MULTIPLE
                                    {
                                    ExtendedList<KeyValuePair> list =
                                            (ExtendedList<KeyValuePair>) returnParameters.get(entry.getKey());

                                    if (list == null)
                                        {
                                        list = new ExtendedList<KeyValuePair>();
                                        returnParameters.put(entry.getKey(), list);
                                        }
                                    list.addAll((ExtendedList<KeyValuePair>) (entry.getValue()));
                                    }
                                }
                            }
                        else // This label is not allowed here
                            {
                            tokenizer.error(commandString, R.string.parser_parameter_invalid,
                                    Tokenizer.regenerateKeyword( commandCode ));
                            // parameter-block (if any) will be skipped as unexpected block
                            }
                        }
                    catch (InvalidKeyException e)
                        {
                        tokenizer.error(commandString, R.string.parser_parameter_invalid,
                                Tokenizer.regenerateKeyword( commandCode ));
                        // parameter-block (if any) will be skipped as unexpected block
                        }

                    // this token (label) was consumed, cycle to the next token
                    continue;
                    }

                // An allowed parameter-command is ready here, step to second
                }

            // Parsing of complex parameter finishes here
            else if ( tokenType == Tokenizer.TYPE_END || tokenType == Tokenizer.TYPE_EOF )
                {
                break;
                }

            // Unexpected block should be skipped
            else if ( tokenType == Tokenizer.TYPE_START )
                {
                tokenizer.error( R.string.parser_block_skipped );
                tokenizer.pushBackLastToken();
                tokenizer.skipBlock();
                continue;
                }

            // Character, Fraction, Integer, String, (Eol) are not allowed!
            else
                {
                tokenizer.error( R.string.parser_command_missing, tokenizer.getStringToken());
                continue;
                }


            // SECOND: we should evaluate the parameter-list of the checked parameter-command
            // Data of the parameter-command is needed
            try
                {
                commandData = Commands.get( commandCode );
                }
            catch (InvalidKeyException e)
                {
                tokenizer.error( commandString, R.string.parser_data_missing);
                // parameter-block (if any) will be skipped as unexpected block
                continue;
                }

            // Type can be:
            // Complex parameter:
            //      Parameters for method: forwardParameters (ExtendedMap)
            //      Returned value: result of the method (if any) - or nothing
            // One parameter
            //      Parameters for method: result (Object)
            //      Returned value: result of the method (if any) - or itself (result)
            // Label parameter
            //      No further method is called
            // Flag parameter - doesn't have any parameter, but still will be stored
            // among returnParameters with a fake (long command-code itself) Object
            //      Parameters for method: none ()
            //      Returned value: result of the method (if any) - or the fake Object
            // No parameter
            //      Parameters for method: none ()
            //      Returned value: result of the method (if any) or nothing

            // Result is cleared here, because it can contain the parameter itself (one-parameter)
            // Or the result of the method (if any), or should be null
            result = null;

            // Parameter-command has COMPLEX parameters
            if ( Bit.setSignedBitOff(commandData.getParameterType()) >= Tokenizer.TOKEN_CODE_SHIFT )
                {
                Scribe.debug( Debug.PARSER, "[" + commandString + "] is identified as COMPLEX parameter. " );
                // surrounding parentheses are checked here
                if (tokenizer.nextToken() != Tokenizer.TYPE_START)
                    {
                    tokenizer.error(commandString, R.string.parser_list_missing);
                    tokenizer.pushBackLastToken();
                    continue;
                    }

                // tokenizer.note( commandString, R.string.parser_complex_started);
                forwardParameters = parseComplexParameter(commandCode, commandData, true );

                // forward results of previous parameter-commands with the same code to method
                // forwarded value can be null
                // !! multiple parameters should be used !!
                // forwardParameters.put(commandCode, returnParameters.get(commandCode));

                // END and EOF can be returned, but evaluation can be performed normally
                if (tokenizer.nextToken() != Tokenizer.TYPE_END)
                    {
                    tokenizer.error(commandString, R.string.parser_bracket_missing);
                    }
                // tokenizer.note( commandString, R.string.parser_complex_finished, forwardParameters.toString() );

                Scribe.debug( Debug.PARSER, "Result of COMPLEX parameter [" + commandString + "]: " + forwardParameters );
                // parameters for method are in forwardParameters, result is cleared
                }

            // Parameter-command has ONE parameter
            else if ( Bit.setSignedBitOff(commandData.getParameterType()) <= Commands.PARAMETER_KEYWORD )
                {
                result = parseOneParameter( commandData.getParameterType());
                // tokenizer.note( commandString, R.string.parser_one_finished, result.toString() );

                Scribe.debug( Debug.PARSER, "[" + commandString + "] is identified as ONE parameter. Result: " + result );

                if ( result ==null )
                    {
                    // There was an error, log was already sent, but this parameter cannot be consumed
                    continue;
                    }

                // parameters for method are in result
                }

            // Parameter-command has LIST parameter
            else if ( Bit.setSignedBitOff(commandData.getParameterType()) <= (Commands.PARAMETER_KEYWORD | Commands.PARAMETER_MOD_LIST) )
                {
                result = parseListParameter( commandData.getParameterType() );
                // tokenizer.note( commandString, R.string.parser_list_finished, result.toString() );

                Scribe.debug( Debug.PARSER, "[" + commandString + "] is identified as LIST parameter. Result: " + result );

                if ( result ==null )
                    {
                    // List is completely missing, log was already sent,
                    // but this parameter cannot be consumed
                    continue;
                    }

                // parameters for method are in result
                }

            // Parameter-command has DEFAULT parameter
            else if ( commandData.getParameterType() == Commands.PARAMETER_DEFAULT )
                {
                Scribe.debug( Debug.PARSER, "[" + commandString + "] creates default complex parameters." );

                parseDefaultParameter();
                continue;

                // no method to call; no result to return
                }

            // Parameter-command has LABEL parameter
            else if ( commandData.getParameterType() == Commands.PARAMETER_LABEL )
                {
                Scribe.debug(Debug.PARSER, "[" + commandString + "] creates label.");

                parseLabelParameter(true); // Label change is not detected any more, parameter is not used!!
                continue;

                // no method to call; no result to return
                }

            // Parameter-command has CHANGE_LABEL parameter
            else if ( commandData.getParameterType() == Commands.PARAMETER_CHANGE_LABEL )
                {
                Scribe.debug( Debug.PARSER, "[" + commandString + "] creates label." );

                parseLabelParameter(false);
                continue;

                // no method to call; no result to return
                }

            // Parameter-command has COAT parameter
            else if ( commandData.getParameterType() == Commands.PARAMETER_COAT )
                {
                Scribe.debug( Debug.PARSER, "[" + commandString + "] includes an other coat file." );
                // A complete new coat file is loaded - then parsing returns to the previous coat file
                parseCoatParameter();
                continue;

                // no method to call; no result to return
                }

            // Parameter-command has FLAG (true) parameter
            else if ( commandData.getParameterType() == Commands.PARAMETER_FLAG )
                {
                Scribe.debug( Debug.PARSER, "[" + commandString + "] is identified as FLAG." );

                // fake Object is needed to be stored among returnParameters
                result = Boolean.TRUE;
                }

            // Parameter-command has FLAG (false) parameter
            else if ( commandData.getParameterType() == Commands.PARAMETER_FLAG_FALSE )
                {
                Scribe.debug( Debug.PARSER, "[" + commandString + "] is identified as FALSE FLAG." );

                // fake Object is needed to be stored among returnParameters
                result = Boolean.FALSE;
                }

            // Parameter-command is a special STOP message
            else if ( commandData.getParameterType() == Commands.MESSAGE_STOP )
                {
                Scribe.debug( Debug.PARSER, "[" + commandString + "] is identified as STOP MESSAGE. This block is skipped." );

                // force to finish this block
                tokenizer.stopBlock();
                break;
                }

            // Parameter-command has NO parameters
            // else
            // No parameters for method, result remains null

            // THIRD: method is called with the appropriate parameters
            // Returned value (if any) is put into returnParameters
            if ( commandData.hasMethodToCall() )
                {
                // tokenizer.note( commandString, R.string.parser_method_called );

                Scribe.debug( Debug.PARSER, "[" + commandString + "] is calling: " + commandData.getMethod().getName() );

                try
                    {
                    // Different types of methods should be called - according to parameter type

                    // Parameter-command has COMPLEX parameters - forwardParameters
                    if ( commandData.getParameterType() >= Tokenizer.TOKEN_CODE_SHIFT || commandData.getParameterType() < 0L )
                        {
                        result = commandData.getMethod().invoke( methodsForCommands, forwardParameters);
                        // As 'get' removes the entries from forwardparameters, it should be empty after the call

                        if ( forwardParameters.size() > 0 )
                            {
                            StringBuilder builder = new StringBuilder();
                            for (Map.Entry<Long, Object> entry : forwardParameters.entrySet())
                                {
                                builder.append( Tokenizer.regenerateKeyword(entry.getKey() ));
                                builder.append(" ");
                                }

                            tokenizer.error( commandString, R.string.parser_parameter_remains , builder.toString());
                            }
                        }
                    // Parameter-command has ONE parameter - result
                    else if ( commandData.getParameterType() <= Commands.PARAMETER_KEYWORD )
                        result = commandData.getMethod().invoke( methodsForCommands, result );
                    // Parameter-command has LIST parameter - result
                    else if ( commandData.getParameterType() <= ( Commands.PARAMETER_KEYWORD | Commands.PARAMETER_MOD_LIST) )
                        result = commandData.getMethod().invoke( methodsForCommands, (List)result );
                    // Parameter-command has NO or FLAG parameters - no parameters
                    else
                        result = commandData.getMethod().invoke( methodsForCommands );
                    // Label-parameters cannot arrive here

                    // if ( result != null )
                        // tokenizer.note( commandString, R.string.parser_result, result.toString() );
                    // else
                        // tokenizer.note( commandString, R.string.parser_method_no_result );

                    Scribe.debug( Debug.PARSER, "[" + commandString + "] results: " + result);
                    }
                catch (IllegalAccessException iae)
                    {
                    tokenizer.error( commandString, R.string.parser_cannot_access_method );
                    // if result was ready (one-parameter) it will be still part of the returnedParameters
                    // but this is NOT the result of the method!
                    }
                catch (InvocationTargetException ite)
                    {
                    // http://stackoverflow.com/a/20525219 getTargetException and getCause
                    Throwable cause = ite.getCause();
                    if ( cause == null )
                        tokenizer.error( commandString, R.string.parser_method_exception_missing );
                    else
                        tokenizer.error( commandString, R.string.parser_method_exception, ite.getCause().toString() );
                    // if result was ready (one-parameter) it will be still part of the returnedParameters
                    // but this is NOT the result of the method!
                    }
                }
            else
                {
                // tokenizer.note( commandString, R.string.parser_no_method_called );
                Scribe.debug( Debug.PARSER, "[" + commandString + "] has no method." );
                }

            // if result is not null, it will part of the returnParameters as groupCode-result pair
            if (result != null)
                {
                long groupCode = commandData.getGroupCode();

                // commandMultiple cannot be 0 (already checked. -1: multiple, +1: single
                if ( commandMultiple > 0 )
                    {
                    // if there was a previous result - it is overwritten
                    previousResult = returnParameters.put( groupCode, result );
                    if ( previousResult == null )
                        {
                        Scribe.debug( Debug.PARSER, "[" + commandString + "] (" + commandCode +
                                ") has single result: " + result + " under group code: " + groupCode );
                        }
                    else
                        {
                        Scribe.debug( Debug.PARSER, "[" + commandString + "] (" + commandCode +
                                ") overwrites previous result (" + previousResult + ") with single result: " + result +
                                " under group code: " + groupCode );
                        tokenizer.note( commandString, R.string.parser_previous_overwritten);
                        }
                    }
                else // MULTIPLE
                    {
                    groupCode = Bit.setSignedBitOn( groupCode );
                    ExtendedList<KeyValuePair> list;

                    list = (ExtendedList<KeyValuePair>)returnParameters.get( groupCode );
                    if ( list == null )
                        {
                        list = new ExtendedList<KeyValuePair>();
                        returnParameters.put( groupCode, list);
                        }

                    list.add( new KeyValuePair( commandCode, result) );
                    Scribe.debug(Debug.PARSER, "[" + commandString + "] (" + commandCode +
                            ") has multiple result: " + list +
                            " under group code: " + groupCode );
                    }
                }

            } // end of cycle

        // Cycle finished with STOP or EOF - but we must not consume the terminating STOP token
        tokenizer.pushBackLastToken();

        Scribe.debug( Debug.PARSER, "[" + Tokenizer.regenerateKeyword(parsedCommandCode) + "] complex command is resulted: " + returnParameters );

        return returnParameters;

        //Char End Eof Eol Fract Int Keyword String Start
        }


    /**
     * Parses one-parameter type parameters. Parameter can be inside parentheses.
     * Currently BOOLEAN (Boolean), CHAR(Long), COLOR(Integer), LONG(Long),
     * FILE(String), STRING(String) and KEYWORD(Long) can be parsed.
     * The method will find LABELS as well.
     * The precision of numeric values will be checked.
     * CHAR precision numeric values can be returned as string.
     * @param parameterType as defined in the Commands class
     * @return the value of the parameter, or null if parameter is invalid
     * @throws IOException (coat) file reading fails
     */
    private Object parseOneParameter( long parameterType) throws IOException
        {
        String forParameter = tokenizer.getStringToken();

        Object result; // null == error
        boolean bracket = false;

        // 1st - optional - token is OPENING BRACKET
        if ( tokenizer.nextToken() == Tokenizer.TYPE_START )
            {
            bracket = true;
            }
        else
            {
            tokenizer.pushBackLastToken();
            }

        // 2nd token is PARAMETER - null and error message, if invalid
        result = parseParameter( parameterType, true, forParameter );

        // 3rd token CLOSING BRACKET (If bracket was opened, it should also be closed)
        if ( bracket )
            {
            if ( tokenizer.nextToken() != Tokenizer.TYPE_END )
                {
                tokenizer.error( forParameter, R.string.parser_bracket_missing );
                tokenizer.pushBackLastToken();
                // There are several ways to resolve this mistake.
                // Result (if ready) is returned, invalid token is pushed back for further analysis
                }
            }

        // tokenizer.note( forParameter, R.string.parser_result, result.toString() );
        // Returning result
        return result;
        }


    /**
     * Parses list of one-parameter type parameters.
     * List elements should have the same type.
     * Each parameter of the list is get by parseOneParameter().
     * @param parameterType as defined in the Commands class
     * (can be one-parameter or list-parameter type)
     * @return list of the parameter values as an array-list, or null if list is completely missing
     * @throws IOException (coat) file reading fails
     */
    private List<Object> parseListParameter( long parameterType) throws IOException
        {
        String forParameter = tokenizer.getStringToken();

        List<Object> result = new ExtendedList<Object>();
        Object element;

        // 1st token is obligatory OPENING-BRACKET
        if ( tokenizer.nextToken() != Tokenizer.TYPE_START )
            {
            tokenizer.error( forParameter, R.string.parser_value_list_missing);
            tokenizer.pushBackLastToken();
            return null;
            }

        // 5. bit of parameter type should be turned 0
        parameterType &= (~Commands.PARAMETER_MOD_LIST);

        // Next tokens: one-parameter type tokens, terminated by TYPE_END
        while ( true )
            {
            element = parseParameter( parameterType, false, forParameter );

            // only valid elements are added
            if ( element != null )
                {
                result.add( element );
                }

            // token evaluation should be continued, if returned value is not valid

            // Termination should be evaluated first, not to send error message
            else if ( tokenizer.getTokenType() == Tokenizer.TYPE_END )
                {
                break;
                }
            // element is invalid because of EOF
            else if ( tokenizer.getTokenType() == Tokenizer.TYPE_EOF )
                {
                tokenizer.error( forParameter, R.string.parser_bracket_missing );
                break;
                }
            }

        return result;
        }


    /**
     * Parses the next token according to one-parameter type parameters.
     * Currently BOOLEAN (Boolean), CHAR(Long), COLOR(Integer), LONG(Long),
     * FILE(String), STRING(String) and KEYWORD(Long) can be parsed.
     * The method will find LABELS as well.
     * The precision of numeric values will be checked.
     * CHAR precision numeric values can be returned as string.
     * If parameter is invalid then null is returned after an error message.
     * TYPE_END token is not consumed and no error message is sent!
     * @param parameterType as defined in the Commands class - IT SHOULD BE A REAL ONE-PARAMETER!
     * @param obligatory if parameter is obligatory (TYPE_END sends error message)
     * @param forParameter textual name of parameter-command (just for debugging)
     * @return the value of the parameter, or null if parameter is invalid
     * @throws IOException (coat) file reading fails
     */
    private Object parseParameter( long parameterType, boolean obligatory, String forParameter ) throws IOException
        {
        Object result = null; // null == error

        int tokenType = tokenizer.nextToken();
        try
            {
            // 2nd token is PARAMETER token
            if ( tokenType == Tokenizer.TYPE_INTEGER )
                {
                // BOOLEAN CHAR COLOR INT LONG
                if ( parameterType <= Commands.PARAMETER_LONG )
                    {
                    // Parameter: NUMERIC, Token: NUMERIC, Return: LONG
                    result = tokenizer.getIntegerToken();
                    }
                else if ( parameterType == Commands.PARAMETER_TEXT)
                    {
                    // Parameter: TEXT, Token: INTEGER, Return: CHARACTER (from char)
                    result = tokenizer.getIntegerToken();
                    // result will be checked as character
                    parameterType = Commands.PARAMETER_CHAR;
                    }
                else // file, string and keyword parameter types
                    tokenizer.error( forParameter, R.string.parser_invalid_numeric );
                }

            else if ( tokenType == Tokenizer.TYPE_CHARACTER )
                {
                // BOOLEAN CHAR COLOR INT LONG
                if ( parameterType <= Commands.PARAMETER_LONG )
                    {
                    // Parameter: NUMERIC, Token: CHARACTER, Return: LONG
                    result = tokenizer.getIntegerToken();
                    }
                else if ( parameterType == Commands.PARAMETER_TEXT)
                    {
                    // Parameter: TEXT, Token: CHARACTER, Return: CHARACTER (from char)
                    result = tokenizer.getIntegerToken();
                    // result will be checked as character
                    parameterType = Commands.PARAMETER_CHAR;
                    }
                else // file, string, keyword parameter types
                    tokenizer.error( forParameter, R.string.parser_invalid_character );
                }

            else if ( tokenType == Tokenizer.TYPE_STRING )
                {
                // STRING FILE
                if ( parameterType > Commands.PARAMETER_LONG && parameterType <= Commands.PARAMETER_STRING )
                    {
                    // Parameter: STRING, Token: STRING, Return: STRING
                    result = tokenizer.getStringToken();
                    }
                else if ( parameterType == Commands.PARAMETER_TEXT)
                    {
                    // Parameter: TEXT, Token: STRING, Return: STRING (from string)
                    result = tokenizer.getStringToken();
                    // result will be checked as string
                    parameterType = Commands.PARAMETER_STRING;
                    }
                else  // numeric (BOOLEAN CHAR COLOR INT LONG), keyword parameter types
                    tokenizer.error( forParameter, R.string.parser_invalid_string );
                }

            else if ( tokenType == Tokenizer.TYPE_KEYWORD )
                {
                long key = tokenizer.getIntegerToken();

                if ( parameterType == Commands.PARAMETER_KEYWORD )
                    {
                    // Parameter: KEYWORD, Token: KEYWORD, Return: LONG (code from keyword)
                    result = key;
                    }

                // 2nd token is LABEL token
                else
                    {
                    // CHAR COLOR INT LONG
                    if ( parameterType <= Commands.PARAMETER_LONG )
                        {
                        // RETURN VALID LONG INTEGER (LABEL)
                        result = labels.getLongValue( key );
                        }
                    // FILE STRING
                    else if ( parameterType <= Commands.PARAMETER_STRING )
                        {
                        // RETURN VALID STRING (LABEL)
                        result = labels.getStringValue(key);
                        }
                    else if ( parameterType == Commands.PARAMETER_TEXT)
                        {
                        labels.select( key );
                        if ( labels.isNumericSelected() )
                            {
                            // Parameter: TEXT, Token: KEYWORD (numeric type), Return: CHARACTER (from long/char)
                            result = (Long)labels.getValueOfSelected();
                            parameterType = Commands.PARAMETER_CHAR;
                            }
                        else if ( labels.isStringSelected() )
                            {
                            // Parameter: TEXT, Token: KEYWORD (string type), Return: STRING (from string)
                            result = (String) labels.getValueOfSelected();
                            parameterType = Commands.PARAMETER_STRING;
                            }
                        // Complex labels are not allowed here
                        }
                    else
                        tokenizer.error( forParameter, R.string.parser_invalid_keyword );
                    }
                }
            // Obligatory: 2nd token is MISSING, 3rd token is pushed back (it should not be consumed)
            // Non-obligatory: token is valid, and will be evaluated later
            else if ( tokenType == Tokenizer.TYPE_END )
                {
                if ( obligatory )
                    {
                    tokenizer.error( forParameter, R.string.parser_value_missing );
                    // token is not consumed!
                    tokenizer.pushBackLastToken();
                    }
                // if non-obligatory - further evaluation will be performed
                }
            // 2nd token is MISSING, descriptor file is terminated
            else if ( tokenType == Tokenizer.TYPE_EOF )
                {
                tokenizer.error( forParameter, R.string.parser_terminated );
                }
            // 2nd token is invalid
            else // TOKEN_FRACTION, TOKEN_START
                {
                tokenizer.error( forParameter, R.string.parser_value_invalid );
                }
            }
        catch (InvalidKeyException ike)
            {
            tokenizer.error( forParameter, R.string.parser_no_label, tokenizer.getStringToken());
            }

        if ( result != null )
            {
            // Precision check for BOOLEAN parameter
            if ( parameterType == Commands.PARAMETER_BOOLEAN )
                {
                result = (long) result == 0 ? Boolean.FALSE : Boolean.TRUE;
                }

            // Precision check for CHAR parameter
            else if ( parameterType == Commands.PARAMETER_CHAR )
                {
                if ( (long) result < Character.MIN_VALUE || (long) result > Character.MAX_VALUE )
                    {
                    tokenizer.error( forParameter, R.string.parser_invalid_char_value, Long.toHexString( (long) result ) );
                    // result = (long) result & (long) Character.MAX_VALUE;
                    }
                long temp = (long) result;
                result = (char) temp;
                }

            // Precision check for COLOR parameter
            else if ( parameterType == Commands.PARAMETER_COLOR )
                {
                if ( (long) result < 0L || (long) result > 0xFFFFFFFFL )
                    {
                    tokenizer.error( forParameter, R.string.parser_invalid_color_value, Long.toHexString( (long) result ) );
                    // result = (long) result & 0xFFFFFFFFL;
                    }
                long temp = (long) result;
                result = (int) temp;
                }

            // Precision check for INT parameter
            else if ( parameterType == Commands.PARAMETER_INT )
                {
                if ( (long) result < Integer.MIN_VALUE || (long) result > Integer.MAX_VALUE )
                    {
                    tokenizer.error( forParameter, R.string.parser_invalid_int_value, String.valueOf( (long) result ) );
                    // result = (long) result & ??;
                    }
                long temp = (long) result;
                result = (int) temp;
                }

            // Precision check for FILE parameter
            else if ( parameterType == Commands.PARAMETER_FILE )
                {
                SharedPreferences sharedPrefs = PreferenceManager.
                        getDefaultSharedPreferences( caller.getApplicationContext() );
                String directoryName =
                        sharedPrefs.getString( caller.getApplicationContext().
                                getString( R.string.descriptor_directory_key ), "" );

                File directory = new File( Environment.getExternalStorageDirectory(), directoryName );
                File file = new File( directory, (String) result );

                if ( !file.exists() || !file.isFile() )
                    {
                    tokenizer.error( forParameter, R.string.parser_no_file, (String) result );
                    result = null;
                    }
                else
                    {
                    result = file;
                    }
                }
            }

        // tokenizer.note( forParameter, R.string.parser_result, result.toString() );

        // Error handling - error log was already sent; result is null
        // Returning result
        return result;
        }


    /**
     * Parses parameters after INCLUDE coat command.
     * @throws IOException (coat) file reading fails
     */
    private void parseCoatParameter( )
            throws IOException, ExternalDataException, InvalidCoatFileException,
            TaskCancelledException
        {
        // parse one parameter file name
        File coatFile;

        if ((coatFile = (File)parseOneParameter( Commands.PARAMETER_FILE )) != null )
            {
            // Current parsing stops here temporary
            parseDescriptorFile( coatFile );
            // And returns after finishing the incuded one
            }
        }


    /**
     * Parses parameters after LET command.
     * Parameters are special labelkey-labelvalue pairs, where labelkey is a keyword,
     * and labelvalue is one of TYPE_STRING, TYPE_CHARACTER, TYPE_INTEGER token.
     * These parameters are specially handled, because their type is not known previously,
     * and keywords (labels) are not accepted!
     * @param denyOverwrite if true then overwrite causes error
     * @throws IOException (coat) file reading fails
     */
    private void parseLabelParameter( boolean denyOverwrite )
            throws IOException, ExternalDataException, InvalidCoatFileException,
            TaskCancelledException
        {
        // key part
        long key = 0L;
        String keyString = null; // just for logging

        // type part
        long type = 0L;

        // value part
        Object value = null;
        String valueString = null; // just for logging

        boolean error = false; // ?? is it really needed ?? or can be replaced by value == null

        // 1st token is obligatory OPENING-BRACKET
        int tokenType = tokenizer.nextToken();
        if ( tokenType != Tokenizer.TYPE_START )
            {
            tokenizer.error( R.string.parser_label_key_missing);
            tokenizer.pushBackLastToken();
            return;
            }

        // 2nd token is KEYWORD
        tokenType = tokenizer.nextToken();
        if ( tokenType == Tokenizer.TYPE_KEYWORD )
            {
            // correct label key
            key = tokenizer.getIntegerToken();
            keyString = tokenizer.getStringToken();
            }
        // 2nd and 3rd tokens are MISSING, closing-bracket is consumed
        else if ( tokenType == Tokenizer.TYPE_END )
            {
            tokenizer.error( R.string.parser_label_key_missing );
            return;
            }
        else if( tokenType == Tokenizer.TYPE_EOF )
            {
            tokenizer.error( R.string.parser_terminated );
            return;
            }
        // 2nd token is invalid
        else
            {
            tokenizer.error( R.string.parser_label_key_invalid, tokenizer.getStringToken());
            error = true;
            }

        //3rd token is VALUE
        tokenType = tokenizer.nextToken();

        // Value is string
        if ( tokenType == Tokenizer.TYPE_STRING )
            {
            type = Commands.PARAMETER_STRING;
            value = tokenizer.getStringToken();
            valueString = (String)value;
            }
        // Value is long (character or integer)
        else if ( tokenType == Tokenizer.TYPE_CHARACTER || tokenType == Tokenizer.TYPE_INTEGER )
            {
            type = Commands.PARAMETER_LONG;
            value = (Long) tokenizer.getIntegerToken();
            valueString = tokenizer.getStringToken();
            }
        // Value is complex
        else if ( tokenType == Tokenizer.TYPE_KEYWORD )
            {
            // key - already given
            // type - token of command, commandCode
            // value - parameters of command, evaluated by parseComplexParameter

            type = tokenizer.getIntegerToken();
            String typeString = tokenizer.getStringToken();

            try
                {
                Commands.Data data = Commands.get( type );
                if ( data.isAllowedAsLabel() )
                    {
                    value = parseComplexValue(type, typeString);
                    if (value == null)
                        {
                        // !! Error was already signed !!
                        tokenizer.error(keyString, R.string.parser_label_complex_invalid);
                        error = true;
                        }
                    else
                        {
                        valueString = typeString + ":" + value;
                        }
                    }
                else
                    {
                    tokenizer.error( typeString, R.string.parser_label_complex_not_allowed );
                    // next block should be skipped
                    tokenizer.skipBlock();
                    error = true;
                    }
                }
            catch (InvalidKeyException e)
                {
                tokenizer.error( typeString, R.string.parser_data_missing);
                // next block should be skipped
                tokenizer.skipBlock();
                error = true;
                }
            }
        // 3rd token is MISSING, closing-bracket is consumed
        else if ( tokenType == Tokenizer.TYPE_END )
            {
            tokenizer.error( keyString, R.string.parser_label_value_missing );
            return;
            }
        else if ( tokenType == Tokenizer.TYPE_EOF )
            {
            tokenizer.error( keyString, R.string.parser_terminated );
            return;
            }
        // 3nd token is invalid
        else
            {
            tokenizer.error( keyString, R.string.parser_label_value_invalid, tokenizer.getStringToken());
            error = true;
            }

        // 4th token is obligatory CLOSING BRACKET
        tokenType = tokenizer.nextToken();
        if ( tokenType != Tokenizer.TYPE_END )
            {
            tokenizer.error( R.string.parser_bracket_missing);
            tokenizer.pushBackLastToken();
            // There are several ways to resolve this mistake.
            // Result (if ready) is returned, invalid token is pushed back for further analysis
            }

        // error was already logged
        if (error)
            return;

        // We have a correct label key-type-value pair
        error = labels.add(key, type, value);
        tokenizer.note( keyString, R.string.parser_label_added, valueString );

        Scribe.debug(Debug.PARSER, "Label is " + (error ? "changed:" : " added: ") +
                keyString + "[" + Long.toHexString(key) + "], " + valueString);

        // This label key was previously set!
        if ( error && denyOverwrite )
            {
            tokenizer.error( keyString, R.string.parser_label_overwritten );
            }
        }


    /**
     * Parses parameters after DEFAULT command.
     * Very similar to LET command, only one parameter allowed, brackets are obligatory.
     * Parameter is a complex parameter-command, allowed in ALLOWED_AS_LABEL[]
     * @throws IOException (coat) file reading fails
     */
    private void parseDefaultParameter()
            throws IOException, ExternalDataException, InvalidCoatFileException,
            TaskCancelledException
        {
        // type part
        long type = 0L;
        String typeString = null;

        // value part
        ExtendedMap<Long, Object> value = null; // value == null means error
        String valueString = null; // just for logging

        boolean bracket = false;

        // 1st - optional - token is OPENING BRACKET
        if ( tokenizer.nextToken() == Tokenizer.TYPE_START )
            {
            bracket = true;
            }
        else
            {
            tokenizer.pushBackLastToken();
            }

        //2rd token is VALUE
        int tokenType = tokenizer.nextToken();

        // Value is complex
        if ( tokenType == Tokenizer.TYPE_KEYWORD )
            {
            // type - token of command, commandCode
            // value - parameters of command, evaluated by parseComplexParameter

            type = tokenizer.getIntegerToken();
            typeString = tokenizer.getStringToken();

            try
                {
                Commands.Data data = Commands.get( type );
                if ( data.isAllowedAsDefault() )
                    {
                    value = parseComplexValue(type, typeString);
                    if (value == null)
                        {
                        // !! Error was already signed !!
                        tokenizer.error(typeString, R.string.parser_default_value_invalid);
                        }
                    else
                        {
                        valueString = typeString + ":" + value;
                        }
                    }
                else
                    {
                    tokenizer.error(typeString, R.string.parser_default_complex_not_allowed);
                    // next block should be skipped
                    tokenizer.skipBlock();
                    }
                }
            catch (InvalidKeyException e)
                {
                tokenizer.error(typeString, R.string.parser_data_missing);
                // next block should be skipped
                tokenizer.skipBlock();
                }
            }
        // 2nd token is MISSING
        else if ( tokenType == Tokenizer.TYPE_END )
            {
            tokenizer.error( R.string.parser_default_type_missing);
            // token is not consumed!
            tokenizer.pushBackLastToken();
            return;
            }
        else if ( tokenType == Tokenizer.TYPE_EOF )
            {
            tokenizer.error( R.string.parser_terminated );
            return;
            }
        // 2nd token is invalid
        else
            {
            tokenizer.error( R.string.parser_default_type_invalid, tokenizer.getStringToken());
            }

        // 3rd token CLOSING BRACKET (If bracket was opened, it should also be closed)
        if ( bracket )
            {
            if ( tokenizer.nextToken() != Tokenizer.TYPE_END )
                {
                tokenizer.error( R.string.parser_bracket_missing );
                tokenizer.pushBackLastToken();
                // There are several ways to resolve this mistake.
                // Result (if ready) is returned, invalid token is pushed back for further analysis
                }
            }

        // error was already logged
        if ( value == null )
            return;

        // defaults can be overwritten without notice
        value = defaults.put( type, value );

        tokenizer.note(typeString, R.string.parser_default_added);

        // !! tokenizer.note should be used - or not?? !!
        Scribe.debug(Debug.PARSER, "Default is" + (value == null ? " added: " : "changed: ") + valueString);
        }


    /**
     * Parses the parameters of the complex value inside the LET command.
     * Pattern: START (obligatory) - complex parameter - END (obligatory)
     * @param commandCode
     * @param commandString just for debug
     * @return complex evaluated by parseComplexParameter() (can be empty,
     * OR null if complex is not valid
     * @throws IOException
     */
    private ExtendedMap<Long, Object> parseComplexValue(long commandCode, String commandString)
            throws IOException, ExternalDataException, InvalidCoatFileException,
            TaskCancelledException
        {
        ExtendedMap<Long, Object> result = null;
        Commands.Data commandData;

        // get command's data
        try
            {
            commandData = Commands.get( commandCode );
            }
        catch (InvalidKeyException e)
            {
            // This cannot happen, because command is part of the allowed commands
            tokenizer.error( commandString, R.string.parser_data_missing);
            // parameter-block (if any) will be skipped as unexpected block
            return null;
            }

        // surrounding parentheses are checked here
        if (tokenizer.nextToken() != Tokenizer.TYPE_START)
            {
            tokenizer.error( commandString, R.string.parser_list_missing );
            tokenizer.pushBackLastToken();
            return null;
            }

        else
            {
            // tokenizer.note( commandString, R.string.parser_complex_started);
            result = parseComplexParameter( commandCode, commandData, false );

            // END and EOF can be returned, but evaluation can be performed normally
            if ( tokenizer.nextToken() != Tokenizer.TYPE_END )
                {
                tokenizer.error( commandString, R.string.parser_bracket_missing );
                }
            }

        return result;
        }


    /**
     * Helper method to create String from PARAMETER_TEXT
     * @param text String or Character object - CANNOT CALLED WITH OTHER TYPES!
     * @return String equivalent
     * !! This method is only used for PARAMETER_TEXT,
     * but toString() could be used to make it more general.
     */
    public static String stringFromText( Object text )
        {
        if (text instanceof Character )
            return String.valueOf( (char)text );
        else // if ( temp instanceof String )
            return (String)text;
        }

    }
